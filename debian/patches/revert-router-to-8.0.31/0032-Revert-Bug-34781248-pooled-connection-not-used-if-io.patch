From 96e5ea085648aed18321f766562e806e3a873a87 Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:05:56 -0500
Subject: [PATCH 32/86] Revert "Bug#34781248 pooled connection not used if
 io.threads larger than 1"

This reverts commit c89512b040ff9c5f3268a2f804344f6ca586cd76.
---
 .../include/mysqlrouter/connection_base.h     |  3 ---
 .../src/routing/src/basic_protocol_splicer.h  | 19 -------------------
 router/src/routing/src/classic_connect.cc     | 16 +++++++++-------
 3 files changed, 9 insertions(+), 29 deletions(-)

diff --git a/router/src/connection_pool/include/mysqlrouter/connection_base.h b/router/src/connection_pool/include/mysqlrouter/connection_base.h
index f3b04fb416e..41500494c7d 100644
--- a/router/src/connection_pool/include/mysqlrouter/connection_base.h
+++ b/router/src/connection_pool/include/mysqlrouter/connection_base.h
@@ -70,9 +70,6 @@ class ConnectionBase {
   [[nodiscard]] virtual std::string endpoint() const = 0;
 
   [[nodiscard]] virtual stdx::expected<void, std::error_code> cancel() = 0;
-
-  [[nodiscard]] virtual stdx::expected<void, std::error_code> set_io_context(
-      net::io_context &new_ctx) = 0;
 };
 
 #endif
diff --git a/router/src/routing/src/basic_protocol_splicer.h b/router/src/routing/src/basic_protocol_splicer.h
index b2c58e8e46b..0a788fb2804 100644
--- a/router/src/routing/src/basic_protocol_splicer.h
+++ b/router/src/routing/src/basic_protocol_splicer.h
@@ -127,25 +127,6 @@ class BasicConnection : public ConnectionBase {
 
   net::io_context &io_ctx() override { return sock_.get_executor().context(); }
 
-  stdx::expected<void, std::error_code> set_io_context(
-      net::io_context &new_ctx) override {
-    // nothing to do.
-    if (sock_.get_executor() == new_ctx.get_executor()) return {};
-
-    return sock_.release().and_then(
-        [this, &new_ctx](
-            auto native_handle) -> stdx::expected<void, std::error_code> {
-          socket_type new_sock(new_ctx);
-
-          auto assign_res = new_sock.assign(ep_.protocol(), native_handle);
-          if (!assign_res) return assign_res;
-
-          std::swap(sock_, new_sock);
-
-          return {};
-        });
-  }
-
   void async_recv(recv_buffer_type &buf,
                   std::function<void(std::error_code ec, size_t transferred)>
                       completion) override {
diff --git a/router/src/routing/src/classic_connect.cc b/router/src/routing/src/classic_connect.cc
index 92bfc896be7..8646677e176 100644
--- a/router/src/routing/src/classic_connect.cc
+++ b/router/src/routing/src/classic_connect.cc
@@ -224,6 +224,9 @@ ConnectProcessor::from_pool() {
     return Result::Again;
   }
 
+  auto &io_ctx =
+      connection()->socket_splicer()->client_conn().connection()->io_ctx();
+
   auto &pools = ConnectionPoolComponent::get_instance();
 
   if (auto pool = pools.get(ConnectionPoolComponent::default_pool_name())) {
@@ -240,6 +243,7 @@ ConnectProcessor::from_pool() {
 
     auto pool_res = pool->pop_if(
         [client_caps, ep = mysqlrouter::to_string(server_endpoint_),
+         my_executor = io_ctx.get_executor(),
          requires_tls = connection()->requires_tls()](const auto &pooled_conn) {
           auto pooled_caps = pooled_conn.shared_capabilities();
 
@@ -247,9 +251,11 @@ ConnectProcessor::from_pool() {
               .reset(classic_protocol::capabilities::pos::compress)
               .reset(classic_protocol::capabilities::pos::compress_zstd);
 
-          return (pooled_conn.endpoint() == ep &&  //
-                  client_caps == pooled_caps &&    //
-                  (requires_tls == (bool)pooled_conn.ssl()));
+          return pooled_conn.endpoint() == ep &&  //
+                 client_caps == pooled_caps &&    //
+                 pooled_conn.connection()->io_ctx().get_executor() ==
+                     my_executor &&
+                 (requires_tls == (bool)pooled_conn.ssl());
         });
 
     if (pool_res) {
@@ -263,16 +269,12 @@ ConnectProcessor::from_pool() {
         trace(Tracer::Event().stage(
             "connect::from_pool: " +
             destination_id_from_endpoint(*endpoints_it_)));
-
         // if the socket would be closed, recv() would return 0 for "eof".
         //
         // socket is still alive. good.
         socket_splicer->server_conn() =
             make_connection_from_pooled(std::move(*pool_res));
 
-        (void)socket_splicer->server_conn().connection()->set_io_context(
-            socket_splicer->client_conn().connection()->io_ctx());
-
         stage(Stage::Connected);
         return Result::Again;
       }
-- 
2.37.2

