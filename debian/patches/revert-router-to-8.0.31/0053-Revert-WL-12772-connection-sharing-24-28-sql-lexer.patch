From 44518c8adc32711c207ba3adc5f34c12af332bb7 Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:18:12 -0500
Subject: [PATCH 53/86] Revert "WL#12772 connection-sharing [24/28] -
 sql-lexer"

This reverts commit 55da5eadd66d8ee390d17cb23013e355b3f14b53.
---
 router/src/routing/src/CMakeLists.txt         |   11 -
 router/src/routing/src/sql_lexer.cc           | 1344 -----------------
 router/src/routing/src/sql_lexer.h            |   84 --
 router/src/routing/src/sql_lexer_error.h      |   44 -
 .../src/routing/src/sql_lexer_input_stream.h  |  512 -------
 .../src/routing/src/sql_lexer_parser_input.h  |   52 -
 .../src/routing/src/sql_lexer_parser_state.h  |   90 --
 router/src/routing/src/sql_lexer_thd.h        |   66 -
 router/src/routing/src/sql_lexer_yacc_state.h |  333 ----
 9 files changed, 2536 deletions(-)
 delete mode 100644 router/src/routing/src/sql_lexer.cc
 delete mode 100644 router/src/routing/src/sql_lexer.h
 delete mode 100644 router/src/routing/src/sql_lexer_error.h
 delete mode 100644 router/src/routing/src/sql_lexer_input_stream.h
 delete mode 100644 router/src/routing/src/sql_lexer_parser_input.h
 delete mode 100644 router/src/routing/src/sql_lexer_parser_state.h
 delete mode 100644 router/src/routing/src/sql_lexer_thd.h
 delete mode 100644 router/src/routing/src/sql_lexer_yacc_state.h

diff --git a/router/src/routing/src/CMakeLists.txt b/router/src/routing/src/CMakeLists.txt
index 61e68694341..2c2beb50519 100644
--- a/router/src/routing/src/CMakeLists.txt
+++ b/router/src/routing/src/CMakeLists.txt
@@ -26,15 +26,6 @@ IF (NOT PROTOBUF_LITE_LIBRARY)
   MESSAGE(FATAL_ERROR "Routing plugin requires protobuf-lite library")
 ENDIF()
 
-ADD_LIBRARY(sql_lexer STATIC
-  sql_lexer.cc
-  ${CMAKE_SOURCE_DIR}/sql/sql_lex_hash.cc
-  )
-TARGET_INCLUDE_DIRECTORIES(sql_lexer
-  PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
-# generate sql_yacc.h
-ADD_DEPENDENCIES(sql_lexer GenServerSource)
-
 ADD_LIBRARY(routing SHARED
   mysql_routing.cc
   destination.cc
@@ -86,7 +77,6 @@ ADD_LIBRARY(routing SHARED
 
   sql_value.cc
 )
-
 TARGET_LINK_LIBRARIES(routing
   PUBLIC
   harness_stdx
@@ -98,7 +88,6 @@ TARGET_LINK_LIBRARIES(routing
   metadata_cache
   connection_pool
   destination_status
-  sql_lexer
   )
 IF(SOLARIS)
   TARGET_LINK_LIBRARIES(routing
diff --git a/router/src/routing/src/sql_lexer.cc b/router/src/routing/src/sql_lexer.cc
deleted file mode 100644
index 6c01f213ea2..00000000000
--- a/router/src/routing/src/sql_lexer.cc
+++ /dev/null
@@ -1,1344 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "sql_lexer.h"
-
-#include <cassert>
-#include <cstdint>
-#include <cstdlib>
-#include <cstring>  // memcpy
-#include <mutex>
-
-#include <iostream>
-
-#include "lex_string.h"  // LEX_STRING
-#include "m_ctype.h"     // my_charset_...
-#include "my_compiler.h"
-#include "my_dbug.h"        // DBUG_SET
-#include "my_inttypes.h"    // uchar, uint, ...
-#include "my_sys.h"         // strmake_root
-#include "mysql_version.h"  // MYSQL_VERSION_ID
-#include "sql/lexer_yystype.h"
-#include "sql/sql_digest_stream.h"
-#include "sql/sql_lex_hash.h"
-#include "sql/sql_yacc.h"
-#include "sql/system_variables.h"
-#include "sql_chars.h"  // my_lex_states
-#include "sql_lexer_input_stream.h"
-#include "sql_lexer_thd.h"
-
-// class THD;
-
-sql_digest_state *digest_add_token(sql_digest_state * /* state */,
-                                   uint /* token */,
-                                   Lexer_yystype * /* yylval */) {
-  return nullptr;
-}
-
-sql_digest_state *digest_reduce_token(sql_digest_state * /* state */,
-                                      uint /* token_left */,
-                                      uint /* token_right */) {
-  return nullptr;
-}
-
-/**
-  Perform initialization of Lex_input_stream instance.
-
-  Basically, a buffer for a pre-processed query. This buffer should be large
-  enough to keep a multi-statement query. The allocation is done once in
-  Lex_input_stream::init() in order to prevent memory pollution when
-  the server is processing large multi-statement queries.
-*/
-
-bool Lex_input_stream::init(THD *thd, const char *buff, size_t length) {
-  DBUG_EXECUTE_IF("bug42064_simulate_oom",
-                  DBUG_SET("+d,simulate_out_of_memory"););
-
-  query_charset = thd->charset();
-
-  m_cpp_buf = (char *)thd->alloc(length + 1);
-
-  DBUG_EXECUTE_IF("bug42064_simulate_oom",
-                  DBUG_SET("-d,bug42064_simulate_oom"););
-
-  if (m_cpp_buf == nullptr) return true;
-
-  m_thd = thd;
-  reset(buff, length);
-
-  return false;
-}
-
-/**
-  Prepare Lex_input_stream instance state for use for handling next SQL
-  statement.
-
-  It should be called between two statements in a multi-statement query.
-  The operation resets the input stream to the beginning-of-parse state,
-  but does not reallocate m_cpp_buf.
-*/
-
-void Lex_input_stream::reset(const char *buffer, size_t length) {
-  yylineno = 1;
-  yytoklen = 0;
-  yylval = nullptr;
-  lookahead_token = grammar_selector_token;
-  static Lexer_yystype dummy_yylval;
-  lookahead_yylval = &dummy_yylval;
-  skip_digest = false;
-  /*
-    Lex_input_stream modifies the query string in one special case (sic!).
-    yyUnput() modifises the string when patching version comments.
-    This is done to prevent newer slaves from executing a different
-    statement than older masters.
-
-    For now, cast away const here. This means that e.g. SHOW PROCESSLIST
-    can see partially patched query strings. It would be better if we
-    could replicate the query string as is and have the slave take the
-    master version into account.
-  */
-  m_ptr = const_cast<char *>(buffer);
-  m_tok_start = nullptr;
-  m_tok_end = nullptr;
-  m_end_of_query = buffer + length;
-  m_buf = buffer;
-  m_buf_length = length;
-  m_echo = true;
-  m_cpp_tok_start = nullptr;
-  m_cpp_tok_end = nullptr;
-  m_body_utf8 = nullptr;
-  m_cpp_utf8_processed_ptr = nullptr;
-  next_state = MY_LEX_START;
-  found_semicolon = nullptr;
-  ignore_space = m_thd->variables.sql_mode & MODE_IGNORE_SPACE;
-  stmt_prepare_mode = false;
-  multi_statements = true;
-  in_comment = NO_COMMENT;
-  m_underscore_cs = nullptr;
-  m_cpp_ptr = m_cpp_buf;
-}
-
-/**
-  The operation is called from the parser in order to
-  1) designate the intention to have utf8 body;
-  1) Indicate to the lexer that we will need a utf8 representation of this
-     statement;
-  2) Determine the beginning of the body.
-
-  @param thd        Thread context.
-  @param begin_ptr  Pointer to the start of the body in the pre-processed
-                    buffer.
-*/
-
-void Lex_input_stream::body_utf8_start(THD *thd, const char *begin_ptr) {
-  assert(begin_ptr);
-  assert(m_cpp_buf <= begin_ptr && begin_ptr <= m_cpp_buf + m_buf_length);
-
-  size_t body_utf8_length =
-      (m_buf_length / thd->variables.character_set_client->mbminlen) *
-      my_charset_utf8mb4_bin.mbmaxlen;
-
-  m_body_utf8 = (char *)thd->alloc(body_utf8_length + 1);
-  m_body_utf8_ptr = m_body_utf8;
-  *m_body_utf8_ptr = 0;
-
-  m_cpp_utf8_processed_ptr = begin_ptr;
-}
-
-/**
-  @brief The operation appends unprocessed part of pre-processed buffer till
-  the given pointer (ptr) and sets m_cpp_utf8_processed_ptr to end_ptr.
-
-  The idea is that some tokens in the pre-processed buffer (like character
-  set introducers) should be skipped.
-
-  Example:
-    CPP buffer: SELECT 'str1', _latin1 'str2';
-    m_cpp_utf8_processed_ptr -- points at the "SELECT ...";
-    In order to skip "_latin1", the following call should be made:
-      body_utf8_append(<pointer to "_latin1 ...">, <pointer to " 'str2'...">)
-
-  @param ptr      Pointer in the pre-processed buffer, which specifies the
-                  end of the chunk, which should be appended to the utf8
-                  body.
-  @param end_ptr  Pointer in the pre-processed buffer, to which
-                  m_cpp_utf8_processed_ptr will be set in the end of the
-                  operation.
-*/
-
-void Lex_input_stream::body_utf8_append(const char *ptr, const char *end_ptr) {
-  assert(m_cpp_buf <= ptr && ptr <= m_cpp_buf + m_buf_length);
-  assert(m_cpp_buf <= end_ptr && end_ptr <= m_cpp_buf + m_buf_length);
-
-  if (!m_body_utf8) return;
-
-  if (m_cpp_utf8_processed_ptr >= ptr) return;
-
-  size_t bytes_to_copy = ptr - m_cpp_utf8_processed_ptr;
-
-  memcpy(m_body_utf8_ptr, m_cpp_utf8_processed_ptr, bytes_to_copy);
-  m_body_utf8_ptr += bytes_to_copy;
-  *m_body_utf8_ptr = 0;
-
-  m_cpp_utf8_processed_ptr = end_ptr;
-}
-
-/**
-  The operation appends unprocessed part of the pre-processed buffer till
-  the given pointer (ptr) and sets m_cpp_utf8_processed_ptr to ptr.
-
-  @param ptr  Pointer in the pre-processed buffer, which specifies the end
-              of the chunk, which should be appended to the utf8 body.
-*/
-
-void Lex_input_stream::body_utf8_append(const char *ptr) {
-  body_utf8_append(ptr, ptr);
-}
-
-/**
-  The operation converts the specified text literal to the utf8 and appends
-  the result to the utf8-body.
-
-  @param thd      Thread context.
-  @param txt      Text literal.
-  @param txt_cs   Character set of the text literal.
-  @param end_ptr  Pointer in the pre-processed buffer, to which
-                  m_cpp_utf8_processed_ptr will be set in the end of the
-                  operation.
-*/
-
-void Lex_input_stream::body_utf8_append_literal(THD *thd, const LEX_STRING *txt,
-                                                const CHARSET_INFO *txt_cs,
-                                                const char *end_ptr) {
-  if (!m_cpp_utf8_processed_ptr) return;
-
-  LEX_STRING utf_txt{nullptr, 0};
-
-  if (!my_charset_same(txt_cs, &my_charset_utf8mb4_general_ci)) {
-    thd->convert_string(&utf_txt, &my_charset_utf8mb4_general_ci, txt->str,
-                        txt->length, txt_cs);
-  } else {
-    utf_txt.str = txt->str;
-    utf_txt.length = txt->length;
-  }
-
-  MY_COMPILER_DIAGNOSTIC_PUSH();
-  // GCC 10.2.0 solaris
-  MY_COMPILER_GCC_DIAGNOSTIC_IGNORE("-Wmaybe-uninitialized");
-
-  /* NOTE: utf_txt.length is in bytes, not in symbols. */
-  memcpy(m_body_utf8_ptr, utf_txt.str, utf_txt.length);
-  m_body_utf8_ptr += utf_txt.length;
-  *m_body_utf8_ptr = 0;
-  MY_COMPILER_DIAGNOSTIC_POP();
-
-  m_cpp_utf8_processed_ptr = end_ptr;
-}
-
-void Lex_input_stream::add_digest_token(uint token, Lexer_yystype *yylval) {
-  if (m_digest != nullptr) {
-    m_digest = digest_add_token(m_digest, token, yylval);
-  }
-}
-
-void Lex_input_stream::reduce_digest_token(uint token_left, uint token_right) {
-  if (m_digest != nullptr) {
-    m_digest = digest_reduce_token(m_digest, token_left, token_right);
-  }
-}
-
-static int find_keyword(Lex_input_stream *lip, uint len, bool function) {
-  const char *tok = lip->get_tok_start();
-
-  const SYMBOL *symbol =
-      function ? Lex_hash::sql_keywords_and_funcs.get_hash_symbol(tok, len)
-               : Lex_hash::sql_keywords.get_hash_symbol(tok, len);
-
-  if (symbol) {
-    lip->yylval->keyword.symbol = symbol;
-    lip->yylval->keyword.str = const_cast<char *>(tok);
-    lip->yylval->keyword.length = len;
-
-    if ((symbol->tok == NOT_SYM) &&
-        (lip->m_thd->variables.sql_mode & MODE_HIGH_NOT_PRECEDENCE))
-      return NOT2_SYM;
-    if ((symbol->tok == OR_OR_SYM) &&
-        !(lip->m_thd->variables.sql_mode & MODE_PIPES_AS_CONCAT)) {
-      push_deprecated_warn(lip->m_thd, "|| as a synonym for OR", "OR");
-      return OR2_SYM;
-    }
-
-    lip->yylval->optimizer_hints = nullptr;
-    if (symbol->group & SG_HINTABLE_KEYWORDS) {
-      lip->add_digest_token(symbol->tok, lip->yylval);
-#ifdef USE_OPTIMIZER_HINTS_PARSER
-      if (consume_optimizer_hints(lip)) return ABORT_SYM;
-#endif
-      lip->skip_digest = true;
-    }
-
-    return symbol->tok;
-  }
-  return 0;
-}
-
-static LEX_STRING get_token(Lex_input_stream *lip, uint skip, uint length) {
-  LEX_STRING tmp;
-  lip->yyUnget();  // ptr points now after last token char
-  tmp.length = lip->yytoklen = length;
-  tmp.str = lip->m_thd->strmake(lip->get_tok_start() + skip, tmp.length);
-
-  lip->m_cpp_text_start = lip->get_cpp_tok_start() + skip;
-  lip->m_cpp_text_end = lip->m_cpp_text_start + tmp.length;
-
-  return tmp;
-}
-
-static LEX_STRING get_quoted_token(Lex_input_stream *lip, uint skip,
-                                   uint length, char quote) {
-  LEX_STRING tmp;
-  const char *from, *end;
-  char *to;
-  lip->yyUnget();  // ptr points now after last token char
-  tmp.length = lip->yytoklen = length;
-  tmp.str = (char *)lip->m_thd->alloc(tmp.length + 1);
-  from = lip->get_tok_start() + skip;
-  to = tmp.str;
-  end = to + length;
-
-  lip->m_cpp_text_start = lip->get_cpp_tok_start() + skip;
-  lip->m_cpp_text_end = lip->m_cpp_text_start + length;
-
-  for (; to != end;) {
-    if ((*to++ = *from++) == quote) {
-      from++;  // Skip double quotes
-      lip->m_cpp_text_start++;
-    }
-  }
-  *to = 0;  // End null for safety
-  return tmp;
-}
-
-static char *get_text(Lex_input_stream *lip, int pre_skip, int post_skip) {
-  uchar c, sep;
-  uint found_escape = 0;
-  const CHARSET_INFO *cs = lip->m_thd->charset();
-
-  lip->tok_bitmap = 0;
-  sep = lip->yyGetLast();  // String should end with this
-  while (!lip->eof()) {
-    c = lip->yyGet();
-    lip->tok_bitmap |= c;
-    {
-      int l;
-      if (use_mb(cs) &&
-          (l = my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query()))) {
-        lip->skip_binary(l - 1);
-        continue;
-      }
-    }
-    if (c == '\\' && !(lip->m_thd->variables.sql_mode &
-                       MODE_NO_BACKSLASH_ESCAPES)) {  // Escaped character
-      found_escape = 1;
-      if (lip->eof()) return nullptr;
-      lip->yySkip();
-    } else if (c == sep) {
-      if (c == lip->yyGet())  // Check if two separators in a row
-      {
-        found_escape = 1;  // duplicate. Remember for delete
-        continue;
-      } else
-        lip->yyUnget();
-
-      /* Found end. Unescape and return string */
-      const char *str, *end;
-      char *start;
-
-      str = lip->get_tok_start();
-      end = lip->get_ptr();
-      /* Extract the text from the token */
-      str += pre_skip;
-      end -= post_skip;
-      assert(end >= str);
-
-      if (!(start =
-                static_cast<char *>(lip->m_thd->alloc((uint)(end - str) + 1))))
-        return const_cast<char *>("");  // MEM_ROOT has set error flag
-
-      lip->m_cpp_text_start = lip->get_cpp_tok_start() + pre_skip;
-      lip->m_cpp_text_end = lip->get_cpp_ptr() - post_skip;
-
-      if (!found_escape) {
-        lip->yytoklen = (uint)(end - str);
-        memcpy(start, str, lip->yytoklen);
-        start[lip->yytoklen] = 0;
-      } else {
-        char *to;
-
-        for (to = start; str != end; str++) {
-          int l;
-          if (use_mb(cs) && (l = my_ismbchar(cs, str, end))) {
-            while (l--) *to++ = *str++;
-            str--;
-            continue;
-          }
-          if (!(lip->m_thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES) &&
-              *str == '\\' && str + 1 != end) {
-            switch (*++str) {
-              case 'n':
-                *to++ = '\n';
-                break;
-              case 't':
-                *to++ = '\t';
-                break;
-              case 'r':
-                *to++ = '\r';
-                break;
-              case 'b':
-                *to++ = '\b';
-                break;
-              case '0':
-                *to++ = 0;  // Ascii null
-                break;
-              case 'Z':  // ^Z must be escaped on Win32
-                *to++ = '\032';
-                break;
-              case '_':
-              case '%':
-                *to++ = '\\';  // remember prefix for wildcard
-                [[fallthrough]];
-              default:
-                *to++ = *str;
-                break;
-            }
-          } else if (*str == sep)
-            *to++ = *str++;  // Two ' or "
-          else
-            *to++ = *str;
-        }
-        *to = 0;
-        lip->yytoklen = (uint)(to - start);
-      }
-      return start;
-    }
-  }
-  return nullptr;  // unexpected end of query
-}
-
-/*
-** Calc type of integer; long integer, longlong integer or real.
-** Returns smallest type that match the string.
-** When using unsigned long long values the result is converted to a real
-** because else they will be unexpected sign changes because all calculation
-** is done with longlong or double.
-*/
-
-static const char *long_str = "2147483647";
-static const uint long_len = 10;
-static const char *signed_long_str = "-2147483648";
-static const char *longlong_str = "9223372036854775807";
-static const uint longlong_len = 19;
-static const char *signed_longlong_str = "-9223372036854775808";
-static const uint signed_longlong_len = 19;
-static const char *unsigned_longlong_str = "18446744073709551615";
-static const uint unsigned_longlong_len = 20;
-
-static inline uint int_token(const char *str, uint length) {
-  if (length < long_len)  // quick normal case
-    return NUM;
-  bool neg = false;
-
-  if (*str == '+')  // Remove sign and pre-zeros
-  {
-    str++;
-    length--;
-  } else if (*str == '-') {
-    str++;
-    length--;
-    neg = true;
-  }
-  while (*str == '0' && length) {
-    str++;
-    length--;
-  }
-  if (length < long_len) return NUM;
-
-  uint smaller, bigger;
-  const char *cmp;
-  if (neg) {
-    if (length == long_len) {
-      cmp = signed_long_str + 1;
-      smaller = NUM;      // If <= signed_long_str
-      bigger = LONG_NUM;  // If >= signed_long_str
-    } else if (length < signed_longlong_len)
-      return LONG_NUM;
-    else if (length > signed_longlong_len)
-      return DECIMAL_NUM;
-    else {
-      cmp = signed_longlong_str + 1;
-      smaller = LONG_NUM;  // If <= signed_longlong_str
-      bigger = DECIMAL_NUM;
-    }
-  } else {
-    if (length == long_len) {
-      cmp = long_str;
-      smaller = NUM;
-      bigger = LONG_NUM;
-    } else if (length < longlong_len)
-      return LONG_NUM;
-    else if (length > longlong_len) {
-      if (length > unsigned_longlong_len) return DECIMAL_NUM;
-      cmp = unsigned_longlong_str;
-      smaller = ULONGLONG_NUM;
-      bigger = DECIMAL_NUM;
-    } else {
-      cmp = longlong_str;
-      smaller = LONG_NUM;
-      bigger = ULONGLONG_NUM;
-    }
-  }
-  while (*cmp && *cmp++ == *str++)
-    ;
-  return ((uchar)str[-1] <= (uchar)cmp[-1]) ? smaller : bigger;
-}
-
-/**
-  Given a stream that is advanced to the first contained character in
-  an open comment, consume the comment.  Optionally, if we are allowed,
-  recurse so that we understand comments within this current comment.
-
-  At this level, we do not support version-condition comments.  We might
-  have been called with having just passed one in the stream, though.  In
-  that case, we probably want to tolerate mundane comments inside.  Thus,
-  the case for recursion.
-
-  @retval  Whether EOF reached before comment is closed.
-*/
-static bool consume_comment(Lex_input_stream *lip,
-                            int remaining_recursions_permitted) {
-  // only one level of nested comments are allowed
-  assert(remaining_recursions_permitted == 0 ||
-         remaining_recursions_permitted == 1);
-  uchar c;
-  while (!lip->eof()) {
-    c = lip->yyGet();
-
-    if (remaining_recursions_permitted == 1) {
-      if ((c == '/') && (lip->yyPeek() == '*')) {
-#ifdef WITH_PUSH_WARNING
-        push_warning(
-            lip->m_thd, Sql_condition::SL_WARNING,
-            ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
-            ER_THD(lip->m_thd, ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX));
-#endif
-        lip->yyUnput('(');  // Replace nested "/*..." with "(*..."
-        lip->yySkip();      // and skip "("
-        lip->yySkip();      /* Eat asterisk */
-        if (consume_comment(lip, 0)) return true;
-        lip->yyUnput(')');  // Replace "...*/" with "...*)"
-        lip->yySkip();      // and skip ")"
-        continue;
-      }
-    }
-
-    if (c == '*') {
-      if (lip->yyPeek() == '/') {
-        lip->yySkip(); /* Eat slash */
-        return false;
-      }
-    }
-
-    if (c == '\n') lip->yylineno++;
-  }
-
-  return true;
-}
-
-static int lex_one_token(Lexer_yystype *yylval, THD *thd) {
-  uchar c = 0;
-  bool comment_closed;
-  int tokval, result_state;
-  uint length;
-  enum my_lex_states state;
-  Lex_input_stream *lip = &thd->m_parser_state->m_lip;
-  const CHARSET_INFO *cs = thd->charset();
-  const my_lex_states *state_map = cs->state_maps->main_map;
-  const uchar *ident_map = cs->ident_map;
-
-  assert(lip);
-
-  lip->yylval = yylval;  // The global state
-
-  lip->start_token();
-  state = lip->next_state;
-  lip->next_state = MY_LEX_START;
-  for (;;) {
-    switch (state) {
-      case MY_LEX_START:  // Start of token
-        // Skip starting whitespace
-        while (state_map[c = lip->yyPeek()] == MY_LEX_SKIP) {
-          if (c == '\n') lip->yylineno++;
-
-          lip->yySkip();
-        }
-
-        /* Start of real token */
-        lip->restart_token();
-        c = lip->yyGet();
-        state = state_map[c];
-        break;
-      case MY_LEX_CHAR:  // Unknown or single char token
-      case MY_LEX_SKIP:  // This should not happen
-        if (c == '-' && lip->yyPeek() == '-' &&
-            (my_isspace(cs, lip->yyPeekn(1)) ||
-             my_iscntrl(cs, lip->yyPeekn(1)))) {
-          state = MY_LEX_COMMENT;
-          break;
-        }
-
-        if (c == '-' && lip->yyPeek() == '>')  // '->'
-        {
-          lip->yySkip();
-          lip->next_state = MY_LEX_START;
-          if (lip->yyPeek() == '>') {
-            lip->yySkip();
-            return JSON_UNQUOTED_SEPARATOR_SYM;
-          }
-          return JSON_SEPARATOR_SYM;
-        }
-
-        if (c != ')') lip->next_state = MY_LEX_START;  // Allow signed numbers
-
-        /*
-          Check for a placeholder: it should not precede a possible identifier
-          because of binlogging: when a placeholder is replaced with its value
-          in a query for the binlog, the query must stay grammatically correct.
-        */
-        if (c == '?' && lip->stmt_prepare_mode && !ident_map[lip->yyPeek()])
-          return (PARAM_MARKER);
-
-        return ((int)c);
-
-      case MY_LEX_IDENT_OR_NCHAR:
-        if (lip->yyPeek() != '\'') {
-          state = MY_LEX_IDENT;
-          break;
-        }
-        /* Found N'string' */
-        lip->yySkip();  // Skip '
-        if (!(yylval->lex_str.str = get_text(lip, 2, 1))) {
-          state = MY_LEX_CHAR;  // Read char by char
-          break;
-        }
-        yylval->lex_str.length = lip->yytoklen;
-        return (NCHAR_STRING);
-
-      case MY_LEX_IDENT_OR_HEX:
-        if (lip->yyPeek() == '\'') {  // Found x'hex-number'
-          state = MY_LEX_HEX_NUMBER;
-          break;
-        }
-        [[fallthrough]];
-      case MY_LEX_IDENT_OR_BIN:
-        if (lip->yyPeek() == '\'') {  // Found b'bin-number'
-          state = MY_LEX_BIN_NUMBER;
-          break;
-        }
-        [[fallthrough]];
-      case MY_LEX_IDENT:
-        const char *start;
-        if (use_mb(cs)) {
-          result_state = IDENT_QUOTED;
-          switch (my_mbcharlen(cs, lip->yyGetLast())) {
-            case 1:
-              break;
-            case 0:
-              if (my_mbmaxlenlen(cs) < 2) break;
-              [[fallthrough]];
-            default:
-              int l =
-                  my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query());
-              if (l == 0) {
-                state = MY_LEX_CHAR;
-                continue;
-              }
-              lip->skip_binary(l - 1);
-          }
-          while (ident_map[c = lip->yyGet()]) {
-            switch (my_mbcharlen(cs, c)) {
-              case 1:
-                break;
-              case 0:
-                if (my_mbmaxlenlen(cs) < 2) break;
-                [[fallthrough]];
-              default:
-                int l;
-                if ((l = my_ismbchar(cs, lip->get_ptr() - 1,
-                                     lip->get_end_of_query())) == 0)
-                  break;
-                lip->skip_binary(l - 1);
-            }
-          }
-        } else {
-          for (result_state = c; ident_map[c = lip->yyGet()]; result_state |= c)
-            ;
-          /* If there were non-ASCII characters, mark that we must convert */
-          result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;
-        }
-        length = lip->yyLength();
-        start = lip->get_ptr();
-        if (lip->ignore_space) {
-          /*
-            If we find a space then this can't be an identifier. We notice this
-            below by checking start != lex->ptr.
-          */
-          for (; state_map[c] == MY_LEX_SKIP; c = lip->yyGet()) {
-            if (c == '\n') lip->yylineno++;
-          }
-        }
-        if (start == lip->get_ptr() && c == '.' && ident_map[lip->yyPeek()])
-          lip->next_state = MY_LEX_IDENT_SEP;
-        else {  // '(' must follow directly if function
-          lip->yyUnget();
-          if ((tokval = find_keyword(lip, length, c == '('))) {
-            lip->next_state = MY_LEX_START;  // Allow signed numbers
-            return (tokval);                 // Was keyword
-          }
-          lip->yySkip();  // next state does a unget
-        }
-        yylval->lex_str = get_token(lip, 0, length);
-
-        /*
-           Note: "SELECT _bla AS 'alias'"
-           _bla should be considered as a IDENT if charset haven't been found.
-           So we don't use MYF(MY_WME) with get_charset_by_csname to avoid
-           producing an error.
-        */
-
-        if (yylval->lex_str.str[0] == '_') {
-          auto charset_name = yylval->lex_str.str + 1;
-          const CHARSET_INFO *underscore_cs =
-              get_charset_by_csname(charset_name, MY_CS_PRIMARY, MYF(0));
-          if (underscore_cs) {
-            lip->warn_on_deprecated_charset(underscore_cs, charset_name);
-            if (underscore_cs == &my_charset_utf8mb4_0900_ai_ci) {
-              /*
-                If underscore_cs is utf8mb4, and the collation of underscore_cs
-                is the default collation of utf8mb4, then update underscore_cs
-                with a value of the default_collation_for_utf8mb4 system
-                variable:
-              */
-              underscore_cs = thd->variables.default_collation_for_utf8mb4;
-            }
-            yylval->charset = underscore_cs;
-            lip->m_underscore_cs = underscore_cs;
-
-            lip->body_utf8_append(lip->m_cpp_text_start,
-                                  lip->get_cpp_tok_start() + length);
-            return (UNDERSCORE_CHARSET);
-          }
-        }
-
-        lip->body_utf8_append(lip->m_cpp_text_start);
-
-        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
-                                      lip->m_cpp_text_end);
-
-        return (result_state);  // IDENT or IDENT_QUOTED
-
-      case MY_LEX_IDENT_SEP:  // Found ident and now '.'
-        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
-        yylval->lex_str.length = 1;
-        c = lip->yyGet();  // should be '.'
-        lip->next_state =
-            MY_LEX_IDENT_START;         // Next is an ident (not a keyword)
-        if (!ident_map[lip->yyPeek()])  // Probably ` or "
-          lip->next_state = MY_LEX_START;
-        return ((int)c);
-
-      case MY_LEX_NUMBER_IDENT:  // number or ident which num-start
-        if (lip->yyGetLast() == '0') {
-          c = lip->yyGet();
-          if (c == 'x') {
-            while (my_isxdigit(cs, (c = lip->yyGet())))
-              ;
-            if ((lip->yyLength() >= 3) && !ident_map[c]) {
-              /* skip '0x' */
-              yylval->lex_str = get_token(lip, 2, lip->yyLength() - 2);
-              return (HEX_NUM);
-            }
-            lip->yyUnget();
-            state = MY_LEX_IDENT_START;
-            break;
-          } else if (c == 'b') {
-            while ((c = lip->yyGet()) == '0' || c == '1')
-              ;
-            if ((lip->yyLength() >= 3) && !ident_map[c]) {
-              /* Skip '0b' */
-              yylval->lex_str = get_token(lip, 2, lip->yyLength() - 2);
-              return (BIN_NUM);
-            }
-            lip->yyUnget();
-            state = MY_LEX_IDENT_START;
-            break;
-          }
-          lip->yyUnget();
-        }
-
-        while (my_isdigit(cs, (c = lip->yyGet())))
-          ;
-        if (!ident_map[c]) {  // Can't be identifier
-          state = MY_LEX_INT_OR_REAL;
-          break;
-        }
-        if (c == 'e' || c == 'E') {
-          // The following test is written this way to allow numbers of type 1e1
-          if (my_isdigit(cs, lip->yyPeek()) || (c = (lip->yyGet())) == '+' ||
-              c == '-') {  // Allow 1E+10
-            if (my_isdigit(cs,
-                           lip->yyPeek()))  // Number must have digit after sign
-            {
-              lip->yySkip();
-              while (my_isdigit(cs, lip->yyGet()))
-                ;
-              yylval->lex_str = get_token(lip, 0, lip->yyLength());
-              return (FLOAT_NUM);
-            }
-          }
-          lip->yyUnget();
-        }
-        [[fallthrough]];
-      case MY_LEX_IDENT_START:  // We come here after '.'
-        result_state = IDENT;
-        if (use_mb(cs)) {
-          result_state = IDENT_QUOTED;
-          while (ident_map[c = lip->yyGet()]) {
-            switch (my_mbcharlen(cs, c)) {
-              case 1:
-                break;
-              case 0:
-                if (my_mbmaxlenlen(cs) < 2) break;
-                [[fallthrough]];
-              default:
-                int l;
-                if ((l = my_ismbchar(cs, lip->get_ptr() - 1,
-                                     lip->get_end_of_query())) == 0)
-                  break;
-                lip->skip_binary(l - 1);
-            }
-          }
-        } else {
-          for (result_state = 0; ident_map[c = lip->yyGet()]; result_state |= c)
-            ;
-          /* If there were non-ASCII characters, mark that we must convert */
-          result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;
-        }
-        if (c == '.' && ident_map[lip->yyPeek()])
-          lip->next_state = MY_LEX_IDENT_SEP;  // Next is '.'
-
-        yylval->lex_str = get_token(lip, 0, lip->yyLength());
-
-        lip->body_utf8_append(lip->m_cpp_text_start);
-
-        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
-                                      lip->m_cpp_text_end);
-
-        return (result_state);
-
-      case MY_LEX_USER_VARIABLE_DELIMITER:  // Found quote char
-      {
-        uint double_quotes = 0;
-        char quote_char = c;  // Used char
-        for (;;) {
-          c = lip->yyGet();
-          if (c == 0) {
-            lip->yyUnget();
-            return ABORT_SYM;  // Unmatched quotes
-          }
-
-          int var_length;
-          if ((var_length = my_mbcharlen(cs, c)) == 1) {
-            if (c == quote_char) {
-              if (lip->yyPeek() != quote_char) break;
-              c = lip->yyGet();
-              double_quotes++;
-              continue;
-            }
-          } else if (use_mb(cs)) {
-            if ((var_length = my_ismbchar(cs, lip->get_ptr() - 1,
-                                          lip->get_end_of_query())))
-              lip->skip_binary(var_length - 1);
-          }
-        }
-        if (double_quotes)
-          yylval->lex_str = get_quoted_token(
-              lip, 1, lip->yyLength() - double_quotes - 1, quote_char);
-        else
-          yylval->lex_str = get_token(lip, 1, lip->yyLength() - 1);
-        if (c == quote_char) lip->yySkip();  // Skip end `
-        lip->next_state = MY_LEX_START;
-
-        lip->body_utf8_append(lip->m_cpp_text_start);
-
-        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
-                                      lip->m_cpp_text_end);
-
-        return (IDENT_QUOTED);
-      }
-      case MY_LEX_INT_OR_REAL:  // Complete int or incomplete real
-        if (c != '.') {         // Found complete integer number.
-          yylval->lex_str = get_token(lip, 0, lip->yyLength());
-          return int_token(yylval->lex_str.str, (uint)yylval->lex_str.length);
-        }
-        [[fallthrough]];
-      case MY_LEX_REAL:  // Incomplete real number
-        while (my_isdigit(cs, c = lip->yyGet()))
-          ;
-
-        if (c == 'e' || c == 'E') {
-          c = lip->yyGet();
-          if (c == '-' || c == '+') c = lip->yyGet();  // Skip sign
-          if (!my_isdigit(cs, c)) {                    // No digit after sign
-            state = MY_LEX_CHAR;
-            break;
-          }
-          while (my_isdigit(cs, lip->yyGet()))
-            ;
-          yylval->lex_str = get_token(lip, 0, lip->yyLength());
-          return (FLOAT_NUM);
-        }
-        yylval->lex_str = get_token(lip, 0, lip->yyLength());
-        return (DECIMAL_NUM);
-
-      case MY_LEX_HEX_NUMBER:  // Found x'hexstring'
-        lip->yySkip();         // Accept opening '
-        while (my_isxdigit(cs, (c = lip->yyGet())))
-          ;
-        if (c != '\'') return (ABORT_SYM);          // Illegal hex constant
-        lip->yySkip();                              // Accept closing '
-        length = lip->yyLength();                   // Length of hexnum+3
-        if ((length % 2) == 0) return (ABORT_SYM);  // odd number of hex digits
-        yylval->lex_str = get_token(lip,
-                                    2,            // skip x'
-                                    length - 3);  // don't count x' and last '
-        return (HEX_NUM);
-
-      case MY_LEX_BIN_NUMBER:  // Found b'bin-string'
-        lip->yySkip();         // Accept opening '
-        while ((c = lip->yyGet()) == '0' || c == '1')
-          ;
-        if (c != '\'') return (ABORT_SYM);  // Illegal hex constant
-        lip->yySkip();                      // Accept closing '
-        length = lip->yyLength();           // Length of bin-num + 3
-        yylval->lex_str = get_token(lip,
-                                    2,            // skip b'
-                                    length - 3);  // don't count b' and last '
-        return (BIN_NUM);
-
-      case MY_LEX_CMP_OP:  // Incomplete comparison operator
-        if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP ||
-            state_map[lip->yyPeek()] == MY_LEX_LONG_CMP_OP)
-          lip->yySkip();
-        if ((tokval = find_keyword(lip, lip->yyLength() + 1, false))) {
-          lip->next_state = MY_LEX_START;  // Allow signed numbers
-          return (tokval);
-        }
-        state = MY_LEX_CHAR;  // Something fishy found
-        break;
-
-      case MY_LEX_LONG_CMP_OP:  // Incomplete comparison operator
-        if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP ||
-            state_map[lip->yyPeek()] == MY_LEX_LONG_CMP_OP) {
-          lip->yySkip();
-          if (state_map[lip->yyPeek()] == MY_LEX_CMP_OP) lip->yySkip();
-        }
-        if ((tokval = find_keyword(lip, lip->yyLength() + 1, false))) {
-          lip->next_state = MY_LEX_START;  // Found long op
-          return (tokval);
-        }
-        state = MY_LEX_CHAR;  // Something fishy found
-        break;
-
-      case MY_LEX_BOOL:
-        if (c != lip->yyPeek()) {
-          state = MY_LEX_CHAR;
-          break;
-        }
-        lip->yySkip();
-        tokval = find_keyword(lip, 2, false);  // Is a bool operator
-        lip->next_state = MY_LEX_START;        // Allow signed numbers
-        return (tokval);
-
-      case MY_LEX_STRING_OR_DELIMITER:
-        if (thd->variables.sql_mode & MODE_ANSI_QUOTES) {
-          state = MY_LEX_USER_VARIABLE_DELIMITER;
-          break;
-        }
-        /* " used for strings */
-        [[fallthrough]];
-      case MY_LEX_STRING:  // Incomplete text string
-        if (!(yylval->lex_str.str = get_text(lip, 1, 1))) {
-          state = MY_LEX_CHAR;  // Read char by char
-          break;
-        }
-        yylval->lex_str.length = lip->yytoklen;
-
-        lip->body_utf8_append(lip->m_cpp_text_start);
-
-        lip->body_utf8_append_literal(
-            thd, &yylval->lex_str,
-            lip->m_underscore_cs ? lip->m_underscore_cs : cs,
-            lip->m_cpp_text_end);
-
-        lip->m_underscore_cs = nullptr;
-
-        return (TEXT_STRING);
-
-      case MY_LEX_COMMENT:  //  Comment
-        thd->m_parser_state->add_comment();
-        while ((c = lip->yyGet()) != '\n' && c)
-          ;
-        lip->yyUnget();        // Safety against eof
-        state = MY_LEX_START;  // Try again
-        break;
-      case MY_LEX_LONG_COMMENT: /* Long C comment? */
-        if (lip->yyPeek() != '*') {
-          state = MY_LEX_CHAR;  // Probable division
-          break;
-        }
-        thd->m_parser_state->add_comment();
-        /* Reject '/' '*', since we might need to turn off the echo */
-        lip->yyUnget();
-
-        lip->save_in_comment_state();
-
-        if (lip->yyPeekn(2) == '!') {
-          lip->in_comment = DISCARD_COMMENT;
-          /* Accept '/' '*' '!', but do not keep this marker. */
-          lip->set_echo(false);
-          lip->yySkip();
-          lip->yySkip();
-          lip->yySkip();
-
-          /*
-            The special comment format is very strict:
-            '/' '*' '!', followed by exactly
-            1 digit (major), 2 digits (minor), then 2 digits (dot).
-            32302 -> 3.23.02
-            50032 -> 5.0.32
-            50114 -> 5.1.14
-          */
-          char version_str[6];
-          if (my_isdigit(cs, (version_str[0] = lip->yyPeekn(0))) &&
-              my_isdigit(cs, (version_str[1] = lip->yyPeekn(1))) &&
-              my_isdigit(cs, (version_str[2] = lip->yyPeekn(2))) &&
-              my_isdigit(cs, (version_str[3] = lip->yyPeekn(3))) &&
-              my_isdigit(cs, (version_str[4] = lip->yyPeekn(4)))) {
-            version_str[5] = 0;
-            ulong version;
-            version = strtol(version_str, nullptr, 10);
-
-            if (version <= MYSQL_VERSION_ID) {
-              /* Accept 'M' 'm' 'm' 'd' 'd' */
-              lip->yySkipn(5);
-              /* Expand the content of the special comment as real code */
-              lip->set_echo(true);
-              state = MY_LEX_START;
-              break; /* Do not treat contents as a comment.  */
-            } else {
-              /*
-                Patch and skip the conditional comment to avoid it
-                being propagated infinitely (eg. to a slave).
-              */
-              char *pcom = lip->yyUnput(' ');
-              comment_closed = !consume_comment(lip, 1);
-              if (!comment_closed) {
-                *pcom = '!';
-              }
-              /* version allowed to have one level of comment inside. */
-            }
-          } else {
-            /* Not a version comment. */
-            state = MY_LEX_START;
-            lip->set_echo(true);
-            break;
-          }
-        } else {
-          if (lip->in_comment != NO_COMMENT) {
-#ifdef WITH_PUSH_WARNING
-            push_warning(
-                lip->m_thd, Sql_condition::SL_WARNING,
-                ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,
-                ER_THD(lip->m_thd, ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX));
-#endif
-          }
-          lip->in_comment = PRESERVE_COMMENT;
-          lip->yySkip();  // Accept /
-          lip->yySkip();  // Accept *
-          comment_closed = !consume_comment(lip, 0);
-          /* regular comments can have zero comments inside. */
-        }
-        /*
-          Discard:
-          - regular '/' '*' comments,
-          - special comments '/' '*' '!' for a future version,
-          by scanning until we find a closing '*' '/' marker.
-
-          Nesting regular comments isn't allowed.  The first
-          '*' '/' returns the parser to the previous state.
-
-          /#!VERSI oned containing /# regular #/ is allowed #/
-
-                  Inside one versioned comment, another versioned comment
-                  is treated as a regular discardable comment.  It gets
-                  no special parsing.
-        */
-
-        /* Unbalanced comments with a missing '*' '/' are a syntax error */
-        if (!comment_closed) return (ABORT_SYM);
-        state = MY_LEX_START;  // Try again
-        lip->restore_in_comment_state();
-        break;
-      case MY_LEX_END_LONG_COMMENT:
-        if ((lip->in_comment != NO_COMMENT) && lip->yyPeek() == '/') {
-          /* Reject '*' '/' */
-          lip->yyUnget();
-          /* Accept '*' '/', with the proper echo */
-          lip->set_echo(lip->in_comment == PRESERVE_COMMENT);
-          lip->yySkipn(2);
-          /* And start recording the tokens again */
-          lip->set_echo(true);
-
-          /*
-            C-style comments are replaced with a single space (as it
-            is in C and C++).  If there is already a whitespace
-            character at this point in the stream, the space is
-            not inserted.
-
-            See also ISO/IEC 9899:1999 §5.1.1.2
-            ("Programming languages — C")
-          */
-          if (!my_isspace(cs, lip->yyPeek()) &&
-              lip->get_cpp_ptr() != lip->get_cpp_buf() &&
-              !my_isspace(cs, *(lip->get_cpp_ptr() - 1)))
-            lip->cpp_inject(' ');
-
-          lip->in_comment = NO_COMMENT;
-          state = MY_LEX_START;
-        } else
-          state = MY_LEX_CHAR;  // Return '*'
-        break;
-      case MY_LEX_SET_VAR:  // Check if ':='
-        if (lip->yyPeek() != '=') {
-          state = MY_LEX_CHAR;  // Return ':'
-          break;
-        }
-        lip->yySkip();
-        return (SET_VAR);
-      case MY_LEX_SEMICOLON:  // optional line terminator
-        state = MY_LEX_CHAR;  // Return ';'
-        break;
-      case MY_LEX_EOL:
-        if (lip->eof()) {
-          lip->yyUnget();  // Reject the last '\0'
-          lip->set_echo(false);
-          lip->yySkip();
-          lip->set_echo(true);
-          /* Unbalanced comments with a missing '*' '/' are a syntax error */
-          if (lip->in_comment != NO_COMMENT) return (ABORT_SYM);
-          lip->next_state = MY_LEX_END;  // Mark for next loop
-          return (END_OF_INPUT);
-        }
-        state = MY_LEX_CHAR;
-        break;
-      case MY_LEX_END:
-        lip->next_state = MY_LEX_END;
-        return (0);  // We found end of input last time
-
-        /* Actually real shouldn't start with . but allow them anyhow */
-      case MY_LEX_REAL_OR_POINT:
-        if (my_isdigit(cs, lip->yyPeek()))
-          state = MY_LEX_REAL;  // Real
-        else {
-          state = MY_LEX_IDENT_SEP;  // return '.'
-          lip->yyUnget();            // Put back '.'
-        }
-        break;
-      case MY_LEX_USER_END:  // end '@' of user@hostname
-        switch (state_map[lip->yyPeek()]) {
-          case MY_LEX_STRING:
-          case MY_LEX_USER_VARIABLE_DELIMITER:
-          case MY_LEX_STRING_OR_DELIMITER:
-            break;
-          case MY_LEX_USER_END:
-            lip->next_state = MY_LEX_SYSTEM_VAR;
-            break;
-          default:
-            lip->next_state = MY_LEX_HOSTNAME;
-            break;
-        }
-        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
-        yylval->lex_str.length = 1;
-        return ((int)'@');
-      case MY_LEX_HOSTNAME:  // end '@' of user@hostname
-        for (c = lip->yyGet();
-             my_isalnum(cs, c) || c == '.' || c == '_' || c == '$';
-             c = lip->yyGet())
-          ;
-        yylval->lex_str = get_token(lip, 0, lip->yyLength());
-        return (LEX_HOSTNAME);
-      case MY_LEX_SYSTEM_VAR:
-        yylval->lex_str.str = const_cast<char *>(lip->get_ptr());
-        yylval->lex_str.length = 1;
-        lip->yySkip();  // Skip '@'
-        lip->next_state =
-            (state_map[lip->yyPeek()] == MY_LEX_USER_VARIABLE_DELIMITER
-                 ? MY_LEX_START
-                 : MY_LEX_IDENT_OR_KEYWORD);
-        return ((int)'@');
-      case MY_LEX_IDENT_OR_KEYWORD:
-        /*
-          We come here when we have found two '@' in a row.
-          We should now be able to handle:
-          [(global | local | session) .]variable_name
-        */
-
-        for (result_state = 0; ident_map[c = lip->yyGet()]; result_state |= c)
-          ;
-        /* If there were non-ASCII characters, mark that we must convert */
-        result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;
-
-        if (c == '.') lip->next_state = MY_LEX_IDENT_SEP;
-        length = lip->yyLength();
-        if (length == 0) return (ABORT_SYM);  // Names must be nonempty.
-        if ((tokval = find_keyword(lip, length, false))) {
-          lip->yyUnget();   // Put back 'c'
-          return (tokval);  // Was keyword
-        }
-        yylval->lex_str = get_token(lip, 0, length);
-
-        lip->body_utf8_append(lip->m_cpp_text_start);
-
-        lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,
-                                      lip->m_cpp_text_end);
-
-        return (result_state);
-    }
-  }
-}
-
-bool lex_init(void) {
-  DBUG_TRACE;
-
-  for (CHARSET_INFO **cs = all_charsets;
-       cs < all_charsets + array_elements(all_charsets) - 1; cs++) {
-    if (*cs && (*cs)->ctype && is_supported_parser_charset(*cs)) {
-      if (init_state_maps(*cs)) return true;  // OOM
-    }
-  }
-
-  return false;
-}
-
-std::once_flag lexer_init;
-
-SqlLexer::SqlLexer(THD *session) : session_{session} {
-  std::call_once(lexer_init, []() {
-    my_init();
-
-    get_collation_number("latin1");  // init the charset subsystem
-
-    lex_init();  // init the state-maps for the parser
-  });
-}
-
-SqlLexer::iterator::iterator(THD *session) : session_(session) {
-  if (session_) {
-    // init the first token
-    token_ = next_token();
-  }
-}
-
-SqlLexer::iterator::Token SqlLexer::iterator::next_token() {
-  const auto token_id = lex_one_token(&st, session_);
-
-  return {get_token_text(token_id), token_id};
-}
-
-SqlLexer::iterator SqlLexer::iterator::operator++(int) {
-  // the last token as END_OF_INPUT, +1 is past the "end()"
-  if (token_.id == END_OF_INPUT) {
-    return {nullptr};
-  }
-
-  return {session_, next_token()};
-}
-
-SqlLexer::iterator &SqlLexer::iterator::operator++() {
-  // the last token as END_OF_INPUT, +1 is past the "end()"
-  if (token_.id == END_OF_INPUT) {
-    token_ = {};
-  } else {
-    token_ = next_token();
-  }
-
-  return *this;
-}
-
-static bool is_keyword_or_func(const char *name, size_t len) {
-  return Lex_hash::sql_keywords_and_funcs.get_hash_symbol(name, len) != nullptr;
-}
-
-std::string_view SqlLexer::iterator::get_token_text(TokenId token_id) const {
-  auto &lip = session_->m_parser_state->m_lip;
-
-  auto raw_token = std::string_view{
-      lip.get_tok_start(),
-      static_cast<size_t>(lip.get_ptr() - lip.get_tok_start())};
-
-  if (token_id == END_OF_INPUT) {
-    return {"\0", 1};
-  } else if (token_id == 0) {  // YYEOF
-    return {};
-  } else if (token_id < 256) {  // 0-255 are plain ASCII characters
-    return raw_token;
-  } else if (token_id == IDENT) {
-    // in 'SET @@SESSION.timestamp' 'timestamp' is a IDENT
-    // in 'SET SESSION timestamp' 'timestamp' is a keyword
-
-    return to_string_view(st.lex_str);
-  } else if (is_keyword_or_func(raw_token.data(), raw_token.size())) {
-    return {st.keyword.str, st.keyword.length};
-  } else {
-    return to_string_view(st.lex_str);
-  }
-}
-
-bool operator==(const SqlLexer::iterator &a, const SqlLexer::iterator &b) {
-  return a.token_.text == b.token_.text;
-}
-
-bool operator!=(const SqlLexer::iterator &a, const SqlLexer::iterator &b) {
-  return !(a == b);
-}
diff --git a/router/src/routing/src/sql_lexer.h b/router/src/routing/src/sql_lexer.h
deleted file mode 100644
index 557ca049104..00000000000
--- a/router/src/routing/src/sql_lexer.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_SQL_LEXER_INCLUDED
-#define ROUTING_SQL_LEXER_INCLUDED
-
-#include <string_view>
-
-#include "sql/lexer_yystype.h"
-
-class THD;
-
-class SqlLexer {
- public:
-  using TokenId = int;
-
-  SqlLexer(THD *session);
-
-  class iterator {
-   public:
-    struct Token {
-      std::string_view text;
-      TokenId id;
-    };
-
-    using lexer_state = Lexer_yystype;
-    using value_type = Token;
-    using pointer = value_type *;
-    using const_pointer = const value_type *;
-
-    iterator(THD *session);
-
-    iterator(THD *session, Token token)
-        : session_(session), token_{std::move(token)} {}
-
-    value_type operator*() const { return token_; }
-    pointer operator->() { return &token_; }
-    const_pointer operator->() const { return &token_; }
-
-    iterator operator++(int);
-    iterator &operator++();
-
-    friend bool operator==(const iterator &a, const iterator &b);
-    friend bool operator!=(const iterator &a, const iterator &b);
-
-   private:
-    Token next_token();
-    std::string_view get_token_text(TokenId token_id) const;
-
-    THD *session_;
-    lexer_state st;
-
-    Token token_;
-  };
-
-  iterator begin() { return iterator(session_); }
-  iterator end() { return iterator(nullptr); }
-
- private:
-  THD *session_;
-};
-
-#endif
diff --git a/router/src/routing/src/sql_lexer_error.h b/router/src/routing/src/sql_lexer_error.h
deleted file mode 100644
index fe2935d4dbc..00000000000
--- a/router/src/routing/src/sql_lexer_error.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_SQL_LEXER_ERROR_INCLUDED
-#define ROUTING_SQL_LEXER_ERROR_INCLUDED
-
-#include "m_ctype.h"  // my_charset_...
-
-class THD;
-
-inline void warn_on_deprecated_charset(THD * /* thd */,
-                                       const CHARSET_INFO * /* cs */,
-                                       const char * /* alias */,
-                                       const char * /* option */ = nullptr) {}
-
-inline void warn_on_deprecated_collation(THD * /* thd */,
-                                         const CHARSET_INFO * /* collation */,
-                                         const char * /* option */ = nullptr) {}
-
-inline void push_deprecated_warn(THD * /* thd */, const char * /* old_syntax */,
-                                 const char * /* new_syntax */) {}
-
-#endif
diff --git a/router/src/routing/src/sql_lexer_input_stream.h b/router/src/routing/src/sql_lexer_input_stream.h
deleted file mode 100644
index 138b0a8a6b0..00000000000
--- a/router/src/routing/src/sql_lexer_input_stream.h
+++ /dev/null
@@ -1,512 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_SQL_LEXER_INPUT_STREAM_INCLUDED
-#define ROUTING_SQL_LEXER_INPUT_STREAM_INCLUDED
-
-#include <cassert>
-#include <cstddef>
-#include <cstring>  // memcpy
-
-#include "lex_string.h"   // LEX_STRING
-#include "m_ctype.h"      // my_charset_...
-#include "my_inttypes.h"  // uchar, uint, ...
-#include "sql/lexer_yystype.h"
-#include "sql/sql_digest_stream.h"
-#include "sql_chars.h"  // my_lex_states
-
-#include "sql_lexer_error.h"  // warn_on_...
-
-class THD;
-
-/**
-  The state of the lexical parser, when parsing comments.
- */
-enum enum_comment_state {
-  /**
-    Not parsing comments.
-  */
-  NO_COMMENT,
-
-  /**
-    Parsing comments that need to be preserved.
-    (Copy '/' '*' and '*' '/' sequences to the preprocessed buffer.)
-    Typically, these are user comments '/' '*' ... '*' '/'.
-  */
-  PRESERVE_COMMENT,
-
-  /**
-    Parsing comments that need to be discarded.
-    (Don't copy '/' '*' '!' and '*' '/' sequences to the preprocessed buffer.)
-    Typically, these are special comments '/' '*' '!' ... '*' '/',
-    or '/' '*' '!' 'M' 'M' 'm' 'm' 'm' ... '*' '/', where the comment
-    markers should not be expanded.
-  */
-  DISCARD_COMMENT
-};
-
-class Lex_input_stream {
- public:
-  /**
-    Constructor
-
-    @param grammar_selector_token_arg   See grammar_selector_token.
-  */
-
-  explicit Lex_input_stream(uint grammar_selector_token_arg)
-      : grammar_selector_token(grammar_selector_token_arg) {}
-
-  /**
-     Object initializer. Must be called before usage.
-
-     @retval false OK
-     @retval true  Error
-  */
-  bool init(THD *thd, const char *buff, size_t length);
-
-  void reset(const char *buff, size_t length);
-
-  /**
-    Set the echo mode.
-
-    When echo is true, characters parsed from the raw input stream are
-    preserved. When false, characters parsed are silently ignored.
-    @param echo the echo mode.
-  */
-  void set_echo(bool echo) { m_echo = echo; }
-
-  void save_in_comment_state() {
-    m_echo_saved = m_echo;
-    in_comment_saved = in_comment;
-  }
-
-  void restore_in_comment_state() {
-    m_echo = m_echo_saved;
-    in_comment = in_comment_saved;
-  }
-
-  /**
-    Skip binary from the input stream.
-    @param n number of bytes to accept.
-  */
-  void skip_binary(int n) {
-    assert(m_ptr + n <= m_end_of_query);
-    if (m_echo) {
-      memcpy(m_cpp_ptr, m_ptr, n);
-      m_cpp_ptr += n;
-    }
-    m_ptr += n;
-  }
-
-  /**
-    Get a character, and advance in the stream.
-    @return the next character to parse.
-  */
-  unsigned char yyGet() {
-    assert(m_ptr <= m_end_of_query);
-    char c = *m_ptr++;
-    if (m_echo) *m_cpp_ptr++ = c;
-    return c;
-  }
-
-  /**
-    Get the last character accepted.
-    @return the last character accepted.
-  */
-  unsigned char yyGetLast() const { return m_ptr[-1]; }
-
-  /**
-    Look at the next character to parse, but do not accept it.
-  */
-  unsigned char yyPeek() const {
-    assert(m_ptr <= m_end_of_query);
-    return m_ptr[0];
-  }
-
-  /**
-    Look ahead at some character to parse.
-    @param n offset of the character to look up
-  */
-  unsigned char yyPeekn(int n) const {
-    assert(m_ptr + n <= m_end_of_query);
-    return m_ptr[n];
-  }
-
-  /**
-    Cancel the effect of the last yyGet() or yySkip().
-    Note that the echo mode should not change between calls to yyGet / yySkip
-    and yyUnget. The caller is responsible for ensuring that.
-  */
-  void yyUnget() {
-    m_ptr--;
-    if (m_echo) m_cpp_ptr--;
-  }
-
-  /**
-    Accept a character, by advancing the input stream.
-  */
-  void yySkip() {
-    assert(m_ptr <= m_end_of_query);
-    if (m_echo)
-      *m_cpp_ptr++ = *m_ptr++;
-    else
-      m_ptr++;
-  }
-
-  /**
-    Accept multiple characters at once.
-    @param n the number of characters to accept.
-  */
-  void yySkipn(int n) {
-    assert(m_ptr + n <= m_end_of_query);
-    if (m_echo) {
-      memcpy(m_cpp_ptr, m_ptr, n);
-      m_cpp_ptr += n;
-    }
-    m_ptr += n;
-  }
-
-  /**
-    Puts a character back into the stream, canceling
-    the effect of the last yyGet() or yySkip().
-    Note that the echo mode should not change between calls
-    to unput, get, or skip from the stream.
-  */
-  char *yyUnput(char ch) {
-    *--m_ptr = ch;
-    if (m_echo) m_cpp_ptr--;
-    return m_ptr;
-  }
-
-  /**
-    Inject a character into the pre-processed stream.
-
-    Note, this function is used to inject a space instead of multi-character
-    C-comment. Thus there is no boundary checks here (basically, we replace
-    N-chars by 1-char here).
-  */
-  char *cpp_inject(char ch) {
-    *m_cpp_ptr = ch;
-    return ++m_cpp_ptr;
-  }
-
-  /**
-    End of file indicator for the query text to parse.
-    @return true if there are no more characters to parse
-  */
-  bool eof() const { return (m_ptr >= m_end_of_query); }
-
-  /**
-    End of file indicator for the query text to parse.
-    @param n number of characters expected
-    @return true if there are less than n characters to parse
-  */
-  bool eof(int n) const { return ((m_ptr + n) >= m_end_of_query); }
-
-  /** Get the raw query buffer. */
-  const char *get_buf() const { return m_buf; }
-
-  /** Get the pre-processed query buffer. */
-  const char *get_cpp_buf() const { return m_cpp_buf; }
-
-  /** Get the end of the raw query buffer. */
-  const char *get_end_of_query() const { return m_end_of_query; }
-
-  /** Mark the stream position as the start of a new token. */
-  void start_token() {
-    m_tok_start = m_ptr;
-    m_tok_end = m_ptr;
-
-    m_cpp_tok_start = m_cpp_ptr;
-    m_cpp_tok_end = m_cpp_ptr;
-  }
-
-  /**
-    Adjust the starting position of the current token.
-    This is used to compensate for starting whitespace.
-  */
-  void restart_token() {
-    m_tok_start = m_ptr;
-    m_cpp_tok_start = m_cpp_ptr;
-  }
-
-  /** Get the token start position, in the raw buffer. */
-  const char *get_tok_start() const { return m_tok_start; }
-
-  /** Get the token start position, in the pre-processed buffer. */
-  const char *get_cpp_tok_start() const { return m_cpp_tok_start; }
-
-  /** Get the token end position, in the raw buffer. */
-  const char *get_tok_end() const { return m_tok_end; }
-
-  /** Get the token end position, in the pre-processed buffer. */
-  const char *get_cpp_tok_end() const { return m_cpp_tok_end; }
-
-  /** Get the current stream pointer, in the raw buffer. */
-  const char *get_ptr() const { return m_ptr; }
-
-  /** Get the current stream pointer, in the pre-processed buffer. */
-  const char *get_cpp_ptr() const { return m_cpp_ptr; }
-
-  /** Get the length of the current token, in the raw buffer. */
-  uint yyLength() const {
-    /*
-      The assumption is that the lexical analyser is always 1 character ahead,
-      which the -1 account for.
-    */
-    assert(m_ptr > m_tok_start);
-    return (uint)((m_ptr - m_tok_start) - 1);
-  }
-
-  /** Get the utf8-body string. */
-  const char *get_body_utf8_str() const { return m_body_utf8; }
-
-  /** Get the utf8-body length. */
-  uint get_body_utf8_length() const {
-    return (uint)(m_body_utf8_ptr - m_body_utf8);
-  }
-
-  void body_utf8_start(THD *thd, const char *begin_ptr);
-  void body_utf8_append(const char *ptr);
-  void body_utf8_append(const char *ptr, const char *end_ptr);
-  void body_utf8_append_literal(THD *thd, const LEX_STRING *txt,
-                                const CHARSET_INFO *txt_cs,
-                                const char *end_ptr);
-
-  uint get_lineno(const char *raw_ptr) const;
-
-  /** Current thread. */
-  THD *m_thd;
-
-  /** Current line number. */
-  uint yylineno;
-
-  /** Length of the last token parsed. */
-  uint yytoklen;
-
-  /** Interface with bison, value of the last token parsed. */
-  Lexer_yystype *yylval;
-
-  /**
-    LALR(2) resolution, look ahead token.
-    Value of the next token to return, if any,
-    or -1, if no token was parsed in advance.
-    Note: 0 is a legal token, and represents YYEOF.
-  */
-  int lookahead_token;
-
-  /** LALR(2) resolution, value of the look ahead token.*/
-  Lexer_yystype *lookahead_yylval;
-
-  /// Skip adding of the current token's digest since it is already added
-  ///
-  /// Usually we calculate a digest token by token at the top-level function
-  /// of the lexer: MYSQLlex(). However, some complex ("hintable") tokens break
-  /// that data flow: for example, the `SELECT /*+ HINT(t) */` is the single
-  /// token from the main parser's point of view, and we add the "SELECT"
-  /// keyword to the digest buffer right after the lex_one_token() call,
-  /// but the "/*+ HINT(t) */" is a sequence of separate tokens from the hint
-  /// parser's point of view, and we add those tokens to the digest buffer
-  /// *inside* the lex_one_token() call. Thus, the usual data flow adds
-  /// tokens from the "/*+ HINT(t) */" string first, and only than it appends
-  /// the "SELECT" keyword token to that stream: "/*+ HINT(t) */ SELECT".
-  /// This is not acceptable, since we use the digest buffer to restore
-  /// query strings in their normalized forms, so the order of added tokens is
-  /// important. Thus, we add tokens of "hintable" keywords to a digest buffer
-  /// right in the hint parser and skip adding of them at the caller with the
-  /// help of skip_digest flag.
-  bool skip_digest;
-
-  void add_digest_token(uint token, Lexer_yystype *yylval);
-
-  void reduce_digest_token(uint token_left, uint token_right);
-
-  /**
-    True if this scanner tokenizes a partial query (partition expression,
-    generated column expression etc.)
-
-    @return true if parsing a partial query, otherwise false.
-  */
-  bool is_partial_parser() const { return grammar_selector_token >= 0; }
-
-  /**
-    Outputs warnings on deprecated charsets in complete SQL statements
-
-    @param [in] cs    The character set/collation to check for a deprecation.
-    @param [in] alias The name/alias of @p cs.
-  */
-  void warn_on_deprecated_charset(const CHARSET_INFO *cs,
-                                  const char *alias) const {
-    if (!is_partial_parser()) {
-      ::warn_on_deprecated_charset(m_thd, cs, alias);
-    }
-  }
-
-  /**
-    Outputs warnings on deprecated collations in complete SQL statements
-
-    @param [in] collation     The collation to check for a deprecation.
-  */
-  void warn_on_deprecated_collation(const CHARSET_INFO *collation) const {
-    if (!is_partial_parser()) {
-      ::warn_on_deprecated_collation(m_thd, collation);
-    }
-  }
-
-  const CHARSET_INFO *query_charset;
-
- private:
-  /** Pointer to the current position in the raw input stream. */
-  char *m_ptr;
-
-  /** Starting position of the last token parsed, in the raw buffer. */
-  const char *m_tok_start;
-
-  /** Ending position of the previous token parsed, in the raw buffer. */
-  const char *m_tok_end;
-
-  /** End of the query text in the input stream, in the raw buffer. */
-  const char *m_end_of_query;
-
-  /** Begining of the query text in the input stream, in the raw buffer. */
-  const char *m_buf;
-
-  /** Length of the raw buffer. */
-  size_t m_buf_length;
-
-  /** Echo the parsed stream to the pre-processed buffer. */
-  bool m_echo;
-  bool m_echo_saved;
-
-  /** Pre-processed buffer. */
-  char *m_cpp_buf;
-
-  /** Pointer to the current position in the pre-processed input stream. */
-  char *m_cpp_ptr;
-
-  /**
-    Starting position of the last token parsed,
-    in the pre-processed buffer.
-  */
-  const char *m_cpp_tok_start;
-
-  /**
-    Ending position of the previous token parsed,
-    in the pre-processed buffer.
-  */
-  const char *m_cpp_tok_end;
-
-  /** UTF8-body buffer created during parsing. */
-  char *m_body_utf8;
-
-  /** Pointer to the current position in the UTF8-body buffer. */
-  char *m_body_utf8_ptr;
-
-  /**
-    Position in the pre-processed buffer. The query from m_cpp_buf to
-    m_cpp_utf_processed_ptr is converted to UTF8-body.
-  */
-  const char *m_cpp_utf8_processed_ptr;
-
- public:
-  /** Current state of the lexical analyser. */
-  enum my_lex_states next_state;
-
-  /**
-    Position of ';' in the stream, to delimit multiple queries.
-    This delimiter is in the raw buffer.
-  */
-  const char *found_semicolon;
-
-  /** Token character bitmaps, to detect 7bit strings. */
-  uchar tok_bitmap;
-
-  /** SQL_MODE = IGNORE_SPACE. */
-  bool ignore_space;
-
-  /**
-    true if we're parsing a prepared statement: in this mode
-    we should allow placeholders.
-  */
-  bool stmt_prepare_mode;
-  /**
-    true if we should allow multi-statements.
-  */
-  bool multi_statements;
-
-  /** State of the lexical analyser for comments. */
-  enum_comment_state in_comment;
-  enum_comment_state in_comment_saved;
-
-  /**
-    Starting position of the TEXT_STRING or IDENT in the pre-processed
-    buffer.
-
-    NOTE: this member must be used within MYSQLlex() function only.
-  */
-  const char *m_cpp_text_start;
-
-  /**
-    Ending position of the TEXT_STRING or IDENT in the pre-processed
-    buffer.
-
-    NOTE: this member must be used within MYSQLlex() function only.
-    */
-  const char *m_cpp_text_end;
-
-  /**
-    Character set specified by the character-set-introducer.
-
-    NOTE: this member must be used within MYSQLlex() function only.
-  */
-  const CHARSET_INFO *m_underscore_cs;
-
-  /**
-    Current statement digest instrumentation.
-  */
-  sql_digest_state *m_digest{nullptr};
-
-  /**
-    The synthetic 1st token to prepend token stream with.
-
-    This token value tricks parser to simulate multiple %start-ing points.
-    Currently the grammar is aware of 4 such synthetic tokens:
-    1. GRAMMAR_SELECTOR_PART for partitioning stuff from DD,
-    2. GRAMMAR_SELECTOR_GCOL for generated column stuff from DD,
-    3. GRAMMAR_SELECTOR_EXPR for generic single expressions from DD/.frm.
-    4. GRAMMAR_SELECTOR_CTE for generic subquery expressions from CTEs.
-    5. -1 when parsing with the main grammar (no grammar selector available).
-
-    @note yylex() is expected to return the value of type int:
-          0 is for EOF and everything else for real token numbers.
-          Bison, in its turn, generates positive token numbers.
-          So, the negative grammar_selector_token means "not a token".
-          In other words, -1 is "empty value".
-  */
-  const int grammar_selector_token;
-
-  bool text_string_is_7bit() const { return !(tok_bitmap & 0x80); }
-};
-
-#endif
diff --git a/router/src/routing/src/sql_lexer_parser_input.h b/router/src/routing/src/sql_lexer_parser_input.h
deleted file mode 100644
index c38616e0666..00000000000
--- a/router/src/routing/src/sql_lexer_parser_input.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_SQL_LEXER_PARSER_INFO_INCLUDED
-#define ROUTING_SQL_LEXER_PARSER_INFO_INCLUDED
-
-/**
-  Input parameters to the parser.
-*/
-struct Parser_input {
-  /**
-    True if the text parsed corresponds to an actual query,
-    and not another text artifact.
-    This flag is used to disable digest parsing of nested:
-    - view definitions
-    - table trigger definitions
-    - table partition definitions
-    - event scheduler event definitions
-  */
-  bool m_has_digest;
-  /**
-    True if the caller needs to compute a digest.
-    This flag is used to request explicitly a digest computation,
-    independently of the performance schema configuration.
-  */
-  bool m_compute_digest;
-
-  Parser_input() : m_has_digest(false), m_compute_digest(false) {}
-};
-
-#endif
diff --git a/router/src/routing/src/sql_lexer_parser_state.h b/router/src/routing/src/sql_lexer_parser_state.h
deleted file mode 100644
index c889cc9c782..00000000000
--- a/router/src/routing/src/sql_lexer_parser_state.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_SQL_LEXER_PARSER_STATE_INCLUDED
-#define ROUTING_SQL_LEXER_PARSER_STATE_INCLUDED
-
-#include <cstdlib>
-
-#include "sql_lexer_input_stream.h"
-#include "sql_lexer_parser_input.h"
-#include "sql_lexer_yacc_state.h"
-
-class THD;
-
-/**
-  Internal state of the parser.
-  The complete state consist of:
-  - input parameters that control the parser behavior
-  - state data used during lexical parsing,
-  - state data used during syntactic parsing.
-*/
-class Parser_state {
- protected:
-  /**
-    Constructor for special parsers of partial SQL clauses (DD)
-
-    @param grammar_selector_token   See Lex_input_stream::grammar_selector_token
-  */
-  explicit Parser_state(int grammar_selector_token)
-      : m_input(), m_lip(grammar_selector_token), m_yacc(), m_comment(false) {}
-
- public:
-  Parser_state() : m_input(), m_lip(~0U), m_yacc(), m_comment(false) {}
-
-  /**
-     Object initializer. Must be called before usage.
-
-     @retval false OK
-     @retval true  Error
-  */
-  bool init(THD *thd, const char *buff, size_t length) {
-    return m_lip.init(thd, buff, length);
-  }
-
-  void reset(const char *found_semicolon, size_t length) {
-    m_lip.reset(found_semicolon, length);
-    m_yacc.reset();
-  }
-
-  /// Signal that the current query has a comment
-  void add_comment() { m_comment = true; }
-  /// Check whether the current query has a comment
-  bool has_comment() const { return m_comment; }
-
- public:
-  Parser_input m_input;
-  Lex_input_stream m_lip;
-  Yacc_state m_yacc;
-#if 0
-  /**
-    Current performance digest instrumentation.
-  */
-  PSI_digest_locker *m_digest_psi;
-#endif
- private:
-  bool m_comment;  ///< True if current query contains comments
-};
-
-#endif
diff --git a/router/src/routing/src/sql_lexer_thd.h b/router/src/routing/src/sql_lexer_thd.h
deleted file mode 100644
index ff99c66485c..00000000000
--- a/router/src/routing/src/sql_lexer_thd.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_SQL_LEXER_THD_INCLUDED
-#define ROUTING_SQL_LEXER_THD_INCLUDED
-
-#include "m_ctype.h"   // CHARSET_INFO
-#include "my_alloc.h"  // MEM_ROOT
-#include "my_sys.h"    // strmake_root
-#include "sql_lexer_parser_state.h"
-
-class THD {
- public:
-  using sql_mode_t = ulonglong;
-
-  MEM_ROOT *mem_root{nullptr};  // Pointer to current memroot
-
-  const CHARSET_INFO *charset() const { return variables.character_set_client; }
-  bool convert_string(LEX_STRING * /* to */, const CHARSET_INFO * /* to_cs */,
-                      const char * /* from */, size_t /* from_length */,
-                      const CHARSET_INFO * /* from_cs */,
-                      bool /* report_error */ = false) {
-    return true;
-  }
-
-  void *alloc(size_t size) { return mem_root->Alloc(size); }
-
-  char *strmake(const char *str, size_t size) const {
-    return strmake_root(mem_root, str, size);
-  }
-
- public:
-  struct System_variables {
-    sql_mode_t sql_mode{};
-    const CHARSET_INFO *character_set_client{&my_charset_latin1};
-    const CHARSET_INFO *default_collation_for_utf8mb4{
-        &my_charset_utf8mb4_0900_ai_ci};
-  };
-
-  System_variables variables;
-
-  Parser_state *m_parser_state;
-};
-
-#endif
diff --git a/router/src/routing/src/sql_lexer_yacc_state.h b/router/src/routing/src/sql_lexer_yacc_state.h
deleted file mode 100644
index 12dfcadfeb1..00000000000
--- a/router/src/routing/src/sql_lexer_yacc_state.h
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_SQL_LEXER_YACC_STATE_INCLUDED
-#define ROUTING_SQL_LEXER_YACC_STATE_INCLUDED
-
-#include <cstdlib>
-
-#include "my_inttypes.h"                // uchar, uint, ...
-#include "mysql/service_mysql_alloc.h"  // my_free
-
-/**
-  This class represents the character input stream consumed during lexical
-  analysis.
-
-  In addition to consuming the input stream, this class performs some comment
-  pre processing, by filtering out out-of-bound special text from the query
-  input stream.
-
-  Two buffers, with pointers inside each, are maintained in parallel. The
-  'raw' buffer is the original query text, which may contain out-of-bound
-  comments. The 'cpp' (for comments pre processor) is the pre-processed buffer
-  that contains only the query text that should be seen once out-of-bound data
-  is removed.
-*/
-
-/*
-  Important: if a new lock type is added, a matching lock description
-             must be added to sql_test.cc's lock_descriptions array.
-*/
-enum thr_lock_type {
-  TL_IGNORE = -1,
-  TL_UNLOCK, /* UNLOCK ANY LOCK */
-  /*
-    Parser only! At open_tables() becomes TL_READ or
-    TL_READ_NO_INSERT depending on the binary log format
-    (SBR/RBR) and on the table category (log table).
-    Used for tables that are read by statements which
-    modify tables.
-  */
-  TL_READ_DEFAULT,
-  TL_READ, /* Read lock */
-  TL_READ_WITH_SHARED_LOCKS,
-  /* High prior. than TL_WRITE. Allow concurrent insert */
-  TL_READ_HIGH_PRIORITY,
-  /* READ, Don't allow concurrent insert */
-  TL_READ_NO_INSERT,
-  /*
-     Write lock, but allow other threads to read / write.
-     Used by BDB tables in MySQL to mark that someone is
-     reading/writing to the table.
-   */
-  TL_WRITE_ALLOW_WRITE,
-  /*
-    parser only! Late bound low_priority_flag.
-    At open_tables() becomes thd->insert_lock_default.
-  */
-  TL_WRITE_CONCURRENT_DEFAULT,
-  /*
-    WRITE lock used by concurrent insert. Will allow
-    READ, if one could use concurrent insert on table.
-  */
-  TL_WRITE_CONCURRENT_INSERT,
-  /*
-    parser only! Late bound low_priority flag.
-    At open_tables() becomes thd->update_lock_default.
-  */
-  TL_WRITE_DEFAULT,
-  /* WRITE lock that has lower priority than TL_READ */
-  TL_WRITE_LOW_PRIORITY,
-  /* Normal WRITE lock */
-  TL_WRITE,
-  /* Abort new lock request with an error */
-  TL_WRITE_ONLY
-};
-
-/**
-  Type of metadata lock request.
-
-  @sa Comments for MDL_object_lock::can_grant_lock() and
-      MDL_scoped_lock::can_grant_lock() for details.
-*/
-
-enum enum_mdl_type {
-  /*
-    An intention exclusive metadata lock. Used only for scoped locks.
-    Owner of this type of lock can acquire upgradable exclusive locks on
-    individual objects.
-    This lock type is also used when doing lookups in the dictionary
-    cache. When acquiring objects in a schema, we lock the schema with IX
-    to prevent the schema from being deleted. This should conceptually
-    be an IS lock, but it would have the same behavior as the current IX.
-    Compatible with other IX locks, but is incompatible with scoped S and
-    X locks.
-  */
-  MDL_INTENTION_EXCLUSIVE = 0,
-  /*
-    A shared metadata lock.
-    To be used in cases when we are interested in object metadata only
-    and there is no intention to access object data (e.g. for stored
-    routines or during preparing prepared statements).
-    We also mis-use this type of lock for open HANDLERs, since lock
-    acquired by this statement has to be compatible with lock acquired
-    by LOCK TABLES ... WRITE statement, i.e. SNRW (We can't get by by
-    acquiring S lock at HANDLER ... OPEN time and upgrading it to SR
-    lock for HANDLER ... READ as it doesn't solve problem with need
-    to abort DML statements which wait on table level lock while having
-    open HANDLER in the same connection).
-    To avoid deadlock which may occur when SNRW lock is being upgraded to
-    X lock for table on which there is an active S lock which is owned by
-    thread which waits in its turn for table-level lock owned by thread
-    performing upgrade we have to use thr_abort_locks_for_thread()
-    facility in such situation.
-    This problem does not arise for locks on stored routines as we don't
-    use SNRW locks for them. It also does not arise when S locks are used
-    during PREPARE calls as table-level locks are not acquired in this
-    case.
-  */
-  MDL_SHARED,
-  /*
-    A high priority shared metadata lock.
-    Used for cases when there is no intention to access object data (i.e.
-    data in the table).
-    "High priority" means that, unlike other shared locks, it is granted
-    ignoring pending requests for exclusive locks. Intended for use in
-    cases when we only need to access metadata and not data, e.g. when
-    filling an INFORMATION_SCHEMA table.
-    Since SH lock is compatible with SNRW lock, the connection that
-    holds SH lock lock should not try to acquire any kind of table-level
-    or row-level lock, as this can lead to a deadlock. Moreover, after
-    acquiring SH lock, the connection should not wait for any other
-    resource, as it might cause starvation for X locks and a potential
-    deadlock during upgrade of SNW or SNRW to X lock (e.g. if the
-    upgrading connection holds the resource that is being waited for).
-  */
-  MDL_SHARED_HIGH_PRIO,
-  /*
-    A shared metadata lock for cases when there is an intention to read data
-    from table.
-    A connection holding this kind of lock can read table metadata and read
-    table data (after acquiring appropriate table and row-level locks).
-    This means that one can only acquire TL_READ, TL_READ_NO_INSERT, and
-    similar table-level locks on table if one holds SR MDL lock on it.
-    To be used for tables in SELECTs, subqueries, and LOCK TABLE ...  READ
-    statements.
-  */
-  MDL_SHARED_READ,
-  /*
-    A shared metadata lock for cases when there is an intention to modify
-    (and not just read) data in the table.
-    A connection holding SW lock can read table metadata and modify or read
-    table data (after acquiring appropriate table and row-level locks).
-    To be used for tables to be modified by INSERT, UPDATE, DELETE
-    statements, but not LOCK TABLE ... WRITE or DDL). Also taken by
-    SELECT ... FOR UPDATE.
-  */
-  MDL_SHARED_WRITE,
-  /*
-    A version of MDL_SHARED_WRITE lock which has lower priority than
-    MDL_SHARED_READ_ONLY locks. Used by DML statements modifying
-    tables and using the LOW_PRIORITY clause.
-  */
-  MDL_SHARED_WRITE_LOW_PRIO,
-  /*
-    An upgradable shared metadata lock which allows concurrent updates and
-    reads of table data.
-    A connection holding this kind of lock can read table metadata and read
-    table data. It should not modify data as this lock is compatible with
-    SRO locks.
-    Can be upgraded to SNW, SNRW and X locks. Once SU lock is upgraded to X
-    or SNRW lock data modification can happen freely.
-    To be used for the first phase of ALTER TABLE.
-  */
-  MDL_SHARED_UPGRADABLE,
-  /*
-    A shared metadata lock for cases when we need to read data from table
-    and block all concurrent modifications to it (for both data and metadata).
-    Used by LOCK TABLES READ statement.
-  */
-  MDL_SHARED_READ_ONLY,
-  /*
-    An upgradable shared metadata lock which blocks all attempts to update
-    table data, allowing reads.
-    A connection holding this kind of lock can read table metadata and read
-    table data.
-    Can be upgraded to X metadata lock.
-    Note, that since this type of lock is not compatible with SNRW or SW
-    lock types, acquiring appropriate engine-level locks for reading
-    (TL_READ* for MyISAM, shared row locks in InnoDB) should be
-    contention-free.
-    To be used for the first phase of ALTER TABLE, when copying data between
-    tables, to allow concurrent SELECTs from the table, but not UPDATEs.
-  */
-  MDL_SHARED_NO_WRITE,
-  /*
-    An upgradable shared metadata lock which allows other connections
-    to access table metadata, but not data.
-    It blocks all attempts to read or update table data, while allowing
-    INFORMATION_SCHEMA and SHOW queries.
-    A connection holding this kind of lock can read table metadata modify and
-    read table data.
-    Can be upgraded to X metadata lock.
-    To be used for LOCK TABLES WRITE statement.
-    Not compatible with any other lock type except S and SH.
-  */
-  MDL_SHARED_NO_READ_WRITE,
-  /*
-    An exclusive metadata lock.
-    A connection holding this lock can modify both table's metadata and data.
-    No other type of metadata lock can be granted while this lock is held.
-    To be used for CREATE/DROP/RENAME TABLE statements and for execution of
-    certain phases of other DDL statements.
-  */
-  MDL_EXCLUSIVE,
-  /* This should be the last !!! */
-  MDL_TYPE_END
-};
-
-/**
-  The internal state of the syntax parser.
-  This object is only available during parsing,
-  and is private to the syntax parser implementation (sql_yacc.yy).
-*/
-class Yacc_state {
- public:
-  Yacc_state() : yacc_yyss(nullptr), yacc_yyvs(nullptr), yacc_yyls(nullptr) {
-    reset();
-  }
-
-  void reset() {
-    if (yacc_yyss != nullptr) {
-      my_free(yacc_yyss);
-      yacc_yyss = nullptr;
-    }
-    if (yacc_yyvs != nullptr) {
-      my_free(yacc_yyvs);
-      yacc_yyvs = nullptr;
-    }
-    if (yacc_yyls != nullptr) {
-      my_free(yacc_yyls);
-      yacc_yyls = nullptr;
-    }
-    m_lock_type = TL_READ_DEFAULT;
-    m_mdl_type = MDL_SHARED_READ;
-  }
-
-  ~Yacc_state() {
-    if (yacc_yyss) {
-      my_free(yacc_yyss);
-      my_free(yacc_yyvs);
-      my_free(yacc_yyls);
-    }
-  }
-
-  /**
-    Reset part of the state which needs resetting before parsing
-    substatement.
-  */
-  void reset_before_substatement() {
-    m_lock_type = TL_READ_DEFAULT;
-    m_mdl_type = MDL_SHARED_READ;
-  }
-
-  /**
-    Bison internal state stack, yyss, when dynamically allocated using
-    my_yyoverflow().
-  */
-  uchar *yacc_yyss;
-
-  /**
-    Bison internal semantic value stack, yyvs, when dynamically allocated using
-    my_yyoverflow().
-  */
-  uchar *yacc_yyvs;
-
-  /**
-    Bison internal location value stack, yyls, when dynamically allocated using
-    my_yyoverflow().
-  */
-  uchar *yacc_yyls;
-
-  /**
-    Type of lock to be used for tables being added to the statement's
-    table list in table_factor, table_alias_ref, single_multi and
-    table_wild_one rules.
-    Statements which use these rules but require lock type different
-    from one specified by this member have to override it by using
-    Query_block::set_lock_for_tables() method.
-
-    The default value of this member is TL_READ_DEFAULT. The only two
-    cases in which we change it are:
-    - When parsing SELECT HIGH_PRIORITY.
-    - Rule for DELETE. In which we use this member to pass information
-      about type of lock from delete to single_multi part of rule.
-
-    We should try to avoid introducing new use cases as we would like
-    to get rid of this member eventually.
-  */
-  thr_lock_type m_lock_type;
-
-  /**
-    The type of requested metadata lock for tables added to
-    the statement table list.
-  */
-  enum_mdl_type m_mdl_type;
-
-  /*
-    TODO: move more attributes from the LEX structure here.
-  */
-};
-
-#endif
-- 
2.37.2

