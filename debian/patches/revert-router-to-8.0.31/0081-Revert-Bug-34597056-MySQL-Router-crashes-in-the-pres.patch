From 0fbd67ec52fd3e40098eb79eba7b00e96d24696e Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:22:02 -0500
Subject: [PATCH 81/86] Revert "Bug#34597056 MySQL Router crashes in the
 presence of execution of Nessus scan"

This reverts commit f9b3cc4f8569c785fbd4bfc5326c450ab4bce41e.
---
 router/src/mock_server/src/x_mock_session.cc |  12 +-
 router/src/routing/src/x_connection.cc       | 105 +++++-----
 router/tests/component/test_routing.cc       | 190 +++----------------
 router/tests/helpers/router_test_helpers.cc  |  19 +-
 4 files changed, 86 insertions(+), 240 deletions(-)

diff --git a/router/src/mock_server/src/x_mock_session.cc b/router/src/mock_server/src/x_mock_session.cc
index 1cc2f850402..5ca39170dae 100644
--- a/router/src/mock_server/src/x_mock_session.cc
+++ b/router/src/mock_server/src/x_mock_session.cc
@@ -104,14 +104,10 @@ MySQLXProtocol::decode_single_message(const std::vector<uint8_t> &payload) {
 
   auto buf = net::buffer(payload) + 1;
 
-  try {
-    return {std::in_place, msg_id,
-            protocol_decoder_.decode_message(
-                header_msg_id, static_cast<const uint8_t *>(buf.data()),
-                buf.size())};
-  } catch (...) {
-    return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-  }
+  return {
+      std::in_place, msg_id,
+      protocol_decoder_.decode_message(
+          header_msg_id, static_cast<const uint8_t *>(buf.data()), buf.size())};
 }
 
 void MySQLXProtocol::encode_message(
diff --git a/router/src/routing/src/x_connection.cc b/router/src/routing/src/x_connection.cc
index 7a6b9d83b1f..66abafc183e 100644
--- a/router/src/routing/src/x_connection.cc
+++ b/router/src/routing/src/x_connection.cc
@@ -497,71 +497,52 @@ void MysqlRoutingXConnection::client_recv_cmd() {
     kCursorClose = Mysqlx::ClientMessages::CURSOR_CLOSE,
   };
 
-  // we need to check if the server connection is properly initialized if the
-  // message we are handling is not one from the session setup stage. This may
-  // be the case if the client is not following the protocol properly.
-  bool server_connection_state_ok{true};
-  const auto msg = Msg{msg_type};
-  switch (msg) {
+  switch (Msg{msg_type}) {
+    case Msg::kConClose:
+      // wait for the client to close the connection.
+      return async_recv_client(Function::kWaitClientClose);
     case Msg::kConCapGet:
+      return client_cap_get();
     case Msg::kConCapSet:
+      return client_cap_set();
     case Msg::kSessAuthStart:
-      break;
-    default: {
-      if (!socket_splicer->server_conn().connection()) {
-        server_connection_state_ok = false;
-      }
-    }
-  }
-
-  if (server_connection_state_ok) {
-    switch (msg) {
-      case Msg::kConClose:
-        // wait for the client to close the connection.
-        return async_recv_client(Function::kWaitClientClose);
-      case Msg::kConCapGet:
-        return client_cap_get();
-      case Msg::kConCapSet:
-        return client_cap_set();
-      case Msg::kSessAuthStart:
-        return client_sess_auth_start();
-      case Msg::kSessionReset:
-        return client_session_reset();
-      case Msg::kSessionClose:
-        return client_session_close();
-      case Msg::kStmtExecute:
-        return client_stmt_execute();
-      case Msg::kCrudFind:
-        return client_crud_find();
-      case Msg::kCrudDelete:
-        return client_crud_delete();
-      case Msg::kCrudInsert:
-        return client_crud_insert();
-      case Msg::kCrudUpdate:
-        return client_crud_update();
-      case Msg::kPreparePrepare:
-        return client_prepare_prepare();
-      case Msg::kPrepareDeallocate:
-        return client_prepare_deallocate();
-      case Msg::kPrepareExecute:
-        return client_prepare_execute();
-      case Msg::kExpectOpen:
-        return client_expect_open();
-      case Msg::kExpectClose:
-        return client_expect_close();
-      case Msg::kCrudCreateView:
-        return client_crud_create_view();
-      case Msg::kCrudModifyView:
-        return client_crud_modify_view();
-      case Msg::kCrudDropView:
-        return client_crud_drop_view();
-      case Msg::kCursorOpen:
-        return client_cursor_open();
-      case Msg::kCursorFetch:
-        return client_cursor_fetch();
-      case Msg::kCursorClose:
-        return client_cursor_close();
-    }
+      return client_sess_auth_start();
+    case Msg::kSessionReset:
+      return client_session_reset();
+    case Msg::kSessionClose:
+      return client_session_close();
+    case Msg::kStmtExecute:
+      return client_stmt_execute();
+    case Msg::kCrudFind:
+      return client_crud_find();
+    case Msg::kCrudDelete:
+      return client_crud_delete();
+    case Msg::kCrudInsert:
+      return client_crud_insert();
+    case Msg::kCrudUpdate:
+      return client_crud_update();
+    case Msg::kPreparePrepare:
+      return client_prepare_prepare();
+    case Msg::kPrepareDeallocate:
+      return client_prepare_deallocate();
+    case Msg::kPrepareExecute:
+      return client_prepare_execute();
+    case Msg::kExpectOpen:
+      return client_expect_open();
+    case Msg::kExpectClose:
+      return client_expect_close();
+    case Msg::kCrudCreateView:
+      return client_crud_create_view();
+    case Msg::kCrudModifyView:
+      return client_crud_modify_view();
+    case Msg::kCrudDropView:
+      return client_crud_drop_view();
+    case Msg::kCursorOpen:
+      return client_cursor_open();
+    case Msg::kCursorFetch:
+      return client_cursor_fetch();
+    case Msg::kCursorClose:
+      return client_cursor_close();
   }
 
   {
diff --git a/router/tests/component/test_routing.cc b/router/tests/component/test_routing.cc
index 760d0d2924d..27ee262e243 100644
--- a/router/tests/component/test_routing.cc
+++ b/router/tests/component/test_routing.cc
@@ -61,29 +61,9 @@ std::ostream &operator<<(std::ostream &os,
 
 }  // namespace std
 
-using mysql_harness::ConfigBuilder;
 using mysqlrouter::MySQLSession;
 
-class RouterRoutingTest : public RouterComponentTest {
- public:
-  std::string get_static_routing_section(
-      const std::string &name, uint16_t bind_port, uint16_t server_port,
-      const std::string &protocol,
-      const std::vector<ConfigBuilder::kv_type> &custom_settings = {}) {
-    std::vector<ConfigBuilder::kv_type> options{
-        {"bind_port", std::to_string(bind_port)},
-        {"mode", "read-write"},
-        {"destinations", "127.0.0.1:" + std::to_string(server_port)},
-        {"protocol", protocol}};
-
-    for (const auto &s : custom_settings) {
-      options.push_back(s);
-    }
-
-    return mysql_harness::ConfigBuilder::build_section("routing:"s + name,
-                                                       options);
-  }
-};
+class RouterRoutingTest : public RouterComponentTest {};
 
 using XProtocolSession = std::shared_ptr<xcl::XSession>;
 
@@ -486,6 +466,23 @@ TEST_F(RouterRoutingTest, XProtoHandshakeEmpty) {
 
 class RouterMaxConnectionsTest : public RouterRoutingTest {
  public:
+  std::string get_static_routing_section(
+      const std::string &name, uint16_t bind_port, uint16_t server_port,
+      const std::string &protocol, const std::string &custom_settings = "") {
+    const std::string result = "[routing:"s + name +
+                               "]\n"
+                               "bind_port = " +
+                               std::to_string(bind_port) +
+                               "\n"
+                               "mode = read-write\n"
+                               "destinations = 127.0.0.1:" +
+                               std::to_string(server_port) + "\n" +
+                               "protocol=" + protocol + "\n" + custom_settings +
+                               "\n";
+
+    return result;
+  }
+
   bool make_new_connection(uint16_t port,
                            const std::chrono::milliseconds timeout = 5s) {
     const auto start_timestamp = std::chrono::steady_clock::now();
@@ -524,7 +521,7 @@ TEST_F(RouterMaxConnectionsTest, RoutingTooManyConnections) {
 
   // create a config with routing that has max_connections == 2
   const std::string routing_section = get_static_routing_section(
-      "A", router_port, server_port, "classic", {{"max_connections", "2"}});
+      "A", router_port, server_port, "classic", "max_connections = 2");
 
   TempDirectory conf_dir("conf");
   std::string conf_file = create_config_file(conf_dir.name(), routing_section);
@@ -698,15 +695,15 @@ TEST_F(RouterMaxConnectionsTest,
   // the total_max_connections is 10
   const std::string routing_section_classic_rw = get_static_routing_section(
       "classic_rw", router_classic_rw_port, server_classic_port, "classic",
-      {{"max_connections", "5"}});
+      "max_connections=5");
   const std::string routing_section_classic_ro = get_static_routing_section(
       "classic_ro", router_classic_ro_port, server_classic_port, "classic",
-      {{"max_connections", "5"}});
+      "max_connections=5");
 
   const std::string routing_section_x_rw = get_static_routing_section(
-      "x_rw", router_x_rw_port, server_x_port, "x", {{"max_connections", "2"}});
+      "x_rw", router_x_rw_port, server_x_port, "x", "max_connections=2");
   const std::string routing_section_x_ro = get_static_routing_section(
-      "x_ro", router_x_ro_port, server_x_port, "x", {{"max_connections", "2"}});
+      "x_ro", router_x_ro_port, server_x_port, "x", "max_connections=2");
 
   TempDirectory conf_dir("conf");
 
@@ -795,15 +792,15 @@ TEST_F(RouterMaxConnectionsTest,
   // the total_max_connections is 25
   const std::string routing_section_classic_rw = get_static_routing_section(
       "classic_rw", router_classic_rw_port, server_classic_port, "classic",
-      {{"max_connections", "5"}});
+      "max_connections=5");
   const std::string routing_section_classic_ro = get_static_routing_section(
       "classic_ro", router_classic_ro_port, server_classic_port, "classic",
-      {{"max_connections", "5"}});
+      "max_connections=5");
 
   const std::string routing_section_x_rw = get_static_routing_section(
-      "x_rw", router_x_rw_port, server_x_port, "x", {{"max_connections", "5"}});
+      "x_rw", router_x_rw_port, server_x_port, "x", "max_connections=5");
   const std::string routing_section_x_ro = get_static_routing_section(
-      "x_ro", router_x_ro_port, server_x_port, "x", {{"max_connections", "5"}});
+      "x_ro", router_x_ro_port, server_x_port, "x", "max_connections=5");
 
   TempDirectory conf_dir("conf");
 
@@ -939,7 +936,7 @@ TEST_F(RouterMaxConnectionsTest, WarningWhenLocalMaxConGreaterThanTotalMaxCon) {
   // 600 max_connections the total_max_connections is default 512
   const std::string routing_section_classic_rw = get_static_routing_section(
       "classic_rw", router_classic_rw_port, server_classic_port, "classic",
-      {{"max_connections", "600"}});
+      "max_connections=600");
   TempDirectory conf_dir("conf");
 
   std::string conf_file = create_config_file(
@@ -1697,137 +1694,6 @@ INSTANTIATE_TEST_SUITE_P(Spec, RoutingDefaultConfigTest,
                          ::testing::ValuesIn(routing_default_config_param),
                          [](const auto &info) { return info.param.test_name; });
 
-void shut_and_close_socket(net::impl::socket::native_handle_type sock) {
-  const auto shut_both =
-      static_cast<std::underlying_type_t<net::socket_base::shutdown_type>>(
-          net::socket_base::shutdown_type::shutdown_both);
-  net::impl::socket::shutdown(sock, shut_both);
-  net::impl::socket::close(sock);
-}
-
-net::impl::socket::native_handle_type connect_to_port(
-    const std::string &hostname, uint16_t port) {
-  struct addrinfo hints, *ainfo;
-  memset(&hints, 0, sizeof hints);
-  hints.ai_family = AF_UNSPEC;
-  hints.ai_socktype = SOCK_STREAM;
-  hints.ai_flags = AI_PASSIVE;
-
-  int status = getaddrinfo(hostname.c_str(), std::to_string(port).c_str(),
-                           &hints, &ainfo);
-  if (status != 0) {
-    return net::impl::socket::kInvalidSocket;
-  }
-  std::shared_ptr<void> exit_freeaddrinfo(nullptr,
-                                          [&](void *) { freeaddrinfo(ainfo); });
-
-  auto result =
-      socket(ainfo->ai_family, ainfo->ai_socktype, ainfo->ai_protocol);
-  if (result == net::impl::socket::kInvalidSocket) {
-    return result;
-  }
-
-  status = connect(result, ainfo->ai_addr, ainfo->ai_addrlen);
-  if (status < 0) {
-    return net::impl::socket::kInvalidSocket;
-  }
-
-  return result;
-}
-
-struct InvalidInitMessageParam {
-  std::string client_ssl_mode;
-  std::string server_ssl_mode;
-  // binary data that client sends after connecting
-  std::vector<uint8_t> client_data;
-};
-
-class RouterRoutingXProtocolInvalidInitMessageTest
-    : public RouterRoutingTest,
-      public ::testing::WithParamInterface<InvalidInitMessageParam> {};
-
-/**
- * @test Check if the Router behavior is correct when the client sends
- * unexpected data right after connecting. It is pretty basic test, we check if
- * the Router does not crash and that connecting to the port is still possible
- * after that.
- */
-TEST_P(RouterRoutingXProtocolInvalidInitMessageTest,
-       XProtocolInvalidInitMessageTest) {
-  const auto server_classic_port = port_pool_.get_next_available();
-  const auto server_x_port = port_pool_.get_next_available();
-  const auto router_x_rw_port = port_pool_.get_next_available();
-
-  const std::string json_stmts = get_data_dir().join("bootstrap_gr.js").str();
-
-  launch_mysql_server_mock(json_stmts, server_classic_port, EXIT_SUCCESS, false,
-                           /*http_port*/ 0, server_x_port);
-
-  const std::string routing_x_section =
-      get_static_routing_section("x", router_x_rw_port, server_x_port, "x");
-
-  TempDirectory conf_dir("conf");
-
-  const std::string ssl_conf =
-      "server_ssl_mode="s + GetParam().server_ssl_mode +
-      "\n"
-      "client_ssl_mode="s +
-      GetParam().client_ssl_mode +
-      "\n"
-      "client_ssl_key=" SSL_TEST_DATA_DIR "/server-key-sha512.pem\n" +
-      "client_ssl_cert=" SSL_TEST_DATA_DIR "/server-cert-sha512.pem";
-
-  std::string conf_file =
-      create_config_file(conf_dir.name(), routing_x_section, nullptr,
-                         "mysqlrouter.conf", ssl_conf);
-
-  // launch the router with the created configuration
-  launch_router({"-c", conf_file});
-
-  const auto x_con_sock = connect_to_port("127.0.0.1", router_x_rw_port);
-  ASSERT_NE(net::impl::socket::kInvalidSocket, x_con_sock);
-
-  std::shared_ptr<void> exit_close_socket(
-      nullptr, [&](void *) { shut_and_close_socket(x_con_sock); });
-
-  const auto write_res = net::impl::socket::write(
-      x_con_sock, GetParam().client_data.data(), GetParam().client_data.size());
-
-  ASSERT_TRUE(write_res);
-
-  // check that after we have sent the random data, connecting is still
-  // possible
-  XProtocolSession x_session;
-  const auto res = make_x_connection(x_session, "127.0.0.1", router_x_rw_port,
-                                     "root", "fake-pass");
-
-  EXPECT_THAT(res.error(), ::testing::AnyOf(0, 3159));
-}
-
-INSTANTIATE_TEST_SUITE_P(
-    XProtocolInvalidInitMessageTest,
-    RouterRoutingXProtocolInvalidInitMessageTest,
-
-    ::testing::Values(
-        // ResetSession frame
-        InvalidInitMessageParam{
-            "REQUIRED", "AS_CLIENT", {0x1, 0x0, 0x0, 0x0, 0x6}},
-        InvalidInitMessageParam{
-            "PASSTHROUGH", "AS_CLIENT", {0x1, 0x0, 0x0, 0x0, 0x6}},
-        // SessionClose frame
-        InvalidInitMessageParam{
-            "REQUIRED", "AS_CLIENT", {0x1, 0x0, 0x0, 0x0, 0x7}},
-        InvalidInitMessageParam{
-            "PASSTHROUGH", "AS_CLIENT", {0x1, 0x0, 0x0, 0x0, 0x7}},
-        // short frame
-        InvalidInitMessageParam{"REQUIRED", "AS_CLIENT", {0x1}},
-        InvalidInitMessageParam{"PASSTHROUGH", "AS_CLIENT", {0x1}},
-        // random garbage
-        InvalidInitMessageParam{
-            "REQUIRED", "AS_CLIENT", {0x2, 0x3, 0x4, 0x5, 0x11, 0x22}},
-        InvalidInitMessageParam{
-            "PASSTHROUGH", "AS_CLIENT", {0x2, 0x3, 0x4, 0x5, 0x11, 0x22}}));
-
 int main(int argc, char *argv[]) {
   init_windows_sockets();
   ProcessManager::set_origin(Path(argv[0]).dirname());
diff --git a/router/tests/helpers/router_test_helpers.cc b/router/tests/helpers/router_test_helpers.cc
index fa48f4f051c..0fcefe8bac3 100644
--- a/router/tests/helpers/router_test_helpers.cc
+++ b/router/tests/helpers/router_test_helpers.cc
@@ -56,7 +56,6 @@
 #include "my_inttypes.h"  // ssize_t
 #include "mysql/harness/filesystem.h"
 #include "mysql/harness/net_ts.h"
-#include "mysql/harness/net_ts/impl/socket.h"
 #include "mysql/harness/net_ts/impl/socket_error.h"
 #include "mysql/harness/net_ts/io_context.h"
 #include "mysql/harness/net_ts/socket.h"
@@ -145,13 +144,17 @@ bool pattern_found(const std::string &s, const std::string &pattern) {
 }
 
 namespace {
-void shut_and_close_socket(net::impl::socket::native_handle_type sock) {
-  const auto shut_both =
-      static_cast<std::underlying_type_t<net::socket_base::shutdown_type>>(
-          net::socket_base::shutdown_type::shutdown_both);
-  net::impl::socket::shutdown(sock, shut_both);
-  net::impl::socket::close(sock);
+#ifndef _WIN32
+int close_socket(int sock) {
+  ::shutdown(sock, SHUT_RDWR);
+  return close(sock);
+}
+#else
+int close_socket(SOCKET sock) {
+  ::shutdown(sock, SD_BOTH);
+  return closesocket(sock);
 }
+#endif
 }  // namespace
 
 bool wait_for_port_ready(uint16_t port, std::chrono::milliseconds timeout,
@@ -188,7 +191,7 @@ bool wait_for_port_ready(uint16_t port, std::chrono::milliseconds timeout,
                               "wait_for_port_ready(): socket() failed");
     }
     std::shared_ptr<void> exit_close_socket(
-        nullptr, [&](void *) { shut_and_close_socket(sock_id); });
+        nullptr, [&](void *) { close_socket(sock_id); });
 
 #ifdef _WIN32
     // On Windows if the port is not ready yet when we try the connect() first
-- 
2.37.2

