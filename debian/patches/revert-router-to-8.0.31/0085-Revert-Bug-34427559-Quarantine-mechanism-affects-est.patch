From fc06996082e2b86ec6f9f9e35d5d6b86e69984e3 Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:22:23 -0500
Subject: [PATCH 85/86] Revert "Bug#34427559 Quarantine mechanism affects
 establishing connections to Router"

This reverts commit 03ec95b9a52a575113ddfc7bb790598ffb53d570.
---
 .../routing_common_unreachable_destinations.h |  70 +---
 ...routing_common_unreachable_destinations.cc | 382 +++++-------------
 2 files changed, 117 insertions(+), 335 deletions(-)

diff --git a/router/src/routing/include/mysqlrouter/routing_common_unreachable_destinations.h b/router/src/routing/include/mysqlrouter/routing_common_unreachable_destinations.h
index ed679f2fb41..de3168aef6e 100644
--- a/router/src/routing/include/mysqlrouter/routing_common_unreachable_destinations.h
+++ b/router/src/routing/include/mysqlrouter/routing_common_unreachable_destinations.h
@@ -81,14 +81,6 @@ class RoutingCommonUnreachableDestinations {
   void add_destination_candidate_to_quarantine(
       const mysql_harness::TCPAddress &dest);
 
-  /**
-   * Remove unreachable destination candidate from quarantine.
-   *
-   * @param[in] dest Unreachable destination candidate address.
-   */
-  void remove_destination_candidate_from_quarantine(
-      const mysql_harness::TCPAddress &dest);
-
   /**
    * Query the quarantined destination candidates set and check if the given
    * destination candidate is quarantined.
@@ -185,17 +177,11 @@ class RoutingCommonUnreachableDestinations {
    */
   struct Unreachable_destination_candidate {
     Unreachable_destination_candidate(
-        net::io_context *io_ctx, const mysql_harness::TCPAddress &addr,
-        std::vector<std::string> referencing_instances,
-        std::chrono::seconds quarantine_interval,
-        std::function<void()> on_delete, std::function<void()> on_connect_ok)
-        : io_ctx_{io_ctx},
-          address_{addr},
-          referencing_routing_instances_{std::move(referencing_instances)},
-          quarantine_interval_{quarantine_interval},
-          timer_{*io_ctx},
-          on_delete_{on_delete},
-          on_connect_ok_{on_connect_ok} {}
+        mysql_harness::TCPAddress addr, net::steady_timer timer,
+        std::vector<std::string> referencing_instances)
+        : address_{std::move(addr)},
+          timer_{std::move(timer)},
+          referencing_routing_instances_{std::move(referencing_instances)} {}
 
     ~Unreachable_destination_candidate();
 
@@ -203,68 +189,26 @@ class RoutingCommonUnreachableDestinations {
         default;
     Unreachable_destination_candidate &operator=(
         Unreachable_destination_candidate &&) = default;
-
     Unreachable_destination_candidate(
         const Unreachable_destination_candidate &) = delete;
     Unreachable_destination_candidate &operator=(
         const Unreachable_destination_candidate &) = delete;
 
-    stdx::expected<void, std::error_code> connect();
-
-    stdx::expected<void, std::error_code> resolve();
-    stdx::expected<void, std::error_code> init_endpoint();
-    stdx::expected<void, std::error_code> next_endpoint();
-    stdx::expected<void, std::error_code> connect_init();
-    stdx::expected<void, std::error_code> try_connect();
-    stdx::expected<void, std::error_code> connect_finish();
-    stdx::expected<void, std::error_code> connected();
-
-    RoutingCommonUnreachableDestinations *destinations_;
-    net::io_context *io_ctx_;
     mysql_harness::TCPAddress address_;
-    std::vector<std::string> referencing_routing_instances_;
-    std::chrono::seconds quarantine_interval_;
     net::steady_timer timer_;
-
-    using server_protocol_type = net::ip::tcp;
-
-    net::ip::tcp::resolver::results_type endpoints_;
-    net::ip::tcp::resolver::results_type::iterator endpoints_it_;
-    server_protocol_type::socket server_sock_{*io_ctx_};
-    server_protocol_type::endpoint server_endpoint_;
-
-    bool connect_timed_out_{false};
-    bool connected_{false};
-
-    enum class Function {
-      kInitDestination,
-      kConnectFinish,
-    };
-
-    Function func_{Function::kInitDestination};
-
-    std::error_code last_ec_{
-        make_error_code(std::errc::no_such_file_or_directory)};
-
-    std::function<void()> on_delete_;
-    std::function<void()> on_connect_ok_;
+    std::vector<std::string> referencing_routing_instances_;
   };
 
   std::chrono::milliseconds kQuarantinedConnectTimeout{1000};
   std::chrono::seconds quarantine_interval_{1};
   net::io_context &io_ctx_ = IoComponent::get_instance().io_context();
   std::mutex quarantine_mutex_;
-  std::vector<std::shared_ptr<Unreachable_destination_candidate>>
+  std::vector<Unreachable_destination_candidate>
       quarantined_destination_candidates_;
   std::mutex unreachable_destinations_init_mutex_;
   std::mutex routing_instances_mutex_;
   std::vector<std::string> routing_instances_;
   std::atomic<bool> stopped_{false};
-
-  /** number of quarantined destinations */
-  std::atomic<size_t> quarantined_dest_counter_{0};
-  std::condition_variable quarantine_empty_cond_;
-  std::mutex quarantine_empty_cond_m_;
 };
 
 #endif  // MYSQLROUTER_ROUTING_COMMON_UNREACHABLE_DESTINATIONS_INCLUDED
diff --git a/router/src/routing/src/routing_common_unreachable_destinations.cc b/router/src/routing/src/routing_common_unreachable_destinations.cc
index e8703a082fe..bb394b08195 100644
--- a/router/src/routing/src/routing_common_unreachable_destinations.cc
+++ b/router/src/routing/src/routing_common_unreachable_destinations.cc
@@ -29,6 +29,70 @@
 
 IMPORT_LOG_FUNCTIONS()
 
+static stdx::expected<void, std::error_code> tcp_port_alive(
+    net::io_context &io_ctx, const std::string &host, const uint16_t port,
+    const std::chrono::milliseconds connect_timeout) {
+  net::ip::tcp::resolver resolver(io_ctx);
+
+  const auto resolve_res = resolver.resolve(host, std::to_string(port));
+  if (!resolve_res) {
+    return resolve_res.get_unexpected();
+  }
+
+  std::error_code last_ec{};
+
+  // try all known addresses of the hostname
+  for (auto const &resolved : resolve_res.value()) {
+    net::ip::tcp::socket sock(io_ctx);
+
+    auto open_res = sock.open(resolved.endpoint().protocol());
+    if (!open_res) {
+      return open_res.get_unexpected();
+    }
+
+    sock.native_non_blocking(true);
+    const auto connect_res = sock.connect(resolved.endpoint());
+
+    if (!connect_res) {
+      if (connect_res.error() ==
+              make_error_condition(std::errc::operation_in_progress) ||
+          connect_res.error() ==
+              make_error_condition(std::errc::operation_would_block)) {
+        std::array<pollfd, 1> pollfds = {{
+            {sock.native_handle(), POLLOUT, 0},
+        }};
+
+        const auto wait_res = net::impl::poll::poll(
+            pollfds.data(), pollfds.size(), connect_timeout);
+
+        if (!wait_res) {
+          last_ec = wait_res.error();
+        } else {
+          net::socket_base::error err;
+          const auto status_res = sock.get_option(err);
+          if (!status_res) {
+            last_ec = status_res.error();
+          } else if (err.value() != 0) {
+            last_ec = net::impl::socket::make_error_code(err.value());
+          } else {
+            // success, we can continue
+            return {};
+          }
+        }
+      } else {
+        last_ec = connect_res.error();
+      }
+    } else {
+      // everything is fine, we are connected
+      return {};
+    }
+
+    // it failed, try the next address
+  }
+
+  return stdx::make_unexpected(last_ec);
+}
+
 void RoutingCommonUnreachableDestinations::init(
     const std::string &instance_name,
     std::chrono::seconds quarantine_refresh_interval) {
@@ -50,77 +114,37 @@ void RoutingCommonUnreachableDestinations::
 
   {
     std::lock_guard<std::mutex> quarantine_lock{quarantine_mutex_};
-    if (stopped_) return;
     auto pos = std::find_if(std::begin(quarantined_destination_candidates_),
                             std::end(quarantined_destination_candidates_),
                             [&dest](const auto &quarantined_dest) {
-                              return quarantined_dest->address_ == dest;
+                              return quarantined_dest.address_ == dest;
                             });
     if (pos != std::end(quarantined_destination_candidates_)) {
       // it is already quarantined, just update the references
-      (*pos)->referencing_routing_instances_ = referencing_instances;
+      pos->referencing_routing_instances_ = referencing_instances;
       return;
     }
 
-    auto dest_cand = std::make_shared<Unreachable_destination_candidate>(
-        &io_ctx_, dest, std::move(referencing_instances), quarantine_interval_,
-        /* on delete */
-        [&]() {
-          std::unique_lock<std::mutex> lk(quarantine_empty_cond_m_);
-          quarantined_dest_counter_--;
-          quarantine_empty_cond_.notify_all();
-        },
-        /* on connected to destination */
-        [this, dest]() { remove_destination_candidate_from_quarantine(dest); });
-    quarantined_dest_counter_++;
-
-    auto &timer = dest_cand->timer_;
-    timer.expires_after(quarantine_interval_);
-    timer.async_wait([this, dest](const std::error_code &ec) {
+    net::steady_timer quarantine_timer{io_ctx_};
+    quarantine_timer.expires_after(quarantine_interval_);
+    quarantine_timer.async_wait([this, dest](const std::error_code &ec) {
       quarantine_handler(ec, dest);
     });
-
-    quarantined_destination_candidates_.push_back(std::move(dest_cand));
+    quarantined_destination_candidates_.emplace_back(
+        std::move(dest), std::move(quarantine_timer),
+        std::move(referencing_instances));
   }
 
   stop_socket_acceptors_on_all_nodes_quarantined();
 }
 
-void RoutingCommonUnreachableDestinations::
-    remove_destination_candidate_from_quarantine(
-        const mysql_harness::TCPAddress &dest) {
-  log_debug(
-      "Destination candidate '%s' is available, remove it from quarantine",
-      dest.str().c_str());
-
-  std::lock_guard<std::mutex> quarantine_lock{quarantine_mutex_};
-  auto pos = std::find_if(std::begin(quarantined_destination_candidates_),
-                          std::end(quarantined_destination_candidates_),
-                          [&dest](const auto &quarantined_dest) {
-                            return quarantined_dest->address_ == dest;
-                          });
-  if (pos == std::end(quarantined_destination_candidates_)) {
-    return;
-  }
-
-  auto &component = MySQLRoutingComponent::get_instance();
-  auto &routing_instances = (*pos)->referencing_routing_instances_;
-  for (const auto &instance_name : routing_instances) {
-    auto routing_instance = component.api(instance_name);
-
-    routing_instance.start_accepting_connections();
-  }
-
-  quarantined_destination_candidates_.erase(pos);
-}
-
 bool RoutingCommonUnreachableDestinations::is_quarantined(
     const mysql_harness::TCPAddress &dest) {
   std::lock_guard<std::mutex> l{quarantine_mutex_};
   return std::find_if(std::begin(quarantined_destination_candidates_),
                       std::end(quarantined_destination_candidates_),
                       [&dest](const auto &quarantined_dest) {
-                        return quarantined_dest->address_ == dest;
+                        return quarantined_dest.address_ == dest;
                       }) != std::end(quarantined_destination_candidates_);
 }
 
@@ -135,23 +159,13 @@ void RoutingCommonUnreachableDestinations::refresh_quarantine(
 }
 
 void RoutingCommonUnreachableDestinations::stop_quarantine() {
-  {
-    std::lock_guard<std::mutex> l{quarantine_mutex_};
-    if (stopped_) return;
-    log_debug("Clear shared unreachable destinations quarantine list");
-    stopped_ = true;
-    std::for_each(std::begin(quarantined_destination_candidates_),
-                  std::end(quarantined_destination_candidates_),
-                  [](auto &dest) {
-                    dest->server_sock_.cancel();
-                    dest->timer_.cancel();
-                  });
-    quarantined_destination_candidates_.clear();
-  }
-
-  std::unique_lock<std::mutex> lk(quarantine_empty_cond_m_);
-  quarantine_empty_cond_.wait(lk,
-                              [&] { return quarantined_dest_counter_ == 0; });
+  log_debug("Clear shared unreachable destinations quarantine list");
+  stopped_ = true;
+  std::lock_guard<std::mutex> l{quarantine_mutex_};
+  std::for_each(std::begin(quarantined_destination_candidates_),
+                std::end(quarantined_destination_candidates_),
+                [](auto &dest) { dest.timer_.cancel(); });
+  quarantined_destination_candidates_.clear();
 }
 
 void RoutingCommonUnreachableDestinations::quarantine_handler(
@@ -162,64 +176,37 @@ void RoutingCommonUnreachableDestinations::quarantine_handler(
     if (stopped_) return;
   }
 
-  std::shared_ptr<Unreachable_destination_candidate> destination;
-  {
-    std::lock_guard<std::mutex> l{quarantine_mutex_};
-    auto pos = std::find_if(std::begin(quarantined_destination_candidates_),
-                            std::end(quarantined_destination_candidates_),
-                            [&dest](const auto &quarantined_dest) {
-                              return quarantined_dest->address_ == dest;
-                            });
-    if (pos == std::end(quarantined_destination_candidates_)) return;
-
-    if (ec && ec != std::errc::operation_canceled) {
-      // Something went wrong, play it safe and remove the destination
-      quarantined_destination_candidates_.erase(pos);
-      return;
-    }
+  const auto port_alive = tcp_port_alive(io_ctx_, dest.address(), dest.port(),
+                                         kQuarantinedConnectTimeout);
+  std::lock_guard<std::mutex> l{quarantine_mutex_};
+  auto pos = std::find_if(std::begin(quarantined_destination_candidates_),
+                          std::end(quarantined_destination_candidates_),
+                          [&dest](const auto &quarantined_dest) {
+                            return quarantined_dest.address_ == dest;
+                          });
+  if (pos == std::end(quarantined_destination_candidates_)) return;
 
-    destination = *pos;
+  if (ec && ec != std::errc::operation_canceled) {
+    // Something went wrong, play it safe and remove the destination
+    quarantined_destination_candidates_.erase(pos);
+    return;
   }
 
-  auto connect_res = destination->connect();
-  if (!connect_res) {
-    const auto ec = connect_res.error();
-    if ((ec == make_error_condition(std::errc::operation_in_progress) ||
-         ec == make_error_condition(std::errc::operation_would_block))) {
-      auto &t = destination->timer_;
+  if (port_alive) {
+    log_debug(
+        "Destination candidate '%s' is available, remove it from quarantine",
+        pos->address_.str().c_str());
 
-      t.expires_after(kQuarantinedConnectTimeout);
+    auto &component = MySQLRoutingComponent::get_instance();
+    auto &routing_instances = pos->referencing_routing_instances_;
+    for (const auto &instance_name : routing_instances) {
+      auto routing_instance = component.api(instance_name);
 
-      t.async_wait([destination](std::error_code ec) {
-        if (ec) {
-          return;
-        }
-
-        destination->connect_timed_out_ = true;
-        destination->server_sock_.cancel();
-      });
-
-      destination->server_sock_.async_wait(
-          net::socket_base::wait_write,
-          [this, destination, dest](std::error_code ec) {
-            if (ec) {
-              if (destination->connect_timed_out_) {
-                quarantine_handler({}, dest);
-              }
-              return;
-            }
-
-            destination->timer_.cancel();
-            quarantine_handler({}, dest);
-          });
-
-      return;
+      routing_instance.start_accepting_connections();
     }
-
-    destination->server_sock_.close();
-    auto &timer = destination->timer_;
-    destination->func_ =
-        Unreachable_destination_candidate::Function::kInitDestination;
+    quarantined_destination_candidates_.erase(pos);
+  } else {
+    auto &timer = pos->timer_;
     timer.cancel();
     timer.expires_after(quarantine_interval_);
     timer.async_wait([this, dest](const std::error_code &ec) {
@@ -271,10 +258,10 @@ void RoutingCommonUnreachableDestinations::update_destinations_state(
         std::find_if(std::begin(quarantined_destination_candidates_),
                      std::end(quarantined_destination_candidates_),
                      [&](auto &quarantined_dest) {
-                       return quarantined_dest->address_ == destination.address;
+                       return quarantined_dest.address_ == destination.address;
                      });
     if (quarantined_pos != std::end(quarantined_destination_candidates_)) {
-      (*quarantined_pos)->timer_.cancel();
+      quarantined_pos->timer_.cancel();
     }
   }
 }
@@ -286,7 +273,7 @@ void RoutingCommonUnreachableDestinations::drop_stray_destinations(
   auto quarantined_dest = std::begin(quarantined_destination_candidates_);
   while (quarantined_dest != std::end(quarantined_destination_candidates_)) {
     auto &referencing_instances =
-        (*quarantined_dest)->referencing_routing_instances_;
+        quarantined_dest->referencing_routing_instances_;
     const auto referencing_routing_pos =
         std::find(std::begin(referencing_instances),
                   std::end(referencing_instances), instance_name);
@@ -296,7 +283,7 @@ void RoutingCommonUnreachableDestinations::drop_stray_destinations(
       if (std::find_if(std::begin(routing_new_destinations),
                        std::end(routing_new_destinations),
                        [&quarantined_dest](const auto &dest) {
-                         return dest.address == (*quarantined_dest)->address_;
+                         return dest.address == quarantined_dest->address_;
                        }) == std::end(routing_new_destinations)) {
         // Quarantined destination is no longer a destination to the given
         // routing plugin
@@ -310,7 +297,7 @@ void RoutingCommonUnreachableDestinations::drop_stray_destinations(
       log_debug(
           "Remove '%s' from quarantine, no plugin is using this destination "
           "candidate",
-          (*quarantined_dest)->address_.str().c_str());
+          quarantined_dest->address_.str().c_str());
       quarantined_dest =
           quarantined_destination_candidates_.erase(quarantined_dest);
     } else {
@@ -323,153 +310,4 @@ RoutingCommonUnreachableDestinations::Unreachable_destination_candidate::
     ~Unreachable_destination_candidate() {
   referencing_routing_instances_.clear();
   timer_.cancel();
-  if (on_delete_) {
-    on_delete_();
-  }
 }
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::connect() {
-  switch (func_) {
-    case Function::kInitDestination: {
-      auto init_res = resolve();
-      if (!init_res) return init_res.get_unexpected();
-
-    } break;
-    case Function::kConnectFinish: {
-      auto connect_res = connect_finish();
-      if (!connect_res) return connect_res.get_unexpected();
-
-    } break;
-  }
-
-  if (!connected_) {
-    auto connect_res = try_connect();
-    if (!connect_res) return connect_res.get_unexpected();
-  }
-
-  return {};
-}
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::resolve() {
-  net::ip::tcp::resolver resolver(*io_ctx_);
-  const auto resolve_res =
-      resolver.resolve(address_.address(), std::to_string(address_.port()));
-
-  if (!resolve_res) {
-    return resolve_res.get_unexpected();
-  }
-
-  endpoints_ = resolve_res.value();
-
-  return init_endpoint();
-}
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::init_endpoint() {
-  endpoints_it_ = endpoints_.begin();
-
-  return connect_init();
-}
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::connect_init() {
-  // close socket if it is already open
-  server_sock_.close();
-  connect_timed_out_ = false;
-  auto endpoint = *endpoints_it_;
-  server_endpoint_ = endpoint.endpoint();
-
-  return {};
-}
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::try_connect() {
-  const int socket_flags {
-#if defined(SOCK_NONBLOCK)
-    // linux|freebsd|sol11.4 allows to set NONBLOCK as part of the socket()
-    // call to save the extra syscall
-    SOCK_NONBLOCK
-#endif
-  };
-
-  auto open_res = server_sock_.open(server_endpoint_.protocol(), socket_flags);
-  if (!open_res) return open_res.get_unexpected();
-
-  const auto non_block_res = server_sock_.native_non_blocking(true);
-  if (!non_block_res) return non_block_res.get_unexpected();
-
-  server_sock_.set_option(net::ip::tcp::no_delay{true});
-
-  const auto connect_res = server_sock_.connect(server_endpoint_);
-  if (!connect_res) {
-    const auto ec = connect_res.error();
-    if (ec == make_error_condition(std::errc::operation_in_progress) ||
-        ec == make_error_condition(std::errc::operation_would_block)) {
-      // connect in progress, wait for completion.
-      func_ = Function::kConnectFinish;
-      return connect_res.get_unexpected();
-    } else {
-      last_ec_ = ec;
-      return next_endpoint();
-    }
-  }
-  return connected();
-}
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::next_endpoint() {
-  std::advance(endpoints_it_, 1);
-
-  if (endpoints_it_ != endpoints_.end()) {
-    return connect_init();
-  } else {
-    return stdx::make_unexpected(last_ec_);
-  }
-}
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::connect_finish() {
-  if (connect_timed_out_) {
-    last_ec_ = make_error_code(std::errc::timed_out);
-
-    return next_endpoint();
-  }
-
-  net::socket_base::error sock_err;
-  const auto getopt_res = server_sock_.get_option(sock_err);
-
-  if (!getopt_res) {
-    last_ec_ = getopt_res.error();
-    return next_endpoint();
-  }
-
-  if (sock_err.value() != 0) {
-    std::error_code ec {
-      sock_err.value(),
-#if defined(_WIN32)
-          std::system_category()
-#else
-          std::generic_category()
-#endif
-    };
-
-    last_ec_ = ec;
-
-    return next_endpoint();
-  }
-
-  return connected();
-}
-
-stdx::expected<void, std::error_code> RoutingCommonUnreachableDestinations::
-    Unreachable_destination_candidate::connected() {
-  connected_ = true;
-
-  if (on_connect_ok_) {
-    on_connect_ok_();
-  }
-
-  return {};
-}
\ No newline at end of file
-- 
2.37.2

