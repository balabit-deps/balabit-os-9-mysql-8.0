From 71c3f115799b04e14c27629c5dd71c4d696ec6ee Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:04:52 -0500
Subject: [PATCH 24/86] Revert "Bug#34787953 add missing AF_UNIX support on
 windows"

This reverts commit 1570bc65a6fc00629eee7e196335d1f0555b4ea8.
---
 .../mysql/harness/net_ts/impl/socket.h        | 161 +++----
 .../include/mysql/harness/net_ts/local.h      |   2 +-
 router/src/harness/tests/test_net_ts_local.cc | 403 ++++--------------
 3 files changed, 135 insertions(+), 431 deletions(-)

diff --git a/router/src/harness/include/mysql/harness/net_ts/impl/socket.h b/router/src/harness/include/mysql/harness/net_ts/impl/socket.h
index 3251cd36bb1..478975e843f 100644
--- a/router/src/harness/include/mysql/harness/net_ts/impl/socket.h
+++ b/router/src/harness/include/mysql/harness/net_ts/impl/socket.h
@@ -28,16 +28,12 @@
 #include <algorithm>  // max
 #include <array>
 #include <bitset>
-#include <cinttypes>  // PRIx64
 #include <limits>
 #include <system_error>
 
 #ifdef _WIN32
 #include <WinSock2.h>
 #include <Windows.h>
-#ifdef AF_UNIX
-#include <afunix.h>
-#endif
 #else
 #include <fcntl.h>
 #include <netinet/in.h>
@@ -53,8 +49,6 @@
 #include "mysql/harness/net_ts/impl/socket_error.h"
 #include "mysql/harness/stdx/expected.h"
 
-#include "scope_guard.h"
-
 namespace net {
 namespace impl {
 namespace socket {
@@ -445,7 +439,8 @@ inline stdx::expected<void, error_type> getpeername(
  * socketpair().
  *
  * - wraps socketpair() on POSIX
- * - emulates socketpair() on windows as winsock2() provides no socketpair.
+ * - emualated on windows via a AF_INET + SOCK_STREAM socket on localhost on a
+ *   system assigned port.
  */
 inline stdx::expected<std::pair<native_handle_type, native_handle_type>,
                       error_type>
@@ -459,123 +454,73 @@ socketpair(int family, int sock_type, int protocol) {
 
   return std::make_pair(fds[0], fds[1]);
 #else
+  if (family != AF_INET) {
+    return stdx::make_unexpected(
+        std::error_code(WSAEAFNOSUPPORT, std::system_category()));
+  }
+  if (sock_type != SOCK_STREAM) {
+    return stdx::make_unexpected(
+        std::error_code(WSAESOCKTNOSUPPORT, std::system_category()));
+  }
+  // we don't have socketpair on windows, build one ourselves
   auto listener_res = impl::socket::socket(family, sock_type, protocol);
   if (!listener_res) return stdx::make_unexpected(listener_res.error());
-
   auto listener = listener_res.value();
 
-  Scope_guard listener_guard([listener]() {
-#if defined(AF_UNIX)
-    struct sockaddr_storage ss {};
-    size_t ss_len = sizeof(ss);
-
-    auto name_res = impl::socket::getsockname(
-        listener, reinterpret_cast<sockaddr *>(&ss), &ss_len);
-    if (name_res) {
-      if (ss.ss_family == AF_UNIX) {
-        struct sockaddr_un *su = reinterpret_cast<sockaddr_un *>(&ss);
-
-        // delete the named socket
-        DeleteFile(su->sun_path);
-      }
-    }
-#endif
-
-    impl::socket::close(listener);
-  });
-
-  stdx::expected<void, std::error_code> bind_res;
+  int reuse = 1;
+  impl::socket::setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &reuse,
+                           sizeof(reuse));
 
-  switch (family) {
-    case AF_INET: {
-      int reuse = 1;
-      impl::socket::setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &reuse,
-                               sizeof(reuse));
+  struct sockaddr_in sa {};
+  sa.sin_family = family;
+  sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+  sa.sin_port = 0;  // pick a random port
 
-      struct sockaddr_in sa {};
-      size_t sa_len = sizeof(sa);
-
-      sa.sin_family = family;
-      sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-      sa.sin_port = 0;  // pick a random port
-
-      bind_res = impl::socket::bind(listener, reinterpret_cast<sockaddr *>(&sa),
-                                    sa_len);
-    } break;
-#if defined(AF_UNIX)
-    case AF_UNIX: {
-      struct sockaddr_un sa {};
-      size_t sa_len = sizeof(sa);
-
-      sa.sun_family = family;
-
-      DWORD path_len = GetTempPath(UNIX_PATH_MAX, sa.sun_path);
-
-      // use the current dir if the tmppath is too long.
-      if (path_len >= UNIX_PATH_MAX - 9) path_len = 0;
-
-      LARGE_INTEGER ticks;
-      QueryPerformanceCounter(&ticks);
-
-      snprintf(sa.sun_path + path_len, UNIX_PATH_MAX - path_len,
-               "%" PRIx64 "-%lu.sok", ticks.QuadPart, GetCurrentProcessId());
-
-      bind_res = impl::socket::bind(listener, reinterpret_cast<sockaddr *>(&sa),
-                                    sa_len);
-    } break;
-#endif
-    default:
-      bind_res = stdx::make_unexpected(
-          make_error_code(std::errc::address_family_not_supported));
-      break;
+  size_t sa_len = sizeof(sa);
+  auto bind_res =
+      impl::socket::bind(listener, reinterpret_cast<sockaddr *>(&sa), sa_len);
+  if (!bind_res) {
+    impl::socket::close(listener);
+    return stdx::make_unexpected(bind_res.error());
   }
-
-  if (!bind_res) return stdx::make_unexpected(bind_res.error());
-
   auto listen_res = impl::socket::listen(listener, 128);
-  if (!listen_res) return stdx::make_unexpected(listen_res.error());
+  if (!listen_res) {
+    impl::socket::close(listener);
+    return stdx::make_unexpected(listen_res.error());
+  }
+  auto first_res = impl::socket::socket(AF_INET, SOCK_STREAM, 0);
+  if (!first_res) {
+    impl::socket::close(listener);
+    return stdx::make_unexpected(first_res.error());
+  }
 
-  auto first_res = impl::socket::socket(family, sock_type, protocol);
-  if (!first_res) return stdx::make_unexpected(first_res.error());
+  memset(&sa, 0, sizeof(sa));
+  impl::socket::getsockname(listener, reinterpret_cast<sockaddr *>(&sa),
+                            &sa_len);
+  sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+  sa.sin_family = AF_INET;
 
   auto first_fd = first_res.value();
 
-  Scope_guard first_fd_guard([first_fd]() { impl::socket::close(first_fd); });
-
-  auto remote_sa_res = [](auto sock_handle)
-      -> stdx::expected<sockaddr_storage, std::error_code> {
-    struct sockaddr_storage ss {};
-    size_t ss_len = sizeof(ss);
-
-    const auto name_res = impl::socket::getsockname(
-        sock_handle, reinterpret_cast<sockaddr *>(&ss), &ss_len);
-    if (!name_res) return stdx::make_unexpected(name_res.error());
-
-    // overwrite the address.
-    if (ss.ss_family == AF_INET) {
-      auto *sa = reinterpret_cast<sockaddr_in *>(&ss);
-
-      sa->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-    }
-
-    return ss;
-  }(listener);
-
-  if (!remote_sa_res) return stdx::make_unexpected(remote_sa_res.error());
-  const auto remote_sa = *remote_sa_res;
-
-  const auto connect_res = impl::socket::connect(
-      first_fd, reinterpret_cast<const sockaddr *>(&remote_sa),
-      sizeof(remote_sa));
-  if (!connect_res) return stdx::make_unexpected(connect_res.error());
-
-  const auto second_res = impl::socket::accept(listener, nullptr, nullptr);
-  if (!second_res) return stdx::make_unexpected(second_res.error());
+  auto connect_res = impl::socket::connect(
+      first_fd, reinterpret_cast<sockaddr *>(&sa), sa_len);
+  if (!connect_res) {
+    impl::socket::close(listener);
+    impl::socket::close(first_fd);
+    return stdx::make_unexpected(connect_res.error());
+  }
 
-  first_fd_guard.commit();
+  auto second_res = impl::socket::accept(listener, nullptr, nullptr);
+  if (!second_res) {
+    impl::socket::close(listener);
+    impl::socket::close(first_fd);
+    return stdx::make_unexpected(second_res.error());
+  }
 
   auto second_fd = second_res.value();
 
+  impl::socket::close(listener);
+
   return std::make_pair(first_fd, second_fd);
 #endif
 }
diff --git a/router/src/harness/include/mysql/harness/net_ts/local.h b/router/src/harness/include/mysql/harness/net_ts/local.h
index 462a8171d15..108e07411cc 100644
--- a/router/src/harness/include/mysql/harness/net_ts/local.h
+++ b/router/src/harness/include/mysql/harness/net_ts/local.h
@@ -36,7 +36,7 @@
 #include <WinSock2.h>
 #include <Windows.h>
 
-#ifdef AF_UNIX
+#ifdef HAVE_AF_UNIX_H
 #include <afunix.h>
 #define NET_TS_HAS_UNIX_SOCKET
 #endif
diff --git a/router/src/harness/tests/test_net_ts_local.cc b/router/src/harness/tests/test_net_ts_local.cc
index bf427782ae4..e70db6622d3 100644
--- a/router/src/harness/tests/test_net_ts_local.cc
+++ b/router/src/harness/tests/test_net_ts_local.cc
@@ -24,45 +24,14 @@
 
 #include "mysql/harness/net_ts/local.h"
 
-#include <system_error>
-
 #include <gmock/gmock.h>
 
 #include "mysql/harness/net_ts/socket.h"  // net::impl::socket::init
+
 #include "mysql/harness/stdx/expected_ostream.h"
 #include "test/temp_directory.h"
 
-template <class T, class E>
-::testing::AssertionResult StdxExpectedSuccess(const char *expr,
-                                               const stdx::expected<T, E> &e) {
-  if (e) return ::testing::AssertionSuccess();
-
-  return ::testing::AssertionFailure() << "Expected: " << expr << " succeeds.\n"
-                                       << "  Actual: " << e.error() << "\n";
-}
-
-template <class T, class E>
-::testing::AssertionResult StdxExpectedFailure(const char *expr,
-                                               const stdx::expected<T, E> &e) {
-  if (!e) return ::testing::AssertionSuccess();
-
-  if constexpr (std::is_void_v<T>) {
-    return ::testing::AssertionFailure() << "Expected: " << expr << " fails.\n"
-                                         << "  Actual: succeeded\n";
-  } else {
-    return ::testing::AssertionFailure()
-           << "Expected: " << expr << " fails.\n"
-           << "  Actual: " << ::testing::PrintToString(e.value()) << "\n";
-  }
-}
-
-#define EXPECT_NO_ERROR(x) EXPECT_PRED_FORMAT1(StdxExpectedSuccess, (x))
-#define ASSERT_NO_ERROR(x) ASSERT_PRED_FORMAT1(StdxExpectedSuccess, (x))
-
-#define EXPECT_ERROR(x) EXPECT_PRED_FORMAT1(StdxExpectedFailure, (x))
-#define ASSERT_ERROR(x) ASSERT_PRED_FORMAT1(StdxExpectedFailure, (x))
-
-#ifdef NET_TS_HAS_UNIX_SOCKET
+#ifndef _WIN32
 
 template <class T>
 class LocalProtocolTest : public ::testing::Test {
@@ -166,6 +135,7 @@ TYPED_TEST(LocalProtocolTest, endpoint_construct_abstract) {
   using protocol_type = TypeParam;
   using endpoint_type = typename protocol_type::endpoint;
 
+  // workaround dev-studio's broken ""s for string-literals
 #define S(x) std::string((x), sizeof(x) - 1)
   endpoint_type endpoint(S("\0/foo/bar"));
 
@@ -185,7 +155,7 @@ std::ostream &operator<<(std::ostream &os,
 }
 }  // namespace net
 
-TEST(NetTS_local, stream_socket_bind_accept_connect_named) {
+TEST(NetTS_local, stream_socket_bind_accept_connect) {
   TempDirectory tmpdir;
 
   std::string socket_path = tmpdir.file("stream-protocol.test.socket");
@@ -195,265 +165,62 @@ TEST(NetTS_local, stream_socket_bind_accept_connect_named) {
   local::stream_protocol::endpoint endp(socket_path);
 
   local::stream_protocol::acceptor acceptor(io_ctx);
-  auto open_res = acceptor.open(endp.protocol());
-  if (!open_res) {
-    auto ec = open_res.error();
-    // macos may not support socketpair() with SEQPACKET
-    // windows may not support socketpair() at all
-    ASSERT_THAT(
-        ec, ::testing::AnyOf(
-                make_error_condition(std::errc::protocol_not_supported),
-                make_error_condition(std::errc::address_family_not_supported),
-                std::error_code(10044,
-                                std::system_category())  // WSAESOCKTNOSUPPORT
-                ));
-    GTEST_SKIP() << ec;
-  }
-
-  ASSERT_NO_ERROR(acceptor.bind(endp));
-  EXPECT_NO_ERROR(acceptor.listen(128));
+  EXPECT_THAT(acceptor.open(endp.protocol()),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
+  ASSERT_THAT(acceptor.bind(endp),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
+  EXPECT_THAT(acceptor.listen(128),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   //
-  EXPECT_NO_ERROR(acceptor.native_non_blocking(true));
+  EXPECT_THAT(acceptor.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   // should fail with EWOULDBLOCK
-  EXPECT_EQ(acceptor.accept(), stdx::make_unexpected(make_error_condition(
-                                   std::errc::operation_would_block)));
+  EXPECT_EQ(
+      acceptor.accept(),
+      stdx::make_unexpected(make_error_code(std::errc::operation_would_block)));
   auto local_endp_res = acceptor.local_endpoint();
 
-  ASSERT_NO_ERROR(local_endp_res);
+  ASSERT_TRUE(local_endp_res);
 
   auto local_endp = std::move(*local_endp_res);
 
   local::stream_protocol::socket client_sock(io_ctx);
-  EXPECT_NO_ERROR(client_sock.open(local_endp.protocol()));
-
-  EXPECT_NO_ERROR(client_sock.native_non_blocking(true));
-
-  auto connect_res = client_sock.connect(local_endp);
-  if (!connect_res) {
-    ASSERT_EQ(connect_res.error(),
-              make_error_condition(std::errc::operation_would_block));
-  }
-
-  auto server_sock_res = acceptor.accept();
-  ASSERT_NO_ERROR(server_sock_res);
-  auto server_sock = std::move(*server_sock_res);
-
-  ASSERT_TRUE(server_sock.is_open());
-
-  if (!connect_res) {
-    // finish the non-blocking connect
-    net::socket_base::error so_error;
-    ASSERT_NO_ERROR(client_sock.get_option(so_error));
-    ASSERT_EQ(so_error.value(), 0);
-  }
-
-  std::array<char, 5> source{{0x01, 0x02, 0x03, 0x04, 0x05}};
-  std::array<char, 16> sink;
-  EXPECT_EQ(net::read(client_sock, net::buffer(sink)),
-            stdx::make_unexpected(
-                make_error_condition(std::errc::operation_would_block)));
-
-  auto write_res = net::write(server_sock, net::buffer(source));
-  ASSERT_NO_ERROR(write_res) << write_res.error();
-  EXPECT_EQ(*write_res, source.size());
-
-  auto read_res = net::read(client_sock, net::buffer(sink),
-                            net::transfer_at_least(source.size()));
-  ASSERT_NO_ERROR(read_res);
-  EXPECT_EQ(*read_res, source.size());
-
-  EXPECT_TRUE(server_sock.shutdown(net::socket_base::shutdown_send));
-  EXPECT_TRUE(client_sock.shutdown(net::socket_base::shutdown_send));
-}
-
-TEST(NetTS_local, stream_socket_bind_accept_connect_abstract) {
-  net::io_context io_ctx;
-
-#define S(x) std::string((x), sizeof(x) - 1)
-  local::stream_protocol::endpoint endp(S("\0foo"));
-#undef S
-
-  local::stream_protocol::acceptor acceptor(io_ctx);
-  auto open_res = acceptor.open(endp.protocol());
-  if (!open_res) {
-    auto ec = open_res.error();
-    // macos may not support socketpair() with SEQPACKET
-    // windows may not support socketpair() at all
-    ASSERT_THAT(
-        ec, ::testing::AnyOf(
-                make_error_condition(std::errc::protocol_not_supported),
-                make_error_condition(std::errc::address_family_not_supported),
-                std::error_code(10044,
-                                std::system_category())  // WSAESOCKTNOSUPPORT
-                ));
-    GTEST_SKIP() << ec;
-  }
-
-  auto bind_res = acceptor.bind(endp);
-  if (!bind_res) {
-    auto ec = bind_res.error();
-    // macos doesn't support abstract paths and will return ENOENT.
-    ASSERT_THAT(ec, ::testing::AnyOf(make_error_condition(
-                        std::errc::no_such_file_or_directory)));
-    GTEST_SKIP() << ec;
-  }
-  EXPECT_NO_ERROR(acceptor.listen(128));
-
-  //
-  EXPECT_NO_ERROR(acceptor.native_non_blocking(true));
-
-  // should fail with EWOULDBLOCK
-  EXPECT_EQ(acceptor.accept(), stdx::make_unexpected(make_error_condition(
-                                   std::errc::operation_would_block)));
-
-  const auto local_endp_res = acceptor.local_endpoint();
-  ASSERT_NO_ERROR(local_endp_res);
-
-  const auto local_endp = std::move(*local_endp_res);
-
-  local::stream_protocol::socket client_sock(io_ctx);
-  EXPECT_NO_ERROR(client_sock.open(local_endp.protocol()));
+  EXPECT_TRUE(client_sock.open(local_endp.protocol()));
 
   // ensure the connect() doesn't block
-  EXPECT_NO_ERROR(client_sock.native_non_blocking(true));
-
-  const auto connect_res = client_sock.connect(local_endp);
-  if (!connect_res) {
-    const auto ec = connect_res.error();
-
-    if (ec == make_error_condition(std::errc::invalid_argument)) {
-      // windows doesn't support autobind and returns WSAEINVAL
-      GTEST_SKIP() << ec;
-    }
-
-    ASSERT_EQ(ec, make_error_condition(std::errc::operation_would_block));
-  }
-
-  auto server_sock_res = acceptor.accept();
-  ASSERT_NO_ERROR(server_sock_res);
-  auto server_sock = std::move(*server_sock_res);
-
-  ASSERT_TRUE(server_sock.is_open());
-
-  if (!connect_res) {
-    // finish the non-blocking connect
-    net::socket_base::error so_error;
-    ASSERT_NO_ERROR(client_sock.get_option(so_error));
-    ASSERT_EQ(so_error.value(), 0);
-  }
-
-  std::array<char, 5> source{{0x01, 0x02, 0x03, 0x04, 0x05}};
-  std::array<char, 16> sink;
-  EXPECT_EQ(net::read(client_sock, net::buffer(sink)),
-            stdx::make_unexpected(
-                make_error_condition(std::errc::operation_would_block)));
-
-  auto write_res = net::write(server_sock, net::buffer(source));
-  ASSERT_NO_ERROR(write_res) << write_res.error();
-  EXPECT_EQ(*write_res, source.size());
-
-  auto read_res = net::read(client_sock, net::buffer(sink),
-                            net::transfer_at_least(source.size()));
-  ASSERT_NO_ERROR(read_res);
-  EXPECT_EQ(*read_res, source.size());
-
-  EXPECT_TRUE(server_sock.shutdown(net::socket_base::shutdown_send));
-  EXPECT_TRUE(client_sock.shutdown(net::socket_base::shutdown_send));
-}
+  EXPECT_THAT(client_sock.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
-TEST(NetTS_local, stream_socket_bind_accept_connect_autobind) {
-  net::io_context io_ctx;
-
-  local::stream_protocol::endpoint endp;
-
-  local::stream_protocol::acceptor acceptor(io_ctx);
-  auto open_res = acceptor.open(endp.protocol());
-  if (!open_res) {
-    auto ec = open_res.error();
-    // macos may not support socketpair() with SEQPACKET
-    // windows may not support socketpair() at all
-    ASSERT_THAT(
-        ec, ::testing::AnyOf(
-                make_error_condition(std::errc::protocol_not_supported),
-                make_error_condition(std::errc::address_family_not_supported),
-                std::error_code(10044,
-                                std::system_category())  // WSAESOCKTNOSUPPORT
-                ));
-    GTEST_SKIP() << ec;
-  }
-
-  auto bind_res = acceptor.bind(endp);
-  if (!bind_res) {
-    auto ec = bind_res.error();
-    // macos doesn't support autobind and will return EINVAL.
-    // solaris returns EISDIR
-    ASSERT_THAT(
-        ec, ::testing::AnyOf(make_error_condition(std::errc::invalid_argument),
-                             make_error_condition(std::errc::is_a_directory)));
-    GTEST_SKIP() << ec;
-  }
-  EXPECT_NO_ERROR(acceptor.listen(128));
-
-  //
-  EXPECT_NO_ERROR(acceptor.native_non_blocking(true));
-
-  // should fail with EWOULDBLOCK
-  EXPECT_EQ(acceptor.accept(), stdx::make_unexpected(make_error_condition(
-                                   std::errc::operation_would_block)));
-  auto local_endp_res = acceptor.local_endpoint();
-  ASSERT_NO_ERROR(local_endp_res);
-
-  auto local_endp = std::move(*local_endp_res);
-
-  // Linux does \0 + 5 bytes.
-  // Windows does 108x \0
-  EXPECT_GT(local_endp.path().size(), 1);
-
-  local::stream_protocol::socket client_sock(io_ctx);
-  EXPECT_NO_ERROR(client_sock.open(local_endp.protocol()));
-
-  EXPECT_NO_ERROR(client_sock.native_non_blocking(true));
-
-  auto connect_res = client_sock.connect(local_endp);
-  if (!connect_res) {
-    auto ec = connect_res.error();
-
-    if (ec == make_error_condition(std::errc::invalid_argument)) {
-      // windows doesn't support autobind and returns WSAEINVAL
-      GTEST_SKIP() << ec;
-    }
-
-    ASSERT_EQ(ec, make_error_condition(std::errc::operation_would_block));
-  }
+  // even though non-blocking, this is unix-domain-sockets
+  ASSERT_THAT(client_sock.connect(local_endp),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   auto server_sock_res = acceptor.accept();
-  ASSERT_NO_ERROR(server_sock_res);
+  ASSERT_TRUE(server_sock_res);
   auto server_sock = std::move(*server_sock_res);
 
   ASSERT_TRUE(server_sock.is_open());
 
-  if (!connect_res) {
-    // finish the non-blocking connect
-    net::socket_base::error so_error;
-    ASSERT_NO_ERROR(client_sock.get_option(so_error));
-    ASSERT_EQ(so_error.value(), 0);
-  }
+  // finish the non-blocking connect
+  net::socket_base::error so_error;
+  ASSERT_TRUE(client_sock.get_option(so_error));
+  ASSERT_EQ(so_error.value(), 0);
 
   std::array<char, 5> source{{0x01, 0x02, 0x03, 0x04, 0x05}};
   std::array<char, 16> sink;
-  EXPECT_EQ(net::read(client_sock, net::buffer(sink)),
-            stdx::make_unexpected(
-                make_error_condition(std::errc::operation_would_block)));
+  EXPECT_EQ(
+      net::read(client_sock, net::buffer(sink)),
+      stdx::make_unexpected(make_error_code(std::errc::operation_would_block)));
 
   auto write_res = net::write(server_sock, net::buffer(source));
-  ASSERT_NO_ERROR(write_res) << write_res.error();
+  ASSERT_TRUE(write_res) << write_res.error();
   EXPECT_EQ(*write_res, source.size());
 
   auto read_res = net::read(client_sock, net::buffer(sink),
                             net::transfer_at_least(source.size()));
-  ASSERT_NO_ERROR(read_res);
+  ASSERT_TRUE(read_res);
   EXPECT_EQ(*read_res, source.size());
 
   EXPECT_TRUE(server_sock.shutdown(net::socket_base::shutdown_send));
@@ -469,35 +236,31 @@ TEST(NetTS_local, datagram_socket_bind_sendmsg_recvmsg) {
   std::string client_socket_path = tmpdir.file("datagram-test.client.socket");
 
   local::datagram_protocol::socket server_sock(io_ctx);
-  auto open_res = server_sock.open();
-  if (!open_res) {
-    auto ec = open_res.error();
-    // macos may not support socketpair() with SEQPACKET
-    // windows may not support socketpair() at all
-    ASSERT_THAT(
-        ec, ::testing::AnyOf(
-                make_error_condition(std::errc::protocol_not_supported),
-                make_error_condition(std::errc::address_family_not_supported)));
-    GTEST_SKIP() << ec;
-  }
+  EXPECT_THAT(server_sock.open(),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   local::datagram_protocol::endpoint server_endp(server_socket_path);
-  ASSERT_NO_ERROR(server_sock.bind(server_endp));
-  EXPECT_NO_ERROR(server_sock.native_non_blocking(true));
+  ASSERT_THAT(server_sock.bind(server_endp),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
+  EXPECT_THAT(server_sock.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   local::datagram_protocol::socket client_sock(io_ctx);
   EXPECT_TRUE(client_sock.open());
 
   // ensure the connect() doesn't block
-  EXPECT_NO_ERROR(client_sock.native_non_blocking(true));
+  EXPECT_THAT(client_sock.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   // UDP over AF_UNIX requires explicit paths as with the abstract namespace
   // we get ENOTCONN on sendmsg()
   local::datagram_protocol::endpoint client_any_endp(client_socket_path);
-  ASSERT_NO_ERROR(client_sock.bind(client_any_endp));
+  ASSERT_THAT(client_sock.bind(client_any_endp),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   auto client_endp_res = client_sock.local_endpoint();
-  ASSERT_NO_ERROR(client_endp_res);
+  ASSERT_THAT(client_endp_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   auto client_endp = std::move(*client_endp_res);
 
@@ -511,12 +274,14 @@ TEST(NetTS_local, datagram_socket_bind_sendmsg_recvmsg) {
   SCOPED_TRACE("// send something");
   std::array<char, 5> source{{0x01, 0x02, 0x03, 0x04, 0x05}};
   auto write_res = server_sock.send_to(net::buffer(source), client_endp);
-  ASSERT_NO_ERROR(write_res);
+  ASSERT_THAT(write_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
   EXPECT_EQ(*write_res, source.size());
 
   SCOPED_TRACE("// and we should receive something");
   auto read_res = client_sock.receive_from(net::buffer(sink), recvfrom_endp);
-  ASSERT_NO_ERROR(read_res);
+  ASSERT_THAT(read_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
   EXPECT_EQ(*read_res, source.size());
 
   SCOPED_TRACE("// check the sender address matches");
@@ -534,22 +299,15 @@ TEST(NetTS_local, datagram_socketpair_recvfrom) {
   socket_type server_sock(io_ctx);
   socket_type client_sock(io_ctx);
 
-  auto open_res =
-      local::connect_pair<protocol_type>(&io_ctx, server_sock, client_sock);
-  if (!open_res) {
-    auto ec = open_res.error();
-    // macos may not support socketpair() with SEQPACKET
-    // windows may not support socketpair() at all
-    ASSERT_THAT(
-        ec, ::testing::AnyOf(
-                make_error_condition(std::errc::protocol_not_supported),
-                make_error_condition(std::errc::address_family_not_supported)));
-    GTEST_SKIP() << ec;
-  }
+  EXPECT_THAT(
+      local::connect_pair<protocol_type>(&io_ctx, server_sock, client_sock),
+      ::testing::Truly([](const auto &t) { return bool(t); }));
 
-  EXPECT_NO_ERROR(server_sock.native_non_blocking(true));
+  EXPECT_THAT(server_sock.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
-  EXPECT_NO_ERROR(client_sock.native_non_blocking(true));
+  EXPECT_THAT(client_sock.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   SCOPED_TRACE("// up to now, there is no data");
   std::array<char, 16> sink;
@@ -561,12 +319,14 @@ TEST(NetTS_local, datagram_socketpair_recvfrom) {
   SCOPED_TRACE("// send something");
   std::array<char, 5> source{{0x01, 0x02, 0x03, 0x04, 0x05}};
   auto write_res = server_sock.send(net::buffer(source));
-  ASSERT_NO_ERROR(write_res);
+  ASSERT_THAT(write_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
   EXPECT_EQ(*write_res, source.size());
 
   SCOPED_TRACE("// and we should receive something");
   auto read_res = client_sock.receive_from(net::buffer(sink), recvfrom_endp);
-  ASSERT_NO_ERROR(read_res);
+  ASSERT_THAT(read_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
   EXPECT_EQ(*read_res, source.size());
 
   // linux: unnamed socket, .size() == 2 (just the AF_UNIX)
@@ -589,41 +349,38 @@ TYPED_TEST(LocalProtocolTest, socketpair) {
   auto connect_res =
       local::connect_pair<protocol_type>(&io_ctx, server_sock, client_sock);
 
-  if (!connect_res) {
-    auto ec = connect_res.error();
-    // macos may not support socketpair() with SEQPACKET
-    // windows may not support socketpair() at all
-    ASSERT_THAT(
-        ec, ::testing::AnyOf(
-                make_error_condition(std::errc::protocol_not_supported),
-                make_error_condition(std::errc::address_family_not_supported),
-                std::error_code(10044,
-                                std::system_category())  // WSAESOCKTNOSUPPORT
-                ));
-    GTEST_SKIP() << ec;
-  }
+  // macosx may not support socketpair() with SEQPACKET
+  if (!connect_res &&
+      connect_res.error() ==
+          make_error_condition(std::errc::protocol_not_supported))
+    return;
 
-  ASSERT_NO_ERROR(connect_res);
+  ASSERT_THAT(connect_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
-  EXPECT_NO_ERROR(server_sock.native_non_blocking(true));
+  EXPECT_THAT(server_sock.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
-  EXPECT_NO_ERROR(client_sock.native_non_blocking(true));
+  EXPECT_THAT(client_sock.native_non_blocking(true),
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   SCOPED_TRACE("// up to now, there is no data");
   std::array<char, 16> sink;
-  EXPECT_EQ(client_sock.receive(net::buffer(sink)),
-            stdx::make_unexpected(
-                make_error_condition(std::errc::operation_would_block)));
+  EXPECT_EQ(
+      client_sock.receive(net::buffer(sink)),
+      stdx::make_unexpected(make_error_code(std::errc::operation_would_block)));
 
   SCOPED_TRACE("// send something");
   std::array<char, 5> source{{0x01, 0x02, 0x03, 0x04, 0x05}};
   auto write_res = server_sock.send(net::buffer(source));
-  ASSERT_NO_ERROR(write_res);
+  ASSERT_THAT(write_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
   EXPECT_EQ(*write_res, source.size());
 
   SCOPED_TRACE("// and we should receive something");
   auto read_res = client_sock.receive(net::buffer(sink));
-  ASSERT_NO_ERROR(read_res);
+  ASSERT_THAT(read_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
   EXPECT_EQ(*read_res, source.size());
 }
 
@@ -650,13 +407,15 @@ TYPED_TEST(LocalTwoWayProtocolTest, twoway_peercreds) {
           make_error_condition(std::errc::protocol_not_supported))
     return;
 
-  ASSERT_NO_ERROR(connect_res);
+  ASSERT_THAT(connect_res,
+              ::testing::Truly([](const auto &t) { return bool(t); }));
 
   SCOPED_TRACE("// get creds of the remote side of the socket");
   typename protocol_type::peer_creds peer_creds;
 
   try {
-    ASSERT_NO_ERROR(client_sock.get_option(peer_creds));
+    ASSERT_THAT(client_sock.get_option(peer_creds),
+                ::testing::Truly([](const auto &t) { return bool(t); }));
   } catch (const std::exception &e) {
     // resize() currently throws on macsox and freebsd
     FAIL() << e.what();
-- 
2.37.2

