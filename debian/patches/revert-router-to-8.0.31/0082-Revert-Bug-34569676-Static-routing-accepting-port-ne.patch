From 88db6e48612e6085250fc3cae516d1f65879135e Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:22:07 -0500
Subject: [PATCH 82/86] Revert "Bug#34569676 Static routing accepting port
 never reopened when port busy after quarantine."

This reverts commit 045524bf38f9cef1d4874facb57be7c78621931e.
---
 .../include/mysqlrouter/routing_component.h   |  1 -
 router/src/routing/src/mysql_routing.cc       | 22 ----------
 router/src/routing/src/mysql_routing.h        | 13 ------
 router/src/routing/src/mysql_routing_base.h   |  2 -
 ...routing_common_unreachable_destinations.cc |  2 +-
 router/src/routing/src/routing_component.cc   |  4 --
 router/tests/component/test_socket_close.cc   | 43 +++++++++++++++----
 7 files changed, 35 insertions(+), 52 deletions(-)

diff --git a/router/src/routing/include/mysqlrouter/routing_component.h b/router/src/routing/include/mysqlrouter/routing_component.h
index 49dfa8eef03..cd4f8e950af 100644
--- a/router/src/routing/include/mysqlrouter/routing_component.h
+++ b/router/src/routing/include/mysqlrouter/routing_component.h
@@ -93,7 +93,6 @@ class ROUTING_EXPORT MySQLRoutingAPI {
   std::vector<mysql_harness::TCPAddress> get_destinations() const;
 
   void start_accepting_connections();
-  void restart_accepting_connections();
 
   bool is_accepting_connections() const;
 
diff --git a/router/src/routing/src/mysql_routing.cc b/router/src/routing/src/mysql_routing.cc
index dadaeb4c5d5..bee396352a2 100644
--- a/router/src/routing/src/mysql_routing.cc
+++ b/router/src/routing/src/mysql_routing.cc
@@ -673,28 +673,6 @@ stdx::expected<void, std::error_code> MySQLRouting::start_acceptor(
   return {};
 }
 
-stdx::expected<void, std::error_code>
-MySQLRouting::restart_accepting_connections() {
-  const auto result = start_accepting_connections();
-
-  // if we failed to restart the acceptor we keep retrying every 1 second if we
-  // have standalone destination. For the metadata-cache destinations there is
-  // another mechanism for that,` that uses metadata TTL as a trigger for that.
-  if (is_destination_standalone_ && !result) {
-    accept_port_reopen_retry_timer_.cancel();
-    accept_port_reopen_retry_timer_.expires_after(1s);
-    accept_port_reopen_retry_timer_.async_wait(
-        [this](const std::error_code &ec) {
-          if (ec && ec == std::errc::operation_canceled) {
-            return;
-          }
-          restart_accepting_connections();
-        });
-  }
-
-  return result;
-}
-
 stdx::expected<void, std::error_code>
 MySQLRouting::start_accepting_connections() {
   if (!is_running()) {
diff --git a/router/src/routing/src/mysql_routing.h b/router/src/routing/src/mysql_routing.h
index a957ceb4f0c..ba5de0a5234 100644
--- a/router/src/routing/src/mysql_routing.h
+++ b/router/src/routing/src/mysql_routing.h
@@ -268,15 +268,6 @@ class ROUTING_EXPORT MySQLRouting : public MySQLRoutingBase {
    */
   stdx::expected<void, std::error_code> start_accepting_connections() override;
 
-  /**
-   * Start accepting new connections on a listening socket after it has been
-   * quarantined for lack of valid destinations
-   *
-   * @returns std::error_code on errors.
-   */
-  stdx::expected<void, std::error_code> restart_accepting_connections()
-      override;
-
  private:
   /**
    * Get listening socket detail information used for the logging purposes.
@@ -362,10 +353,6 @@ class ROUTING_EXPORT MySQLRouting : public MySQLRoutingBase {
   /** Information if the routing plugging is still running. */
   std::atomic<bool> is_running_{true};
 
-  /** Used when the accepting port is been reopened and it failed, to schedule
-   * another retry for standalone-destination(s) route. */
-  net::steady_timer accept_port_reopen_retry_timer_{io_ctx_};
-
 #ifdef FRIEND_TEST
   FRIEND_TEST(RoutingTests, bug_24841281);
   FRIEND_TEST(RoutingTests, get_routing_thread_name);
diff --git a/router/src/routing/src/mysql_routing_base.h b/router/src/routing/src/mysql_routing_base.h
index 8db2c53790b..60f50e49999 100644
--- a/router/src/routing/src/mysql_routing_base.h
+++ b/router/src/routing/src/mysql_routing_base.h
@@ -49,8 +49,6 @@ class ROUTING_EXPORT MySQLRoutingBase {
   virtual routing::RoutingStrategy get_routing_strategy() const = 0;
   virtual routing::AccessMode get_mode() const = 0;
   virtual stdx::expected<void, std::error_code>
-  restart_accepting_connections() = 0;
-  virtual stdx::expected<void, std::error_code>
   start_accepting_connections() = 0;
   virtual void stop_socket_acceptors() = 0;
 
diff --git a/router/src/routing/src/routing_common_unreachable_destinations.cc b/router/src/routing/src/routing_common_unreachable_destinations.cc
index 50c4db782d9..e8703a082fe 100644
--- a/router/src/routing/src/routing_common_unreachable_destinations.cc
+++ b/router/src/routing/src/routing_common_unreachable_destinations.cc
@@ -108,7 +108,7 @@ void RoutingCommonUnreachableDestinations::
   for (const auto &instance_name : routing_instances) {
     auto routing_instance = component.api(instance_name);
 
-    routing_instance.restart_accepting_connections();
+    routing_instance.start_accepting_connections();
   }
 
   quarantined_destination_candidates_.erase(pos);
diff --git a/router/src/routing/src/routing_component.cc b/router/src/routing/src/routing_component.cc
index 9cd047ded66..09854ae7986 100644
--- a/router/src/routing/src/routing_component.cc
+++ b/router/src/routing/src/routing_component.cc
@@ -123,10 +123,6 @@ void MySQLRoutingAPI::start_accepting_connections() {
   r_->start_accepting_connections();
 }
 
-void MySQLRoutingAPI::restart_accepting_connections() {
-  r_->restart_accepting_connections();
-}
-
 void MySQLRoutingAPI::stop_socket_acceptors() { r_->stop_socket_acceptors(); }
 
 bool MySQLRoutingAPI::is_running() const { return r_->is_running(); }
diff --git a/router/tests/component/test_socket_close.cc b/router/tests/component/test_socket_close.cc
index a3724a1c8fd..335a53ca8b3 100644
--- a/router/tests/component/test_socket_close.cc
+++ b/router/tests/component/test_socket_close.cc
@@ -749,9 +749,13 @@ class SocketUser final {
 const uint16_t SocketUser::error_code;
 const char SocketUser::error_msg[] = "You shall not pass";
 
-TEST_F(SocketCloseTest, StaticRoundRobin) {
+class FailToOpenSocketStaticRoundRobin
+    : public SocketCloseTest,
+      public ::testing::WithParamInterface<SocketsCloseTestParams> {};
+
+TEST_P(FailToOpenSocketStaticRoundRobin, StaticRoundRobin) {
   SCOPED_TRACE("// launch cluster with one node");
-  setup_cluster(1, "my_port.js");
+  setup_cluster(1, GetParam().tracefile);
 
   const auto router_rw_port_str = std::to_string(router_rw_port);
 
@@ -788,7 +792,8 @@ TEST_F(SocketCloseTest, StaticRoundRobin) {
                std::to_string(node_ports[0]) +
                " to bring the destination back from "
                "quarantine.");
-  const std::string json_metadata = get_data_dir().join("my_port.js").str();
+  const std::string json_metadata =
+      get_data_dir().join(GetParam().tracefile).str();
   cluster_nodes.push_back(&launch_mysql_server_mock(
       json_metadata, node_ports[0], EXIT_SUCCESS, false, node_http_ports[0]));
 
@@ -806,11 +811,6 @@ TEST_F(SocketCloseTest, StaticRoundRobin) {
     EXPECT_THAT(e.what(), ::testing::HasSubstr(SocketUser::error_msg));
   }
 
-  // sleep for a while to test that when the quarantine wants to reopen the
-  // acceptor port and it fails it will still be retried later when the port
-  // become available
-  std::this_thread::sleep_for(1.5s);
-
   SCOPED_TRACE("// Release the tcp-port:" + router_rw_port_str +
                ", and wait a bit to set router bind to the port again");
   socket_user.unlock();
@@ -825,6 +825,17 @@ TEST_F(SocketCloseTest, StaticRoundRobin) {
   }
 }
 
+INSTANTIATE_TEST_SUITE_P(
+    FailToOpenSocketStaticRoundRobinTest, FailToOpenSocketStaticRoundRobin,
+    ::testing::Values(
+        SocketsCloseTestParams("metadata_dynamic_nodes_v2_gr.js",
+                               "static_round_robin_fail_to_open_socket_gr_v2",
+                               ClusterType::GR_V2),
+        SocketsCloseTestParams("metadata_dynamic_nodes_v2_ar.js",
+                               "static_round_robin_fail_to_open_socket_ar_v2",
+                               ClusterType::RS_V2)),
+    get_test_description);
+
 enum class PortType { RW, RO, X_RW, X_RO };
 
 struct FailToOpenSocketParams {
@@ -1237,7 +1248,11 @@ INSTANTIATE_TEST_SUITE_P(
                                              ClusterType::RS_V2)),
     get_test_description);
 
-TEST_F(SocketCloseTest, StaticRoutingToNonExistentNodesTest) {
+class StaticRoutingToNonExistentNodes
+    : public SocketCloseTest,
+      public ::testing::WithParamInterface<SocketsCloseTestParams> {};
+
+TEST_P(StaticRoutingToNonExistentNodes, StaticRoutingToNonExistentNodesTest) {
   const auto port1 = port_pool_.get_next_available();
   const auto port2 = port_pool_.get_next_available();
   const auto port3 = port_pool_.get_next_available();
@@ -1279,6 +1294,16 @@ TEST_F(SocketCloseTest, StaticRoutingToNonExistentNodesTest) {
   EXPECT_TRUE(wait_for_port_unused(port3, 120s));
 }
 
+INSTANTIATE_TEST_SUITE_P(
+    StaticRoutingToNonExistentNodesTest, StaticRoutingToNonExistentNodes,
+    ::testing::Values(SocketsCloseTestParams("metadata_dynamic_nodes_v2_gr.js",
+                                             "non_existent_nodes_gr_v2",
+                                             ClusterType::GR_V2),
+                      SocketsCloseTestParams("metadata_dynamic_nodes_v2_ar.js",
+                                             "non_existent_nodes_ar_v2",
+                                             ClusterType::RS_V2)),
+    get_test_description);
+
 struct SharedQuarantineSocketCloseParam {
   std::string strategy;
   bool is_socket_closed;
-- 
2.37.2

