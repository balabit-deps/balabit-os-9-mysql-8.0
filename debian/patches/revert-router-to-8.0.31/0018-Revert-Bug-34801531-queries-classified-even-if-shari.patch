From a8f10fa863fe205b6df80eb0993b7739cc73e7be Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:03:49 -0500
Subject: [PATCH 18/86] Revert "Bug#34801531 queries classified even if sharing
 is not possible"

This reverts commit 598fd3e985925fc673d1cb19046fc27c089b7726.
---
 router/src/routing/src/classic_query.cc | 164 ++++++++++++------------
 1 file changed, 81 insertions(+), 83 deletions(-)

diff --git a/router/src/routing/src/classic_query.cc b/router/src/routing/src/classic_query.cc
index 72e5fffbf38..fedcb0a5c1f 100644
--- a/router/src/routing/src/classic_query.cc
+++ b/router/src/routing/src/classic_query.cc
@@ -803,98 +803,96 @@ stdx::expected<Processor::Result, std::error_code> QueryForwarder::command() {
   auto src_channel = socket_splicer->client_channel();
   auto src_protocol = connection()->client_protocol();
 
-  if (connection()->connection_sharing_possible()) {
-    auto msg_res =
-        ClassicFrame::recv_msg<classic_protocol::message::client::Query>(
-            src_channel, src_protocol);
-    if (!msg_res) return recv_client_failed(msg_res.error());
-
-    trace(Tracer::Event().stage("query::command: " +
-                                msg_res->statement().substr(0, 1024)));
-
-    if (connection()->connection_sharing_allowed()) {
-      // the diagnostics-area is only maintained, if connection-sharing is
-      // allowed.
-      //
-      // Otherwise, all queries for the to the diagnostics area MUST go to the
-      // server.
-      auto intercept_res =
-          intercept_diagnostics_area_queries(msg_res->statement());
-      if (intercept_res) {
-        if (std::holds_alternative<std::monostate>(*intercept_res)) {
-          // no match
-        } else if (std::holds_alternative<ShowWarnings>(*intercept_res)) {
-          discard_current_msg(src_channel, src_protocol);
-
-          auto cmd = std::get<ShowWarnings>(*intercept_res);
-
-          auto send_res = show_warnings(connection(), cmd.only_errors(),
-                                        cmd.row_count(), cmd.offset());
-          if (!send_res) return send_client_failed(send_res.error());
-
-          stage(Stage::Done);
-          return Result::SendToClient;
-        } else if (std::holds_alternative<ShowWarningCount>(*intercept_res)) {
-          discard_current_msg(src_channel, src_protocol);
-
-          auto cmd = std::get<ShowWarningCount>(*intercept_res);
-
-          auto send_res =
-              show_warning_count(connection(), cmd.only_errors(), cmd.scope());
-          if (!send_res) return send_client_failed(send_res.error());
-
-          stage(Stage::Done);
-          return Result::SendToClient;
-        }
+  auto msg_res =
+      ClassicFrame::recv_msg<classic_protocol::message::client::Query>(
+          src_channel, src_protocol);
+  if (!msg_res) return recv_client_failed(msg_res.error());
+
+  trace(Tracer::Event().stage("query::command: " +
+                              msg_res->statement().substr(0, 1024)));
+
+  if (connection()->connection_sharing_allowed()) {
+    // the diagnostics-area is only maintained, if connection-sharing is
+    // allowed.
+    //
+    // Otherwise, all queries for the to the diagnostics area MUST go to the
+    // server.
+    auto intercept_res =
+        intercept_diagnostics_area_queries(msg_res->statement());
+    if (intercept_res) {
+      if (std::holds_alternative<std::monostate>(*intercept_res)) {
+        // no match
+      } else if (std::holds_alternative<ShowWarnings>(*intercept_res)) {
+        discard_current_msg(src_channel, src_protocol);
+
+        auto cmd = std::get<ShowWarnings>(*intercept_res);
+
+        auto send_res = show_warnings(connection(), cmd.only_errors(),
+                                      cmd.row_count(), cmd.offset());
+        if (!send_res) return send_client_failed(send_res.error());
+
+        stage(Stage::Done);
+        return Result::SendToClient;
+      } else if (std::holds_alternative<ShowWarningCount>(*intercept_res)) {
+        discard_current_msg(src_channel, src_protocol);
+
+        auto cmd = std::get<ShowWarningCount>(*intercept_res);
+
+        auto send_res =
+            show_warning_count(connection(), cmd.only_errors(), cmd.scope());
+        if (!send_res) return send_client_failed(send_res.error());
+
+        stage(Stage::Done);
+        return Result::SendToClient;
       }
     }
+  }
+
+  stmt_classified_ = classify(msg_res->statement(), true);
 
-    stmt_classified_ = classify(msg_res->statement(), true);
+  trace(Tracer::Event().stage("query::classified: " +
+                              mysqlrouter::to_string(stmt_classified_)));
 
-    trace(Tracer::Event().stage("query::classified: " +
-                                mysqlrouter::to_string(stmt_classified_)));
+  // SET session_track... is forbidden if router sets session-trackers on the
+  // server-side.
+  if ((stmt_classified_ & StmtClassifier::ForbiddenSetWithConnSharing) &&
+      connection()->connection_sharing_possible()) {
+    discard_current_msg(src_channel, src_protocol);
 
-    // SET session_track... is forbidden if router sets session-trackers on the
-    // server-side.
-    if ((stmt_classified_ & StmtClassifier::ForbiddenSetWithConnSharing) &&
-        connection()->connection_sharing_possible()) {
-      discard_current_msg(src_channel, src_protocol);
+    trace(Tracer::Event().stage("query::forbidden"));
 
-      trace(Tracer::Event().stage("query::forbidden"));
+    auto send_res =
+        ClassicFrame::send_msg<classic_protocol::message::server::Error>(
+            src_channel, src_protocol,
+            {ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION,
+             "The system variable cannot be set when connection sharing is "
+             "enabled",
+             "HY000"});
+    if (!send_res) return send_client_failed(send_res.error());
 
-      auto send_res =
-          ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-              src_channel, src_protocol,
-              {ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION,
-               "The system variable cannot be set when connection sharing is "
-               "enabled",
-               "HY000"});
-      if (!send_res) return send_client_failed(send_res.error());
+    stage(Stage::Done);
+    return Result::SendToClient;
+  }
 
-      stage(Stage::Done);
-      return Result::SendToClient;
-    }
+  // functions are forbidden if the connection can be shared
+  // (e.g. config allows sharing and outside a transaction)
+  if ((stmt_classified_ & StmtClassifier::ForbiddenFunctionWithConnSharing) &&
+      connection()->connection_sharing_allowed()) {
+    discard_current_msg(src_channel, src_protocol);
 
-    // functions are forbidden if the connection can be shared
-    // (e.g. config allows sharing and outside a transaction)
-    if ((stmt_classified_ & StmtClassifier::ForbiddenFunctionWithConnSharing) &&
-        connection()->connection_sharing_allowed()) {
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("query::forbidden"));
-
-      auto send_res = ClassicFrame::send_msg<
-          classic_protocol::message::server::Error>(
-          src_channel, src_protocol,
-          {ER_NO_ACCESS_TO_NATIVE_FCT,
-           "Access to native function is rejected when connection sharing is "
-           "enabled",
-           "HY000"});
-      if (!send_res) return send_client_failed(send_res.error());
-
-      stage(Stage::Done);
-      return Result::SendToClient;
-    }
+    trace(Tracer::Event().stage("query::forbidden"));
+
+    auto send_res =
+        ClassicFrame::send_msg<classic_protocol::message::server::Error>(
+            src_channel, src_protocol,
+            {ER_NO_ACCESS_TO_NATIVE_FCT,
+             "Access to native function is rejected when connection sharing is "
+             "enabled",
+             "HY000"});
+    if (!send_res) return send_client_failed(send_res.error());
+
+    stage(Stage::Done);
+    return Result::SendToClient;
   }
 
   auto &server_conn = connection()->socket_splicer()->server_conn();
-- 
2.37.2

