From 4f13d7d14aaf4b21fd01a1394115e163d1861c74 Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:08:12 -0500
Subject: [PATCH 44/86] Revert "Bug#34633883 unify authentication between
 greeting and change_user"

This reverts commit 46feeb3356df0980dab1e1e99bc8d2cb2536b0a5.
---
 router/src/routing/src/CMakeLists.txt         |   5 -
 router/src/routing/src/classic_auth.cc        | 151 ++-
 router/src/routing/src/classic_auth.h         |  82 +-
 .../routing/src/classic_auth_caching_sha2.cc  | 774 ----------------
 .../routing/src/classic_auth_caching_sha2.h   | 175 ----
 .../src/routing/src/classic_auth_cleartext.cc | 269 ------
 .../src/routing/src/classic_auth_cleartext.h  | 124 ---
 .../src/routing/src/classic_auth_forwarder.cc | 442 ---------
 .../src/routing/src/classic_auth_forwarder.h  |  74 --
 router/src/routing/src/classic_auth_native.cc | 253 -----
 router/src/routing/src/classic_auth_native.h  | 125 ---
 .../src/classic_auth_sha256_password.cc       | 576 ------------
 .../src/classic_auth_sha256_password.h        | 160 ----
 router/src/routing/src/classic_change_user.cc | 482 +++++++++-
 router/src/routing/src/classic_change_user.h  |  14 +-
 router/src/routing/src/classic_greeting.cc    | 869 +++++++++++++++++-
 router/src/routing/src/classic_greeting.h     |  24 +-
 17 files changed, 1526 insertions(+), 3073 deletions(-)
 delete mode 100644 router/src/routing/src/classic_auth_caching_sha2.cc
 delete mode 100644 router/src/routing/src/classic_auth_caching_sha2.h
 delete mode 100644 router/src/routing/src/classic_auth_cleartext.cc
 delete mode 100644 router/src/routing/src/classic_auth_cleartext.h
 delete mode 100644 router/src/routing/src/classic_auth_forwarder.cc
 delete mode 100644 router/src/routing/src/classic_auth_forwarder.h
 delete mode 100644 router/src/routing/src/classic_auth_native.cc
 delete mode 100644 router/src/routing/src/classic_auth_native.h
 delete mode 100644 router/src/routing/src/classic_auth_sha256_password.cc
 delete mode 100644 router/src/routing/src/classic_auth_sha256_password.h

diff --git a/router/src/routing/src/CMakeLists.txt b/router/src/routing/src/CMakeLists.txt
index 708ad7d6ef7..61e68694341 100644
--- a/router/src/routing/src/CMakeLists.txt
+++ b/router/src/routing/src/CMakeLists.txt
@@ -56,11 +56,6 @@ ADD_LIBRARY(routing SHARED
 
   processor.cc
   classic_auth.cc
-  classic_auth_cleartext.cc
-  classic_auth_caching_sha2.cc
-  classic_auth_forwarder.cc
-  classic_auth_native.cc
-  classic_auth_sha256_password.cc
   classic_binlog_dump.cc
   classic_change_user.cc
   classic_clone.cc
diff --git a/router/src/routing/src/classic_auth.cc b/router/src/routing/src/classic_auth.cc
index 22657d3f37e..33d3dc195d9 100644
--- a/router/src/routing/src/classic_auth.cc
+++ b/router/src/routing/src/classic_auth.cc
@@ -33,22 +33,11 @@
 #include <openssl/x509.h>
 
 #include "auth_digest.h"
+#include "classic_frame.h"
 #include "mysql/harness/stdx/expected.h"
+#include "mysqlrouter/classic_protocol_wire.h"
 #include "openssl_version.h"
 
-/**
- * remove trailing \0 in a string_view.
- *
- * returns the original string-view, if there is no trailing NUL-char.
- */
-std::string_view AuthBase::strip_trailing_null(std::string_view s) {
-  if (s.empty()) return s;
-
-  if (s.back() == '\0') s.remove_suffix(1);
-
-  return s;
-}
-
 template <>
 struct OsslDeleter<BIO> {
   void operator()(BIO *b) { BIO_free_all(b); }
@@ -289,16 +278,132 @@ stdx::expected<std::string, std::error_code> AuthBase::rsa_encrypt_password(
   return AuthBase::public_key_encrypt(plaintext, pkey.get());
 }
 
-bool AuthBase::connection_has_public_key(
-    MysqlRoutingClassicConnection *connection) {
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
-  if (!connection->context().source_ssl_ctx()) return false;
+//  AuthCleartextPassword
 
-  SSL_CTX *ssl_ctx = connection->context().source_ssl_ctx()->get();
+std::optional<std::string> AuthCleartextPassword::scramble(
+    [[maybe_unused]] std::string_view nonce, std::string_view pwd) {
+  std::string s(pwd);
 
-  return SSL_CTX_get0_certificate(ssl_ctx) != nullptr;
-#else
-  (void)connection;
-  return false;
-#endif
+  s.push_back('\0');
+
+  return s;
+}
+
+// AuthNativePassword
+
+std::optional<std::string> AuthNativePassword::scramble(std::string_view nonce,
+                                                        std::string_view pwd) {
+  return mysql_native_password_scramble<std::string>(nonce, pwd);
+}
+
+// AuthCachingSha2Password
+
+std::optional<std::string> AuthCachingSha2Password::scramble(
+    std::string_view nonce, std::string_view pwd) {
+  return caching_sha2_password_scramble<std::string>(nonce, pwd);
+}
+
+stdx::expected<size_t, std::error_code>
+AuthCachingSha2Password::send_public_key_request(
+    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {std::string(kPublicKeyRequest)});
+}
+
+stdx::expected<size_t, std::error_code>
+AuthCachingSha2Password::send_public_key(Channel *dst_channel,
+                                         ClassicProtocolState *dst_protocol,
+                                         const std::string &public_key) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {public_key});
+}
+
+stdx::expected<size_t, std::error_code>
+AuthCachingSha2Password::send_plaintext_password_request(
+    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::server::AuthMethodData>(
+      dst_channel, dst_protocol, {std::string(1, kPerformFullAuth)});
+}
+
+stdx::expected<size_t, std::error_code>
+AuthCachingSha2Password::send_plaintext_password(
+    Channel *dst_channel, ClassicProtocolState *dst_protocol,
+    const std::string &password) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {password + '\0'});
+}
+
+stdx::expected<size_t, std::error_code>
+AuthCachingSha2Password::send_encrypted_password(
+    Channel *dst_channel, ClassicProtocolState *dst_protocol,
+    const std::string &encrypted) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {encrypted});
+}
+
+bool AuthCachingSha2Password::is_public_key_request(
+    const std::string_view &data) {
+  return data == kPublicKeyRequest;
+}
+
+bool AuthCachingSha2Password::is_public_key(const std::string_view &data) {
+  return data.size() == 256;
+}
+
+// AuthSha256Password
+
+std::optional<std::string> AuthSha256Password::scramble(
+    [[maybe_unused]] std::string_view nonce, std::string_view pwd) {
+  std::string s(pwd);
+
+  s.push_back('\0');
+
+  return s;
+}
+
+stdx::expected<size_t, std::error_code>
+AuthSha256Password::send_public_key_request(
+    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {std::string(kPublicKeyRequest)});
+}
+
+stdx::expected<size_t, std::error_code> AuthSha256Password::send_public_key(
+    Channel *dst_channel, ClassicProtocolState *dst_protocol,
+    const std::string &public_key) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {public_key});
+}
+
+stdx::expected<size_t, std::error_code>
+AuthSha256Password::send_plaintext_password(Channel *dst_channel,
+                                            ClassicProtocolState *dst_protocol,
+                                            const std::string &password) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {password + '\0'});
+}
+
+stdx::expected<size_t, std::error_code>
+AuthSha256Password::send_encrypted_password(Channel *dst_channel,
+                                            ClassicProtocolState *dst_protocol,
+                                            const std::string &encrypted) {
+  return ClassicFrame::send_msg<
+      classic_protocol::message::client::AuthMethodData>(
+      dst_channel, dst_protocol, {encrypted});
+}
+
+bool AuthSha256Password::is_public_key_request(const std::string_view &data) {
+  return data == kPublicKeyRequest;
+}
+
+bool AuthSha256Password::is_public_key(const std::string_view &data) {
+  return data.size() == 256;
 }
diff --git a/router/src/routing/src/classic_auth.h b/router/src/routing/src/classic_auth.h
index dd0977b76ff..55c19de8bc5 100644
--- a/router/src/routing/src/classic_auth.h
+++ b/router/src/routing/src/classic_auth.h
@@ -63,11 +63,87 @@ class AuthBase {
 
   static stdx::expected<std::string, std::error_code> rsa_encrypt_password(
       const EvpPkey &pkey, std::string_view password, std::string_view nonce);
+};
+
+class AuthNativePassword {
+ public:
+  static constexpr const std::string_view kName{"mysql_native_password"};
+
+  static std::optional<std::string> scramble(std::string_view nonce,
+                                             std::string_view pwd);
+};
+
+class AuthCleartextPassword {
+ public:
+  static constexpr const std::string_view kName{"mysql_clear_password"};
+
+  static std::optional<std::string> scramble(std::string_view nonce,
+                                             std::string_view pwd);
+};
+
+// low-level routings for caching_sha2_password
+class AuthCachingSha2Password : public AuthBase {
+ public:
+  static constexpr const std::string_view kName{"caching_sha2_password"};
+
+  static constexpr const std::string_view kPublicKeyRequest{"\x02"};
+  static constexpr const uint8_t kFastAuthDone{0x03};
+  static constexpr const uint8_t kPerformFullAuth{0x04};
+
+  static std::optional<std::string> scramble(std::string_view nonce,
+                                             std::string_view pwd);
+
+  static stdx::expected<size_t, std::error_code> send_public_key_request(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol);
+
+  static stdx::expected<size_t, std::error_code> send_public_key(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol,
+      const std::string &public_key);
+
+  static stdx::expected<size_t, std::error_code>
+  send_plaintext_password_request(Channel *dst_channel,
+                                  ClassicProtocolState *dst_protocol);
+
+  static stdx::expected<size_t, std::error_code> send_plaintext_password(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol,
+      const std::string &password);
+
+  static stdx::expected<size_t, std::error_code> send_encrypted_password(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol,
+      const std::string &password);
+
+  static bool is_public_key_request(const std::string_view &data);
+  static bool is_public_key(const std::string_view &data);
+};
+
+// low-level routings for sha256_password
+class AuthSha256Password : public AuthBase {
+ public:
+  static constexpr const std::string_view kName{"sha256_password"};
+
+  static constexpr const std::string_view kEmptyPassword{"\x00", 1};
+  static constexpr const std::string_view kPublicKeyRequest{"\x01"};
+
+  static std::optional<std::string> scramble(std::string_view nonce,
+                                             std::string_view pwd);
+
+  static stdx::expected<size_t, std::error_code> send_public_key_request(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol);
+
+  static stdx::expected<size_t, std::error_code> send_public_key(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol,
+      const std::string &public_key);
+
+  static stdx::expected<size_t, std::error_code> send_plaintext_password(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol,
+      const std::string &password);
 
-  static std::string_view strip_trailing_null(std::string_view s);
+  static stdx::expected<size_t, std::error_code> send_encrypted_password(
+      Channel *dst_channel, ClassicProtocolState *dst_protocol,
+      const std::string &password);
 
-  static bool connection_has_public_key(
-      MysqlRoutingClassicConnection *connection);
+  static bool is_public_key_request(const std::string_view &data);
+  static bool is_public_key(const std::string_view &data);
 };
 
 #endif
diff --git a/router/src/routing/src/classic_auth_caching_sha2.cc b/router/src/routing/src/classic_auth_caching_sha2.cc
deleted file mode 100644
index 5c597966cba..00000000000
--- a/router/src/routing/src/classic_auth_caching_sha2.cc
+++ /dev/null
@@ -1,774 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_auth_caching_sha2.h"
-
-#include "auth_digest.h"
-#include "classic_frame.h"
-#include "harness_assert.h"
-#include "hexify.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysqld_error.h"  // mysql-server error-codes
-#include "mysqlrouter/classic_protocol_wire.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-using mysql_harness::hexify;
-
-// AuthCachingSha2Password
-
-std::optional<std::string> AuthCachingSha2Password::scramble(
-    std::string_view nonce, std::string_view pwd) {
-  return caching_sha2_password_scramble<std::string>(nonce, pwd);
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_public_key_request(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {std::string(kPublicKeyRequest)});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_public_key(Channel *dst_channel,
-                                         ClassicProtocolState *dst_protocol,
-                                         const std::string &public_key) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {public_key});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_plaintext_password_request(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::server::AuthMethodData>(
-      dst_channel, dst_protocol, {std::string(1, kPerformFullAuth)});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_plaintext_password(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    const std::string &password) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {password + '\0'});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_encrypted_password(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    const std::string &encrypted) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {encrypted});
-}
-
-bool AuthCachingSha2Password::is_public_key_request(
-    const std::string_view &data) {
-  return data == kPublicKeyRequest;
-}
-
-bool AuthCachingSha2Password::is_public_key(const std::string_view &data) {
-  return data.size() == 256;
-}
-
-// sender
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Sender::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::Response:
-      return response();
-    case Stage::PublicKey:
-      return public_key();
-    case Stage::AuthData:
-      return auth_data();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Sender::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  auto scramble_res = Auth::scramble(
-      AuthBase::strip_trailing_null(initial_server_auth_data_), password_);
-  if (!scramble_res) {
-    return send_server_failed(make_error_code(std::errc::invalid_argument));
-  }
-
-  auto send_res =
-      ClassicFrame::send_msg<classic_protocol::message::client::AuthMethodData>(
-          dst_channel, dst_protocol, {*scramble_res});
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Sender::send_password() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  if (dst_channel->ssl()) {
-    trace(Tracer::Event().stage("caching_sha2::sender::plaintext_password"));
-    auto send_res = ClassicFrame::send_msg<
-        classic_protocol::message::client::AuthMethodData>(
-        dst_channel, dst_protocol, {password_ + '\0'});
-    if (!send_res) return send_server_failed(send_res.error());
-
-    stage(Stage::Response);
-  } else {
-    trace(Tracer::Event().stage("caching_sha2::sender::public_key_request"));
-
-    auto send_res = Auth::send_public_key_request(dst_channel, dst_protocol);
-    if (!send_res) return send_server_failed(send_res.error());
-
-    stage(Stage::PublicKey);
-  }
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Sender::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    AuthData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthData:
-      stage(Stage::AuthData);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in caching-sha2-auth:\n%s",
-            hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Sender::public_key() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          dst_channel, dst_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  discard_current_msg(dst_channel, dst_protocol);
-
-  auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-  if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-  auto encrypted_res = Auth::rsa_encrypt_password(*pubkey_res, password_,
-                                                  initial_server_auth_data_);
-  if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-  auto send_res =
-      Auth::send_encrypted_password(dst_channel, dst_protocol, *encrypted_res);
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Sender::auth_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          dst_channel, dst_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  if (msg_res->auth_method_data() == std::string_view("\x04")) {
-    trace(Tracer::Event().stage("caching_sha2::sender::request_full_auth"));
-
-    discard_current_msg(dst_channel, dst_protocol);
-
-    return send_password();
-  } else if (msg_res->auth_method_data() == std::string_view("\x03")) {
-    trace(Tracer::Event().stage("caching_sha2::sender::fast_auth_ok"));
-
-    // as the client did the slow path, it doesn't expect a fast-auth-ok.
-    discard_current_msg(dst_channel, dst_protocol);
-
-    // next should be an Ok
-    stage(Stage::Response);
-
-    return Result::Again;
-  } else {
-    return recv_server_failed(make_error_code(std::errc::bad_message));
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthCachingSha2Sender::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("caching_sha2::sender::ok"));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Sender::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("caching_sha2::sender::error"));
-
-  return Result::Again;
-}
-
-// Forwarder
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::ClientData:
-      return client_data();
-    case Stage::EncryptedPassword:
-      return encrypted_password();
-    case Stage::PlaintextPassword:
-      return plaintext_password();
-    case Stage::Response:
-      return response();
-    case Stage::PublicKeyResponse:
-      return public_key_response();
-    case Stage::PublicKey:
-      return public_key();
-    case Stage::AuthData:
-      return auth_data();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  trace(Tracer::Event().stage("caching_sha2::forward::switch"));
-
-  auto send_res = ClassicFrame::send_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(
-      dst_channel, dst_protocol,
-      {std::string(Auth::kName), initial_server_auth_data_});
-  if (!send_res) return send_client_failed(send_res.error());
-
-  stage(Stage::ClientData);
-  return Result::SendToClient;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::client_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  if (Auth::is_public_key_request(msg_res->auth_method_data())) {
-    trace(Tracer::Event().stage("caching_sha2::forward::public_key_request"));
-
-    if (AuthBase::connection_has_public_key(connection())) {
-      // send the router's public-key to be able to decrypt the client's
-      // password.
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("caching_sha2::forward::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) {
-        auto ec = pubkey_res.error();
-
-        if (ec != std::errc::function_not_supported) {
-          return send_client_failed(ec);
-        }
-
-        stage(Stage::Done);
-
-        // couldn't get the public key, fail the auth.
-        auto send_res =
-            ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-                src_channel, src_protocol,
-                {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
-        if (!send_res) return send_client_failed(send_res.error());
-      } else {
-        // send the router's public key to the client.
-        stage(Stage::EncryptedPassword);
-
-        auto send_res =
-            Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-        if (!send_res) return send_client_failed(send_res.error());
-      }
-
-      return Result::SendToClient;
-    } else {
-      // client requested a public key, but router has no ssl-ctx
-      // (client-ssl-mode is DISABLED|PASSTHROUGH)
-      //
-      // If the server-connection is encrypted, the server will treat the
-      // public-key-request as an invalid password
-      // (as it isn't terminated by \0)
-      stage(Stage::PublicKeyResponse);
-
-      return forward_client_to_server();
-    }
-  } else {
-    trace(Tracer::Event().stage("caching_sha2::forward::scrambled_password"));
-
-    // if it isn't a public-key request, it is a fast-auth.
-    stage(Stage::Response);
-
-    return forward_client_to_server();
-  }
-}
-
-// encrypted password from client to server.
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::encrypted_password() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("caching_sha2::forward::encrypted"));
-
-  if (AuthBase::connection_has_public_key(connection())) {
-    auto recv_res = Auth::rsa_decrypt_password(
-        connection()->context().source_ssl_ctx()->get(),
-        msg_res->auth_method_data(), initial_server_auth_data_);
-    if (!recv_res) return recv_client_failed(recv_res.error());
-
-    src_protocol->password(*recv_res);
-
-    discard_current_msg(src_channel, src_protocol);
-
-    return send_password();
-  } else {
-    trace(Tracer::Event().stage("caching_sha2::forward::encrypted"));
-
-    stage(Stage::Response);
-
-    return forward_client_to_server();
-  }
-}
-
-// plaintext password from client to server.
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::plaintext_password() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  if (src_channel->ssl()) {
-    trace(Tracer::Event().stage("caching_sha2::forward::plaintext_password"));
-
-    // remove trailing null
-    src_protocol->password(std::string(
-        AuthBase::strip_trailing_null(msg_res->auth_method_data())));
-
-    discard_current_msg(src_channel, src_protocol);
-
-    return send_password();
-  } else if (Auth::is_public_key_request(msg_res->auth_method_data())) {
-    trace(Tracer::Event().stage("caching_sha2::forward::public_key_request"));
-
-    if (AuthBase::connection_has_public_key(connection())) {
-      // send the router's public-key to be able to decrypt the client's
-      // password.
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("caching_sha2::forward::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) {
-        auto ec = pubkey_res.error();
-
-        if (ec != std::errc::function_not_supported) {
-          return send_client_failed(ec);
-        }
-
-        stage(Stage::Done);
-
-        // couldn't get the public key, fail the auth.
-        auto send_res =
-            ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-                src_channel, src_protocol,
-                {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
-        if (!send_res) return send_client_failed(send_res.error());
-      } else {
-        // send the router's public key to the client.
-        stage(Stage::EncryptedPassword);
-
-        auto send_res =
-            Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-        if (!send_res) return send_client_failed(send_res.error());
-      }
-
-      return Result::SendToClient;
-    } else {
-      // client requested a public key, but router has no ssl-ctx
-      // (client-ssl-mode is DISABLED|PASSTHROUGH)
-      //
-      // If the server-connection is encrypted, the server will treat the
-      // public-key-request as an invalid password
-      // (as it isn't terminated by \0)
-      stage(Stage::PublicKeyResponse);
-
-      return forward_client_to_server();
-    }
-  } else {
-    discard_current_msg(src_channel, src_protocol);
-
-    trace(Tracer::Event().stage("caching_sha2::forward::bad_message"));
-
-    return recv_client_failed(make_error_code(std::errc::bad_message));
-  }
-}
-
-// encrypted password from client to server.
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::send_password() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_protocol = connection()->client_protocol();
-
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  if (dst_channel->ssl()) {
-    // the server-side is encrypted: send plaintext password
-    trace(Tracer::Event().stage("caching_sha2::forward::plaintext_password"));
-
-    stage(Stage::Response);
-
-    auto send_res = Auth::send_plaintext_password(
-        dst_channel, dst_protocol, src_protocol->password().value());
-    if (!send_res) return send_server_failed(send_res.error());
-  } else {
-    // the server is NOT encrypted: ask for the server's publickey
-    trace(Tracer::Event().stage("caching_sha2::forward::public_key_request"));
-
-    stage(Stage::PublicKeyResponse);
-
-    auto send_res = Auth::send_public_key_request(dst_channel, dst_protocol);
-    if (!send_res) return send_server_failed(send_res.error());
-  }
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    AuthData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthData:
-      stage(Stage::AuthData);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in caching-sha2-auth:\n%s",
-            hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::public_key_response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    AuthData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthData:
-      stage(Stage::PublicKey);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("caching_sha2::forward::public_key_response"));
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug(
-      "received unexpected message from server in sha256-password-auth:\n%s",
-      hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-// receive a public-key from the server.
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::public_key() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          dst_channel, dst_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("caching_sha2::forward::public-key"));
-
-  if (!src_protocol->password().has_value()) {
-    // the client's password isn't known.
-    //
-    // Forward the server's public-key to the client
-    stage(Stage::EncryptedPassword);
-
-    return forward_server_to_client();
-  }
-
-  // as the plaintext password is known, encrypt it with the server's
-  // public-key.
-  auto pubkey_res = Auth::public_key_from_pem(msg_res->auth_method_data());
-  if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-  discard_current_msg(dst_channel, dst_protocol);
-
-  auto password = *src_protocol->password();
-
-  auto encrypted_res = Auth::rsa_encrypt_password(*pubkey_res, password,
-                                                  initial_server_auth_data_);
-  if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-  auto send_res =
-      Auth::send_encrypted_password(dst_channel, dst_protocol, *encrypted_res);
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::auth_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          dst_channel, dst_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  if (msg_res->auth_method_data() == std::string_view("\x04")) {
-    trace(Tracer::Event().stage("caching_sha2::forward::request_full_auth"));
-
-    if (src_protocol->password().has_value()) {
-      discard_current_msg(dst_channel, dst_protocol);
-
-      return send_password();
-    } else {
-      stage(Stage::PlaintextPassword);
-
-      return forward_server_to_client();
-    }
-  } else if (msg_res->auth_method_data() == std::string_view("\x03")) {
-    trace(Tracer::Event().stage("caching_sha2::forward::fast_auth_ok"));
-
-    // next is a Ok packet.
-    stage(Stage::Response);
-
-    if (in_handshake_) {
-      // 0x03 means the client-greeting provided the right scrambled
-      // password that matches the cached entry.
-
-      // as there is a password provided by the client already
-      // the client side expects either server::Ok or server::Error now.
-      //
-      // c<-r: server::greeting (from router)
-      // c->r: client::greeting (with tls handshake)
-      // c<-r: 0x01 0x04
-      // c->r: password
-      //    r->s: connect()
-      //    r<-s: server::greeting
-      //    r->s: client::greeting (with tls handshake, rehashed pwd)
-      //    r<-s: 0x01 0x03   // current message
-      //    r<-s: server::Ok
-      // c<-r: server::Ok
-      discard_current_msg(dst_channel, dst_protocol);
-
-      // skip this message.
-      return Result::Again;
-    } else {
-      return forward_server_to_client(true);
-    }
-  } else {
-    trace(Tracer::Event().stage("caching_sha2::forward::??\n" +
-                                hexify(msg_res->auth_method_data())));
-    stage(Stage::Response);
-
-    return forward_server_to_client();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("caching_sha2::forward::ok"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCachingSha2Forwarder::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("caching_sha2::forward::error"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_auth_caching_sha2.h b/router/src/routing/src/classic_auth_caching_sha2.h
deleted file mode 100644
index 4b2433fd726..00000000000
--- a/router/src/routing/src/classic_auth_caching_sha2.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_AUTH_CACHING_SHA2_INCLUDED
-#define ROUTING_CLASSIC_AUTH_CACHING_SHA2_INCLUDED
-
-#include <memory>  // unique_ptr
-#include <string_view>
-#include <system_error>
-
-#include <openssl/ssl.h>
-
-#include "classic_auth.h"
-#include "classic_connection.h"
-#include "mysql/harness/stdx/expected.h"
-
-// low-level routings for caching_sha2_password
-class AuthCachingSha2Password : public AuthBase {
- public:
-  static constexpr const std::string_view kName{"caching_sha2_password"};
-
-  static constexpr const std::string_view kPublicKeyRequest{"\x02"};
-  static constexpr const uint8_t kFastAuthDone{0x03};
-  static constexpr const uint8_t kPerformFullAuth{0x04};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-
-  static stdx::expected<size_t, std::error_code> send_public_key_request(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol);
-
-  static stdx::expected<size_t, std::error_code> send_public_key(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &public_key);
-
-  static stdx::expected<size_t, std::error_code>
-  send_plaintext_password_request(Channel *dst_channel,
-                                  ClassicProtocolState *dst_protocol);
-
-  static stdx::expected<size_t, std::error_code> send_plaintext_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static stdx::expected<size_t, std::error_code> send_encrypted_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static bool is_public_key_request(const std::string_view &data);
-  static bool is_public_key(const std::string_view &data);
-};
-
-class AuthCachingSha2Sender : public Processor {
- public:
-  AuthCachingSha2Sender(MysqlRoutingClassicConnection *conn,
-                        std::string initial_server_auth_data,
-                        std::string password)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        password_{std::move(password)} {}
-
-  enum class Stage {
-    Init,
-
-    PublicKey,
-
-    Response,
-
-    AuthData,
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  using Auth = AuthCachingSha2Password;
-
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> public_key();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> auth_data();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  stdx::expected<Result, std::error_code> send_password();
-
-  Stage stage_{Stage::Init};
-
-  std::string initial_server_auth_data_;
-  std::string password_;
-};
-
-class AuthCachingSha2Forwarder : public Processor {
- public:
-  AuthCachingSha2Forwarder(MysqlRoutingClassicConnection *conn,
-                           std::string initial_server_auth_data,
-                           bool in_handshake = false)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        in_handshake_{in_handshake},
-        stage_{in_handshake ? Stage::Response : Stage::Init} {}
-
-  enum class Stage {
-    Init,
-
-    ClientData,
-    EncryptedPassword,
-    PlaintextPassword,
-
-    PublicKeyResponse,
-    PublicKey,
-    AuthData,
-
-    Response,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  using Auth = AuthCachingSha2Password;
-
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> client_data();
-  stdx::expected<Result, std::error_code> encrypted_password();
-  stdx::expected<Result, std::error_code> plaintext_password();
-  stdx::expected<Result, std::error_code> auth_data();
-  stdx::expected<Result, std::error_code> public_key_response();
-  stdx::expected<Result, std::error_code> public_key();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  stdx::expected<Result, std::error_code> send_password();
-
-  std::string initial_server_auth_data_;
-
-  bool in_handshake_;
-  Stage stage_;
-};
-
-#endif
diff --git a/router/src/routing/src/classic_auth_cleartext.cc b/router/src/routing/src/classic_auth_cleartext.cc
deleted file mode 100644
index 8c8cec09942..00000000000
--- a/router/src/routing/src/classic_auth_cleartext.cc
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_auth_cleartext.h"
-
-#include <array>
-#include <memory>  // unique_ptr
-#include <system_error>
-
-#include <openssl/evp.h>
-#include <openssl/ssl.h>
-#include <openssl/x509.h>
-
-#include "auth_digest.h"
-#include "classic_frame.h"
-#include "harness_assert.h"
-#include "hexify.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysqld_error.h"  // mysql-server error-codes
-#include "mysqlrouter/classic_protocol_wire.h"
-#include "openssl_version.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-using mysql_harness::hexify;
-
-//  AuthCleartextPassword
-
-std::optional<std::string> AuthCleartextPassword::scramble(
-    [[maybe_unused]] std::string_view nonce, std::string_view pwd) {
-  std::string s(pwd);
-
-  s.push_back('\0');
-
-  return s;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextSender::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::Response:
-      return response();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthCleartextSender::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  auto send_res =
-      ClassicFrame::send_msg<classic_protocol::message::client::AuthMethodData>(
-          dst_channel, dst_protocol, {password_});
-  if (!send_res) return send_server_failed(send_res.error());
-
-  trace(Tracer::Event().stage("cleartext::sender::password"));
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextSender::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in cleartext-auth:\n%s",
-            hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthCleartextSender::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("cleartext::sender::ok"));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextSender::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("cleartext::sender::error"));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextForwarder::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::ClientData:
-      return client_data();
-    case Stage::Response:
-      return response();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextForwarder::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  trace(Tracer::Event().stage("cleartext::forward::switch"));
-
-  auto send_res = ClassicFrame::send_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(
-      dst_channel, dst_protocol,
-      {std::string(Auth::kName), initial_server_auth_data_});
-  if (!send_res) return send_client_failed(send_res.error());
-
-  stage(Stage::ClientData);
-
-  return Result::SendToClient;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextForwarder::client_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("cleartext::forward::plaintext_password"));
-
-  stage(Stage::Response);
-
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextForwarder::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("cleartext::forward::response"));
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in cleartext-auth:\n%s",
-            hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextForwarder::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("cleartext::forward::ok"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthCleartextForwarder::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("cleartext::forward::error"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_auth_cleartext.h b/router/src/routing/src/classic_auth_cleartext.h
deleted file mode 100644
index 947fb84c5bf..00000000000
--- a/router/src/routing/src/classic_auth_cleartext.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_AUTH_CLEARTEXT_INCLUDED
-#define ROUTING_CLASSIC_AUTH_CLEARTEXT_INCLUDED
-
-#include <memory>  // unique_ptr
-#include <optional>
-#include <string_view>
-#include <system_error>
-
-#include <openssl/ssl.h>
-
-#include "classic_auth.h"
-#include "classic_connection.h"
-#include "mysql/harness/stdx/expected.h"
-
-class AuthCleartextPassword {
- public:
-  static constexpr const std::string_view kName{"mysql_clear_password"};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-};
-
-class AuthCleartextSender : public Processor {
- public:
-  AuthCleartextSender(MysqlRoutingClassicConnection *conn,
-                      std::string initial_server_auth_data,
-                      std::string password)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        password_{std::move(password)} {}
-
-  enum class Stage {
-    Init,
-
-    Response,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  Stage stage_{Stage::Init};
-
-  std::string initial_server_auth_data_;
-  std::string password_;
-};
-
-class AuthCleartextForwarder : public Processor {
- public:
-  AuthCleartextForwarder(MysqlRoutingClassicConnection *conn,
-                         std::string initial_server_auth_data,
-                         bool in_handshake = false)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        stage_{in_handshake ? Stage::Response : Stage::Init} {}
-
-  enum class Stage {
-    Init,
-
-    ClientData,
-    Response,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  using Auth = AuthCleartextPassword;
-
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> client_data();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  std::string initial_server_auth_data_;
-
-  Stage stage_{Stage::Init};
-};
-
-#endif
diff --git a/router/src/routing/src/classic_auth_forwarder.cc b/router/src/routing/src/classic_auth_forwarder.cc
deleted file mode 100644
index 53a29075672..00000000000
--- a/router/src/routing/src/classic_auth_forwarder.cc
+++ /dev/null
@@ -1,442 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_auth_forwarder.h"
-
-#include <memory>  // unique_ptr
-#include <system_error>
-
-#include <openssl/evp.h>
-#include <openssl/ssl.h>
-#include <openssl/x509.h>
-
-#include "auth_digest.h"
-#include "classic_auth_caching_sha2.h"
-#include "classic_auth_cleartext.h"
-#include "classic_auth_native.h"
-#include "classic_auth_sha256_password.h"
-#include "classic_frame.h"
-#include "harness_assert.h"
-#include "hexify.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysqld_error.h"  // mysql-server error-codes
-#include "mysqlrouter/classic_protocol_wire.h"
-#include "openssl_version.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-using mysql_harness::hexify;
-
-class AuthGenericForwarder : public Processor {
- public:
-  AuthGenericForwarder(MysqlRoutingClassicConnection *conn,
-                       std::string auth_method_name,
-                       std::string initial_server_auth_data,
-                       bool in_handshake = false)
-      : Processor(conn),
-        auth_method_name_{std::move(auth_method_name)},
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        stage_{in_handshake ? Stage::Response : Stage::Init} {}
-
-  enum class Stage {
-    Init,
-
-    ClientData,
-    AuthData,
-
-    Response,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> client_data();
-  stdx::expected<Result, std::error_code> auth_data();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  stdx::expected<Result, std::error_code> send_password();
-
-  std::string auth_method_name_;
-  std::string initial_server_auth_data_;
-  std::string password_;
-
-  Stage stage_;
-};
-
-stdx::expected<Processor::Result, std::error_code>
-AuthGenericForwarder::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::ClientData:
-      return client_data();
-    case Stage::Response:
-      return response();
-    case Stage::AuthData:
-      return auth_data();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthGenericForwarder::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  trace(Tracer::Event().stage("generic::forward::switch: " + auth_method_name_ +
-                              "\n" + hexify(initial_server_auth_data_)));
-
-  auto send_res = ClassicFrame::send_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(
-      dst_channel, dst_protocol,
-      {auth_method_name_, initial_server_auth_data_});
-  if (!send_res) return send_client_failed(send_res.error());
-
-  stage(Stage::ClientData);
-  return Result::SendToClient;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthGenericForwarder::client_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage(
-      "generic::forward::client:\n" +
-      mysql_harness::hexify(msg_res->auth_method_data())));
-
-  // if it isn't a public-key request, it is a fast-auth.
-  stage(Stage::Response);
-
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthGenericForwarder::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    AuthData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthData:
-      stage(Stage::AuthData);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in %s:\n%s",
-            auth_method_name_.c_str(), hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthGenericForwarder::auth_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          dst_channel, dst_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("generic::forward::data\n" +
-                              hexify(msg_res->auth_method_data())));
-  stage(Stage::ClientData);
-
-  return forward_server_to_client();
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthGenericForwarder::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("generic::forward::ok"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthGenericForwarder::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("generic::forward::error"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthForwarder::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::AuthMethodSwitch:
-      return auth_method_switch();
-    case Stage::Response:
-      return response();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthForwarder::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-  auto *dst_protocol = connection()->client_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  if (msg_type == ClassicFrame::cmd_byte<
-                      classic_protocol::message::server::AuthMethodSwitch>()) {
-    stage(Stage::AuthMethodSwitch);
-    return Result::Again;
-  }
-
-  auto auth_method_name = dst_protocol->auth_method_name();
-  auto initial_auth_method_data = src_protocol->auth_method_data();
-
-  // handle the pre-auth-plugin capabilities.
-  if (auth_method_name.empty()) {
-    auth_method_name =
-        src_protocol->shared_capabilities().test(
-            classic_protocol::capabilities::pos::secure_connection)
-            ? AuthNativePassword::kName
-            : "old_password";
-  }
-
-  trace(Tracer::Event().stage("auth::forwarder::direct: " + auth_method_name));
-
-  if (auth_method_name == AuthSha256Password::kName) {
-    connection()->push_processor(std::make_unique<AuthSha256Forwarder>(
-        connection(), initial_auth_method_data, true));
-  } else if (auth_method_name == AuthCachingSha2Password::kName) {
-    connection()->push_processor(std::make_unique<AuthCachingSha2Forwarder>(
-        connection(), initial_auth_method_data, true));
-  } else if (auth_method_name == AuthNativePassword::kName) {
-    connection()->push_processor(std::make_unique<AuthNativeForwarder>(
-        connection(), initial_auth_method_data, true));
-  } else if (auth_method_name == AuthCleartextPassword::kName) {
-    connection()->push_processor(std::make_unique<AuthCleartextForwarder>(
-        connection(), initial_auth_method_data, true));
-  } else {
-    connection()->push_processor(std::make_unique<AuthGenericForwarder>(
-        connection(), auth_method_name, initial_auth_method_data, true));
-  }
-
-  stage(Stage::Response);
-  return Result::Again;
-}
-
-// server wants to switch to another auth-method.
-stdx::expected<Processor::Result, std::error_code>
-AuthForwarder::auth_method_switch() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-  auto *dst_protocol = connection()->client_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(src_channel,
-                                                           src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  src_protocol->auth_method_name(msg.auth_method());
-  src_protocol->auth_method_data(msg.auth_method_data());
-  dst_protocol->auth_method_name(msg.auth_method());
-  dst_protocol->auth_method_data(msg.auth_method_data());
-
-  trace(Tracer::Event().stage("auth::forwarder::switch: " + msg.auth_method()));
-
-  discard_current_msg(src_channel, src_protocol);
-
-  if (msg.auth_method() == AuthSha256Password::kName) {
-    if (dst_protocol->password().has_value()) {
-      connection()->push_processor(std::make_unique<AuthSha256Sender>(
-          connection(), msg.auth_method_data(),
-          dst_protocol->password().value()));
-    } else {
-      connection()->push_processor(std::make_unique<AuthSha256Forwarder>(
-          connection(), msg.auth_method_data()));
-    }
-  } else if (msg.auth_method() == AuthCachingSha2Password::kName) {
-    if (dst_protocol->password().has_value()) {
-      connection()->push_processor(std::make_unique<AuthCachingSha2Sender>(
-          connection(), msg.auth_method_data(),
-          dst_protocol->password().value()));
-    } else {
-      connection()->push_processor(std::make_unique<AuthCachingSha2Forwarder>(
-          connection(), msg.auth_method_data()));
-    }
-  } else if (msg.auth_method() == AuthNativePassword::kName) {
-    if (dst_protocol->password().has_value()) {
-      connection()->push_processor(std::make_unique<AuthNativeSender>(
-          connection(), msg.auth_method_data(),
-          dst_protocol->password().value()));
-    } else {
-      connection()->push_processor(std::make_unique<AuthNativeForwarder>(
-          connection(), msg.auth_method_data()));
-    }
-  } else if (msg.auth_method() == AuthCleartextPassword::kName) {
-    if (dst_protocol->password().has_value()) {
-      connection()->push_processor(std::make_unique<AuthCleartextSender>(
-          connection(), msg.auth_method_data(),
-          dst_protocol->password().value()));
-    } else {
-      connection()->push_processor(std::make_unique<AuthCleartextForwarder>(
-          connection(), msg.auth_method_data()));
-    }
-  } else {
-    connection()->push_processor(std::make_unique<AuthGenericForwarder>(
-        connection(), msg.auth_method(), msg.auth_method_data()));
-  }
-
-  stage(Stage::Response);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthForwarder::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("auth::forwarder::response"));
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in auth:\n%s",
-            hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthForwarder::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("auth::forwarder::ok"));
-
-  // leave the message in the queue for the caller.
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthForwarder::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("auth::forwarder::error"));
-
-  // leave the message in the queue for the caller.
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_auth_forwarder.h b/router/src/routing/src/classic_auth_forwarder.h
deleted file mode 100644
index 4c9b6906977..00000000000
--- a/router/src/routing/src/classic_auth_forwarder.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_AUTH_FORWARDER_INCLUDED
-#define ROUTING_CLASSIC_AUTH_FORWARDER_INCLUDED
-
-#include <memory>  // unique_ptr
-#include <string_view>
-#include <system_error>
-
-#include <openssl/ssl.h>
-
-#include "classic_connection.h"
-#include "mysql/harness/stdx/expected.h"
-
-/**
- * forward authentication between a client and server.
- *
- * started from the server after AuthSwitch
- */
-class AuthForwarder : public Processor {
- public:
-  using Processor::Processor;
-
-  enum class Stage {
-    Init,
-
-    AuthMethodSwitch,
-
-    Response,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> auth_method_switch();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  Stage stage_{Stage::Init};
-};
-
-#endif
diff --git a/router/src/routing/src/classic_auth_native.cc b/router/src/routing/src/classic_auth_native.cc
deleted file mode 100644
index f2d177a7793..00000000000
--- a/router/src/routing/src/classic_auth_native.cc
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_auth_native.h"
-
-#include "auth_digest.h"
-#include "classic_auth.h"
-#include "classic_frame.h"
-#include "hexify.h"
-#include "mysql/harness/logging/logging.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-using mysql_harness::hexify;
-
-// AuthNativePassword
-
-std::optional<std::string> AuthNativePassword::scramble(std::string_view nonce,
-                                                        std::string_view pwd) {
-  return mysql_native_password_scramble<std::string>(nonce, pwd);
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthNativeSender::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::Response:
-      return response();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthNativeSender::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  auto scramble_res = Auth::scramble(
-      AuthBase::strip_trailing_null(initial_server_auth_data_), password_);
-  if (!scramble_res) {
-    return send_server_failed(make_error_code(std::errc::invalid_argument));
-  }
-
-  trace(Tracer::Event().stage("native::sender::scrambled_password"));
-
-  auto send_res =
-      ClassicFrame::send_msg<classic_protocol::message::client::AuthMethodData>(
-          dst_channel, dst_protocol, {*scramble_res});
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthNativeSender::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("native::sender::response"));
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in native-auth:\n%s",
-            hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthNativeSender::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("native::sender::ok"));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthNativeSender::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("native::sender::error"));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthNativeForwarder::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::ClientData:
-      return client_data();
-    case Stage::Response:
-      return response();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-// server switched to mysql_native_password
-stdx::expected<Processor::Result, std::error_code> AuthNativeForwarder::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  trace(Tracer::Event().stage("native::forward::switch"));
-
-  auto send_res = ClassicFrame::send_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(
-      dst_channel, dst_protocol,
-      {std::string(Auth::kName), initial_server_auth_data_});
-  if (!send_res) return send_client_failed(send_res.error());
-
-  stage(Stage::ClientData);
-  return Result::SendToClient;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthNativeForwarder::client_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto read_res = ClassicFrame::ensure_frame_header(src_channel, src_protocol);
-  if (!read_res) return recv_client_failed(read_res.error());
-
-  trace(Tracer::Event().stage("native::forward::scrambled_password"));
-
-  stage(Stage::Response);
-
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthNativeForwarder::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in native-auth:\n%s",
-            hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthNativeForwarder::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("native::forward::ok"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthNativeForwarder::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("native::forward::error"));
-
-  // leave the message in the queue for the AuthForwarder.
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_auth_native.h b/router/src/routing/src/classic_auth_native.h
deleted file mode 100644
index 0d72c7e2ac0..00000000000
--- a/router/src/routing/src/classic_auth_native.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_AUTH_NATIVE_INCLUDED
-#define ROUTING_CLASSIC_AUTH_NATIVE_INCLUDED
-
-#include <memory>  // unique_ptr
-#include <optional>
-#include <string_view>
-#include <system_error>
-
-#include <openssl/ssl.h>
-
-#include "classic_connection.h"
-#include "mysql/harness/stdx/expected.h"
-#include "processor.h"
-
-class AuthNativePassword {
- public:
-  static constexpr const std::string_view kName{"mysql_native_password"};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-};
-
-class AuthNativeSender : public Processor {
- public:
-  AuthNativeSender(MysqlRoutingClassicConnection *conn,
-                   std::string initial_server_auth_data, std::string password)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        password_{std::move(password)} {}
-
-  enum class Stage {
-    Init,
-
-    Response,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  using Auth = AuthNativePassword;
-
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  Stage stage_{Stage::Init};
-
-  std::string initial_server_auth_data_;
-  std::string password_;
-};
-
-class AuthNativeForwarder : public Processor {
- public:
-  AuthNativeForwarder(MysqlRoutingClassicConnection *conn,
-                      std::string initial_server_auth_data,
-                      bool in_handshake = false)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        stage_{in_handshake ? Stage::Response : Stage::Init} {}
-
-  enum class Stage {
-    Init,
-
-    ClientData,
-    Response,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  using Auth = AuthNativePassword;
-
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> client_data();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  std::string initial_server_auth_data_;
-
-  Stage stage_;
-};
-
-#endif
diff --git a/router/src/routing/src/classic_auth_sha256_password.cc b/router/src/routing/src/classic_auth_sha256_password.cc
deleted file mode 100644
index f9a54117479..00000000000
--- a/router/src/routing/src/classic_auth_sha256_password.cc
+++ /dev/null
@@ -1,576 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_auth_sha256_password.h"
-
-#include "auth_digest.h"
-#include "classic_frame.h"
-#include "hexify.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysqld_error.h"  // mysql-server error-codes
-
-IMPORT_LOG_FUNCTIONS()
-
-using mysql_harness::hexify;
-
-// AuthSha256Password
-
-std::optional<std::string> AuthSha256Password::scramble(
-    [[maybe_unused]] std::string_view nonce, std::string_view pwd) {
-  std::string s(pwd);
-
-  s.push_back('\0');
-
-  return s;
-}
-
-stdx::expected<size_t, std::error_code>
-AuthSha256Password::send_public_key_request(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {std::string(kPublicKeyRequest)});
-}
-
-stdx::expected<size_t, std::error_code> AuthSha256Password::send_public_key(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    const std::string &public_key) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {public_key});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthSha256Password::send_plaintext_password(Channel *dst_channel,
-                                            ClassicProtocolState *dst_protocol,
-                                            const std::string &password) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {password + '\0'});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthSha256Password::send_encrypted_password(Channel *dst_channel,
-                                            ClassicProtocolState *dst_protocol,
-                                            const std::string &encrypted) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {encrypted});
-}
-
-bool AuthSha256Password::is_public_key_request(const std::string_view &data) {
-  return data == kPublicKeyRequest;
-}
-
-bool AuthSha256Password::is_public_key(const std::string_view &data) {
-  return data.size() == 256;
-}
-
-// sender
-
-stdx::expected<Processor::Result, std::error_code> AuthSha256Sender::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::Response:
-      return response();
-    case Stage::PublicKey:
-      return public_key();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthSha256Sender::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  if (dst_channel->ssl() || password_.empty()) {
-    trace(Tracer::Event().stage("sha256_password::sender::plaintext_password"));
-
-    auto send_res = ClassicFrame::send_msg<
-        classic_protocol::message::client::AuthMethodData>(
-        dst_channel, dst_protocol, {password_ + '\0'});
-    if (!send_res) return send_server_failed(send_res.error());
-
-    stage(Stage::Response);
-  } else {
-    trace(Tracer::Event().stage("sha256_password::sender::public_key_request"));
-    auto send_res = Auth::send_public_key_request(dst_channel, dst_protocol);
-    if (!send_res) return send_server_failed(send_res.error());
-
-    stage(Stage::PublicKey);
-  }
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Sender::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug("received unexpected message from server in sha256-auth:\n%s",
-            mysql_harness::hexify(recv_buf).c_str());
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Sender::public_key() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          dst_channel, dst_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  discard_current_msg(dst_channel, dst_protocol);
-
-  auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-  if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-  auto encrypted_res = Auth::rsa_encrypt_password(*pubkey_res, password_,
-                                                  initial_server_auth_data_);
-  if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-  auto send_res =
-      Auth::send_encrypted_password(dst_channel, dst_protocol, *encrypted_res);
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthSha256Sender::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("sha256_password::sender::ok"));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthSha256Sender::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("sha256_password::sender::error"));
-
-  return Result::Again;
-}
-
-// forwarder
-
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::ClientData:
-      return client_data();
-    case Stage::EncryptedPassword:
-      return encrypted_password();
-    case Stage::Response:
-      return response();
-    case Stage::PublicKeyResponse:
-      return public_key_response();
-    case Stage::PublicKey:
-      return public_key();
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthSha256Forwarder::init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  trace(Tracer::Event().stage("sha256_password::forward::switch"));
-
-  auto send_res = ClassicFrame::send_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(
-      dst_channel, dst_protocol,
-      {std::string(Auth::kName), initial_server_auth_data_});
-  if (!send_res) return send_client_failed(send_res.error());
-
-  stage(Stage::ClientData);
-
-  return Result::SendToClient;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::client_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("sha256_password::forward::client_data:\n" +
-                              hexify(msg_res->auth_method_data())));
-
-  if (src_channel->ssl() ||
-      msg_res->auth_method_data() == Auth::kEmptyPassword) {
-    // password is null-terminated, remove it.
-    src_protocol->password(std::string(
-        AuthBase::strip_trailing_null(msg_res->auth_method_data())));
-
-    trace(Tracer::Event().stage("sha256_password::forward::password:\n" +
-                                hexify(*src_protocol->password())));
-
-    discard_current_msg(src_channel, src_protocol);
-
-    return send_password();
-  } else if (Auth::is_public_key_request(msg_res->auth_method_data())) {
-    trace(
-        Tracer::Event().stage("sha256_password::forward::public_key_request"));
-
-    if (AuthBase::connection_has_public_key(connection())) {
-      // send the router's public-key to be able to decrypt the client's
-      // password.
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("sha256_password::forward::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) {
-        auto ec = pubkey_res.error();
-
-        if (ec != std::errc::function_not_supported) {
-          return send_client_failed(ec);
-        }
-
-        stage(Stage::Done);
-
-        // couldn't get the public key, fail the auth.
-        auto send_res =
-            ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-                src_channel, src_protocol,
-                {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
-        if (!send_res) return send_client_failed(send_res.error());
-      } else {
-        // send the router's public key to the client.
-        stage(Stage::EncryptedPassword);
-
-        auto send_res =
-            Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-        if (!send_res) return send_client_failed(send_res.error());
-      }
-
-      return Result::SendToClient;
-    } else {
-      // client requested a public key, but router has no ssl-ctx
-      // (client-ssl-mode is DISABLED|PASSTHROUGH)
-      //
-      // If the server-connection is encrypted, the server will treat the
-      // public-key-request as an invalid password
-      // (as it isn't terminated by \0)
-      stage(Stage::PublicKeyResponse);
-
-      return forward_client_to_server();
-    }
-  } else {
-    discard_current_msg(src_channel, src_protocol);
-
-    Tracer::Event().stage("sha256_password::forward::bad_message:\n" +
-                          hexify(msg_res->auth_method_data()));
-
-    return recv_client_failed(make_error_code(std::errc::bad_message));
-  }
-}
-
-// encrypted password from client to server.
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::encrypted_password() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  if (AuthBase::connection_has_public_key(connection())) {
-    auto recv_res = Auth::rsa_decrypt_password(
-        connection()->context().source_ssl_ctx()->get(),
-        msg_res->auth_method_data(), src_protocol->auth_method_data());
-    if (!recv_res) {
-      trace(Tracer::Event().stage("sha256_password::forward::decrypt:\n" +
-                                  recv_res.error().message()));
-      return recv_client_failed(recv_res.error());
-    }
-
-    src_protocol->password(*recv_res);
-
-    trace(Tracer::Event().stage("sha256_password::forward::password:\n" +
-                                hexify(*src_protocol->password())));
-
-    discard_current_msg(src_channel, src_protocol);
-
-    return send_password();
-  } else {
-    trace(Tracer::Event().stage("sha256_password::forward::encrypted"));
-
-    stage(Stage::Response);
-
-    return forward_client_to_server();
-  }
-}
-
-// encrypted password from client to server.
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::send_password() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_protocol = connection()->client_protocol();
-
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  if (dst_channel->ssl() || src_protocol->password()->empty()) {
-    // the server-side is encrypted (or the password is empty):
-    //
-    // send plaintext password
-    trace(
-        Tracer::Event().stage("sha256_password::forward::plaintext_password"));
-
-    stage(Stage::Response);
-
-    auto send_res = Auth::send_plaintext_password(
-        dst_channel, dst_protocol, src_protocol->password().value());
-    if (!send_res) return send_server_failed(send_res.error());
-  } else {
-    // the server is NOT encrypted: ask for the server's publickey
-    trace(
-        Tracer::Event().stage("sha256_password::forward::public_key_request"));
-
-    stage(Stage::PublicKeyResponse);
-
-    auto send_res = Auth::send_public_key_request(dst_channel, dst_protocol);
-    if (!send_res) return send_server_failed(send_res.error());
-  }
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("sha256_password::forward::response"));
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug(
-      "received unexpected message from server in sha256-password-auth:\n%s",
-      hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::public_key_response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    AuthData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthData:
-      stage(Stage::PublicKey);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("sha256_password::forward::response"));
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug(
-      "received unexpected message from server in sha256-password-auth:\n%s",
-      hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-/*
- * @pre
- * a public-key request was sent to the server.
- */
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::public_key() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          dst_channel, dst_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("sha256_password::forward::public_key"));
-
-  if (!src_protocol->password().has_value()) {
-    stage(Stage::EncryptedPassword);
-
-    return forward_server_to_client();
-  }
-
-  auto password = *src_protocol->password();
-  auto msg = std::move(*msg_res);
-
-  discard_current_msg(dst_channel, dst_protocol);
-
-  auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-  if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-  auto encrypted_res = Auth::rsa_encrypt_password(*pubkey_res, password,
-                                                  initial_server_auth_data_);
-  if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-  trace(Tracer::Event().stage("sha256_password::forward::encrypted_password"));
-
-  auto send_res =
-      Auth::send_encrypted_password(dst_channel, dst_protocol, *encrypted_res);
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code> AuthSha256Forwarder::ok() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("sha256_password::forward::ok"));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-AuthSha256Forwarder::error() {
-  stage(Stage::Done);
-
-  trace(Tracer::Event().stage("sha256_password::forward::error"));
-
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_auth_sha256_password.h b/router/src/routing/src/classic_auth_sha256_password.h
deleted file mode 100644
index 37b4ffa2c70..00000000000
--- a/router/src/routing/src/classic_auth_sha256_password.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_AUTH_SHA256_PASSWORD_INCLUDED
-#define ROUTING_CLASSIC_AUTH_SHA256_PASSWORD_INCLUDED
-
-#include <memory>  // unique_ptr
-#include <string_view>
-#include <system_error>
-
-#include <openssl/ssl.h>
-
-#include "classic_auth.h"
-#include "classic_connection.h"
-#include "mysql/harness/stdx/expected.h"
-
-// low-level routings for sha256_password
-class AuthSha256Password : public AuthBase {
- public:
-  static constexpr const std::string_view kName{"sha256_password"};
-
-  static constexpr const std::string_view kEmptyPassword{"\x00", 1};
-  static constexpr const std::string_view kPublicKeyRequest{"\x01"};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-
-  static stdx::expected<size_t, std::error_code> send_public_key_request(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol);
-
-  static stdx::expected<size_t, std::error_code> send_public_key(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &public_key);
-
-  static stdx::expected<size_t, std::error_code> send_plaintext_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static stdx::expected<size_t, std::error_code> send_encrypted_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static bool is_public_key_request(const std::string_view &data);
-  static bool is_public_key(const std::string_view &data);
-};
-
-class AuthSha256Sender : public Processor {
- public:
-  AuthSha256Sender(MysqlRoutingClassicConnection *conn,
-                   std::string initial_server_auth_data, std::string password)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        password_{std::move(password)} {}
-
-  enum class Stage {
-    Init,
-
-    Response,
-
-    PublicKey,
-
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  using Auth = AuthSha256Password;
-
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> public_key();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  Stage stage_{Stage::Init};
-
-  std::string initial_server_auth_data_;
-  std::string password_;
-};
-
-// forwarder
-
-class AuthSha256Forwarder : public Processor {
- public:
-  AuthSha256Forwarder(MysqlRoutingClassicConnection *conn,
-                      std::string initial_server_auth_data,
-                      bool in_handshake = false)
-      : Processor(conn),
-        initial_server_auth_data_{std::move(initial_server_auth_data)},
-        stage_{in_handshake ? Stage::Response : Stage::Init} {}
-
-  enum class Stage {
-    Init,
-
-    ClientData,
-    EncryptedPassword,
-
-    PublicKeyResponse,
-    PublicKey,
-
-    Response,
-    Error,
-    Ok,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  using Auth = AuthSha256Password;
-
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> client_data();
-  stdx::expected<Result, std::error_code> encrypted_password();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> public_key();
-  stdx::expected<Result, std::error_code> public_key_response();
-  stdx::expected<Result, std::error_code> error();
-  stdx::expected<Result, std::error_code> ok();
-
-  stdx::expected<Result, std::error_code> send_password();
-
-  std::string initial_server_auth_data_;
-
-  Stage stage_;
-};
-
-#endif
diff --git a/router/src/routing/src/classic_change_user.cc b/router/src/routing/src/classic_change_user.cc
index fe2ec6afc8e..8de69d1ce4a 100644
--- a/router/src/routing/src/classic_change_user.cc
+++ b/router/src/routing/src/classic_change_user.cc
@@ -26,12 +26,9 @@
 
 #include <optional>
 
+#include <openssl/evp.h>
+
 #include "classic_auth.h"
-#include "classic_auth_caching_sha2.h"
-#include "classic_auth_cleartext.h"
-#include "classic_auth_forwarder.h"
-#include "classic_auth_native.h"
-#include "classic_auth_sha256_password.h"
 #include "classic_connect.h"
 #include "classic_connection.h"
 #include "classic_forwarder.h"
@@ -53,6 +50,20 @@ using mysql_harness::hexify;
 using namespace std::string_literals;
 using namespace std::string_view_literals;
 
+static bool connection_has_public_key(
+    MysqlRoutingClassicConnection *connection) {
+#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
+  if (!connection->context().source_ssl_ctx()) return false;
+
+  SSL_CTX *ssl_ctx = connection->context().source_ssl_ctx()->get();
+
+  return SSL_CTX_get0_certificate(ssl_ctx) != nullptr;
+#else
+  (void)connection;
+  return false;
+#endif
+}
+
 /**
  * forward the change-user message flow.
  *
@@ -276,10 +287,16 @@ stdx::expected<Processor::Result, std::error_code> ChangeUserSender::process() {
   switch (stage()) {
     case Stage::Command:
       return command();
-    case Stage::InitialResponse:
-      return initial_response();
-    case Stage::FinalResponse:
-      return final_response();
+    case Stage::Response:
+      return response();
+    case Stage::AuthMethodSwitch:
+      return auth_method_switch();
+    case Stage::ClientData:
+      return client_data();
+    case Stage::AuthResponse:
+      return auth_response();
+    case Stage::ServerData:
+      return server_data();
     case Stage::Ok:
       return ok();
     case Stage::Error:
@@ -510,20 +527,12 @@ stdx::expected<Processor::Result, std::error_code> ChangeUserSender::command() {
       ClassicFrame::send_msg(dst_channel, dst_protocol, *change_user_msg_);
   if (!send_res) return send_server_failed(send_res.error());
 
-  stage(Stage::InitialResponse);
+  stage(Stage::Response);
   return Result::SendToServer;
 }
 
 stdx::expected<Processor::Result, std::error_code>
-ChangeUserSender::initial_response() {
-  connection()->push_processor(std::make_unique<AuthForwarder>(connection()));
-
-  stage(Stage::FinalResponse);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserSender::final_response() {
+ChangeUserSender::response() {
   auto *socket_splicer = connection()->socket_splicer();
   auto src_channel = socket_splicer->server_channel();
   auto src_protocol = connection()->server_protocol();
@@ -535,11 +544,16 @@ ChangeUserSender::final_response() {
   const uint8_t msg_type = src_protocol->current_msg_type().value();
 
   enum class Msg {
+    AuthMethodSwitch = ClassicFrame::cmd_byte<
+        classic_protocol::message::server::AuthMethodSwitch>(),
     Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
     Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
   };
 
   switch (Msg{msg_type}) {
+    case Msg::AuthMethodSwitch:
+      stage(Stage::AuthMethodSwitch);
+      return Result::Again;
     case Msg::Ok:
       stage(Stage::Ok);
       return Result::Again;
@@ -553,6 +567,436 @@ ChangeUserSender::final_response() {
   return stdx::make_unexpected(make_error_code(std::errc::bad_message));
 }
 
+stdx::expected<Processor::Result, std::error_code>
+ChangeUserSender::auth_method_switch() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto src_channel = socket_splicer->server_channel();
+  auto src_protocol = connection()->server_protocol();
+  auto dst_protocol = connection()->client_protocol();
+
+  auto msg_res = ClassicFrame::recv_msg<
+      classic_protocol::message::server::AuthMethodSwitch>(src_channel,
+                                                           src_protocol);
+  if (!msg_res) return recv_server_failed(msg_res.error());
+
+  auto msg = std::move(*msg_res);
+
+  trace(Tracer::Event().stage("change_user::auth_method_switch: " +
+                              msg.auth_method()));
+
+  src_protocol->auth_method_name(msg.auth_method());
+  src_protocol->auth_method_data(msg.auth_method_data());
+  dst_protocol->auth_method_name(msg.auth_method());
+  dst_protocol->auth_method_data(msg.auth_method_data());
+
+  if (dst_protocol->password().has_value()) {
+    auto pwd = *(dst_protocol->password());
+
+    discard_current_msg(src_channel, src_protocol);
+
+    if (!src_channel->ssl() && !pwd.empty() &&
+        dst_protocol->auth_method_name() == AuthSha256Password::kName) {
+      // the server channel isn't encrypted, request the public-key.
+
+      auto send_res = AuthSha256Password::send_public_key_request(src_channel,
+                                                                  src_protocol);
+
+      if (!send_res) return send_server_failed(send_res.error());
+    } else {
+      trace(Tracer::Event().stage("change_user::client_data"));
+
+      auto scramble_res = scramble_them_all(
+          msg.auth_method(), strip_trailing_null(msg.auth_method_data()), pwd);
+
+      if (!scramble_res) {
+        return recv_server_failed(make_error_code(std::errc::bad_message));
+      }
+
+      auto send_res = ClassicFrame::send_msg<classic_protocol::wire::String>(
+          src_channel, src_protocol, {*scramble_res});
+      if (!send_res) return send_server_failed(send_res.error());
+    }
+
+    stage(Stage::AuthResponse);
+    return Result::SendToServer;
+  } else {
+    stage(Stage::ClientData);
+    return forward_server_to_client();
+  }
+}
+
+stdx::expected<Processor::Result, std::error_code>
+ChangeUserSender::client_data() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto src_channel = socket_splicer->client_channel();
+  auto src_protocol = connection()->client_protocol();
+  auto *dst_channel = socket_splicer->server_channel();
+  auto *dst_protocol = connection()->server_protocol();
+
+  auto msg_res =
+      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
+          src_channel, src_protocol);
+  if (!msg_res) return recv_client_failed(msg_res.error());
+
+  trace(Tracer::Event().stage("change_user::client_data:\n" +
+                              hexify(msg_res->auth_method_data())));
+
+  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
+    using Auth = AuthCachingSha2Password;
+
+    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
+        connection_has_public_key(connection())) {
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("server::auth::public_key"));
+
+      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
+          connection()->context().source_ssl_ctx()->get());
+      if (!pubkey_res) {
+        auto ec = pubkey_res.error();
+
+        if (ec != std::errc::function_not_supported) {
+          return send_client_failed(ec);
+        }
+
+        // couldn't get the public key, fail the auth.
+        auto send_res =
+            ClassicFrame::send_msg<classic_protocol::message::server::Error>(
+                src_channel, src_protocol,
+                {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
+        if (!send_res) return send_client_failed(send_res.error());
+      } else {
+        auto send_res =
+            Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
+        if (!send_res) return send_client_failed(send_res.error());
+      }
+
+      return Result::SendToClient;
+    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
+               connection_has_public_key(connection())) {
+      auto recv_res = Auth::rsa_decrypt_password(
+          connection()->context().source_ssl_ctx()->get(),
+          msg_res->auth_method_data(), src_protocol->auth_method_data());
+      if (!recv_res) return recv_client_failed(recv_res.error());
+
+      src_protocol->password(*recv_res);
+
+      trace(Tracer::Event().stage("change_user::password"));
+
+      discard_current_msg(src_channel, src_protocol);
+
+      if (dst_channel->ssl()) {
+        // the server-side is encrypted: send plaintext password
+        trace(Tracer::Event().stage("change_user::plaintext_password"));
+
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        // the server is NOT encrypted: ask for the server's publickey
+        trace(Tracer::Event().stage("change_user::request_public_key"));
+
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::AuthResponse);
+      return Result::SendToServer;
+    } else if (src_channel->ssl() && msg_res->auth_method_data().size() == 32) {
+      // try fast auth first.
+
+      stage(Stage::AuthResponse);
+      return forward_client_to_server();
+    } else if (src_channel->ssl()) {
+      discard_current_msg(src_channel, src_protocol);
+
+      auto pwd = msg_res->auth_method_data();
+      pwd.resize(pwd.size() - 1);
+
+      // the plaintext password.
+      src_protocol->password(pwd);
+
+      if (dst_channel->ssl() || pwd.empty()) {
+        trace(Tracer::Event().stage("client::auth::plaintext_password"));
+        // the server-side is encrypted: send plaintext password with trailing
+        // \0
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+        // the server is NOT encrypted: ask for the server's publickey
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::AuthResponse);
+      return Result::SendToServer;
+    }
+  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
+    using Auth = AuthSha256Password;
+
+    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
+        connection_has_public_key(connection())) {
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("server::auth::public_key"));
+
+      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
+          connection()->context().source_ssl_ctx()->get());
+      if (!pubkey_res) return send_client_failed(pubkey_res.error());
+
+      auto send_res =
+          Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
+      if (!send_res) return send_client_failed(send_res.error());
+
+      return Result::SendToClient;
+    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
+               connection()->context().source_ssl_ctx()) {
+      auto recv_res = Auth::rsa_decrypt_password(
+          connection()->context().source_ssl_ctx()->get(),
+          msg_res->auth_method_data(), src_protocol->auth_method_data());
+      if (!recv_res) return recv_client_failed(recv_res.error());
+
+      src_protocol->password(*recv_res);
+
+      discard_current_msg(src_channel, src_protocol);
+
+      if (dst_channel->ssl()) {
+        trace(Tracer::Event().stage("client::auth_data::password"));
+        // the server-side is encrypted: send plaintext password
+
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        // the server is NOT encrypted: ask for the server's public-key
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::AuthResponse);
+      return Result::SendToServer;
+    } else if (src_channel->ssl()) {
+      discard_current_msg(src_channel, src_protocol);
+      auto pwd = msg_res->auth_method_data();
+      pwd.resize(pwd.size() - 1);
+
+      // the plaintext password.
+      src_protocol->password(pwd);
+
+      if (dst_channel->ssl() || pwd.empty()) {
+        trace(Tracer::Event().stage("client::auth_data::password"));
+        // the server-side is encrypted (or the password is empty)
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        // the server is NOT encrypted: ask for the server's public-key
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::AuthResponse);
+      return Result::SendToServer;
+    }
+  }
+
+  stage(Stage::AuthResponse);
+  return forward_client_to_server();
+}
+
+stdx::expected<Processor::Result, std::error_code>
+ChangeUserSender::auth_response() {
+  // ERR|OK|data
+  auto *socket_splicer = connection()->socket_splicer();
+  auto src_channel = socket_splicer->server_channel();
+  auto src_protocol = connection()->server_protocol();
+
+  auto read_res =
+      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
+  if (!read_res) return recv_server_failed(read_res.error());
+
+  uint8_t msg_type = src_protocol->current_msg_type().value();
+
+  enum class Msg {
+    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
+    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
+    AuthData = ClassicFrame::cmd_byte<
+        classic_protocol::message::server::AuthMethodData>(),
+  };
+
+  switch (Msg{msg_type}) {
+    case Msg::Error:
+      stage(Stage::Error);
+      return Result::Again;
+    case Msg::Ok:
+      stage(Stage::Ok);
+      return Result::Again;
+    case Msg::AuthData:
+      stage(Stage::ServerData);
+      return Result::Again;
+  }
+
+  trace(Tracer::Event().stage("change_user::auth::response"));
+
+  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
+}
+
+/**
+ * receive auth-data from the server handle it.
+ */
+stdx::expected<Processor::Result, std::error_code>
+ChangeUserSender::server_data() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto src_channel = socket_splicer->server_channel();
+  auto src_protocol = connection()->server_protocol();
+  auto dst_protocol = connection()->client_protocol();
+
+  auto msg_res =
+      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
+          src_channel, src_protocol);
+  if (!msg_res) return recv_server_failed(msg_res.error());
+
+  auto msg = std::move(*msg_res);
+
+  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
+    using Auth = AuthCachingSha2Password;
+
+    // if ensure_has_full_frame fails, we'll fail later with bad_message.
+
+    if (msg.auth_method_data().size() < 1) {
+      return recv_server_failed(make_error_code(std::errc::bad_message));
+    }
+
+    switch (msg.auth_method_data()[0]) {
+      case Auth::kFastAuthDone:
+        trace(Tracer::Event().stage("change_user::auth::fast-auth-ok"));
+
+        stage(Stage::AuthResponse);
+
+        // fast-auth-ok is followed by Ok
+        if (dst_protocol->password().has_value()) {
+          // as the client provided a password already, it expects a Ok next.
+          discard_current_msg(src_channel, src_protocol);
+
+          return Result::Again;
+        } else {
+          // client provided a hash and expects the 0x03 and OK.
+          return forward_server_to_client(true /* noflush */);
+        }
+      case Auth::kPerformFullAuth:
+        trace(Tracer::Event().stage("change_user::auth::full-auth"));
+
+        if (dst_protocol->password().has_value()) {
+          auto opt_pwd = dst_protocol->password();
+
+          discard_current_msg(src_channel, src_protocol);
+
+          if (!src_channel->ssl()) {
+            // the server is NOT encrypted: ask for the server's publickey
+            trace(
+                Tracer::Event().stage("change_user::auth::request_public_key"));
+            auto send_res =
+                Auth::send_public_key_request(src_channel, src_protocol);
+            if (!send_res) return send_server_failed(send_res.error());
+          } else {
+            trace(
+                Tracer::Event().stage("change_user::auth::plaintext_password"));
+            auto send_res = Auth::send_plaintext_password(
+                src_channel, src_protocol, *opt_pwd);
+            if (!send_res) return send_server_failed(send_res.error());
+          }
+
+          // send it to the server.
+          stage(Stage::AuthResponse);
+          return Result::SendToServer;
+        } else {
+          // forward request for full auth to the client.
+          stage(Stage::ClientData);
+
+          return forward_server_to_client();
+        }
+      case '-': {
+        trace(Tracer::Event().stage("change_user::auth::public_key"));
+
+        if (dst_protocol->password().has_value()) {
+          // the client's password is known: answer the server directly.
+          auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
+          if (!pubkey_res) return recv_server_failed(pubkey_res.error());
+
+          discard_current_msg(src_channel, src_protocol);
+
+          trace(Tracer::Event().stage("client::auth::password"));
+
+          auto encrypted_res = Auth::rsa_encrypt_password(
+              *pubkey_res, *(dst_protocol->password()),
+              src_protocol->auth_method_data());
+          if (!encrypted_res) return send_server_failed(encrypted_res.error());
+
+          auto send_res = Auth::send_encrypted_password(
+              src_channel, src_protocol, *encrypted_res);
+          if (!send_res) return send_server_failed(send_res.error());
+
+          stage(Stage::Response);
+          return Result::SendToServer;
+        } else {
+          // ... otherwise forward the public-key to the client and send its
+          // encrypted password.
+          stage(Stage::ClientData);
+
+          return forward_server_to_client();
+        }
+      }
+    }
+  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
+    using Auth = AuthSha256Password;
+    // public key
+    trace(Tracer::Event().stage("server::auth::public-key"));
+
+    if (dst_protocol->password().has_value()) {
+      // the client's password is known: answer the server directly.
+      auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
+      if (!pubkey_res) return recv_server_failed(pubkey_res.error());
+
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("client::auth::password"));
+
+      auto encrypted_res =
+          Auth::rsa_encrypt_password(*pubkey_res, *(dst_protocol->password()),
+                                     src_protocol->auth_method_data());
+      if (!encrypted_res) return send_server_failed(encrypted_res.error());
+
+      auto send_res = Auth::send_encrypted_password(src_channel, src_protocol,
+                                                    *encrypted_res);
+      if (!send_res) return send_server_failed(send_res.error());
+
+      stage(Stage::AuthResponse);
+      return Result::SendToServer;
+    } else {
+      // ... otherwise forward the public-key to the client and send its
+      // encrypted password.
+      stage(Stage::ClientData);
+
+      return forward_server_to_client();
+    }
+  }
+
+  log_debug("change_user::auth::data: %s",
+            hexify(msg.auth_method_data()).c_str());
+
+  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
+}
+
 stdx::expected<Processor::Result, std::error_code> ChangeUserSender::ok() {
   auto *socket_splicer = connection()->socket_splicer();
   auto src_channel = socket_splicer->server_channel();
diff --git a/router/src/routing/src/classic_change_user.h b/router/src/routing/src/classic_change_user.h
index 70cf0c10117..2fda7f28d0a 100644
--- a/router/src/routing/src/classic_change_user.h
+++ b/router/src/routing/src/classic_change_user.h
@@ -72,8 +72,11 @@ class ChangeUserSender : public Processor {
 
   enum class Stage {
     Command,
-    InitialResponse,
-    FinalResponse,
+    Response,
+    AuthMethodSwitch,
+    ClientData,
+    AuthResponse,
+    ServerData,
     Ok,
     Error,
     Done,
@@ -86,8 +89,11 @@ class ChangeUserSender : public Processor {
 
  private:
   stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> initial_response();
-  stdx::expected<Result, std::error_code> final_response();
+  stdx::expected<Result, std::error_code> response();
+  stdx::expected<Result, std::error_code> auth_method_switch();
+  stdx::expected<Result, std::error_code> client_data();
+  stdx::expected<Result, std::error_code> auth_response();
+  stdx::expected<Result, std::error_code> server_data();
   stdx::expected<Result, std::error_code> ok();
   stdx::expected<Result, std::error_code> error();
 
diff --git a/router/src/routing/src/classic_greeting.cc b/router/src/routing/src/classic_greeting.cc
index 7f4c158e3ce..cca2d6dd701 100644
--- a/router/src/routing/src/classic_greeting.cc
+++ b/router/src/routing/src/classic_greeting.cc
@@ -30,11 +30,6 @@
 #include <system_error>
 
 #include "classic_auth.h"
-#include "classic_auth_caching_sha2.h"
-#include "classic_auth_cleartext.h"
-#include "classic_auth_forwarder.h"
-#include "classic_auth_native.h"
-#include "classic_auth_sha256_password.h"
 #include "classic_change_user.h"
 #include "classic_connect.h"
 #include "classic_connection.h"
@@ -818,10 +813,14 @@ stdx::expected<Processor::Result, std::error_code> ServerGreetor::process() {
       return tls_connect();
     case Stage::ClientGreetingAfterTls:
       return client_greeting_after_tls();
-    case Stage::InitialResponse:
-      return initial_response();
-    case Stage::FinalResponse:
-      return final_response();
+    case Stage::Response:
+      return response();
+    case Stage::AuthData:
+      return auth_data();
+    case Stage::AuthMethodSwitch:
+      return auth_method_switch();
+    case Stage::ClientAuth:
+      return client_auth();
     case Stage::AuthError:
       return auth_error();
     case Stage::AuthOk:
@@ -1289,7 +1288,7 @@ ServerGreetor::client_greeting_full() {
   return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
       .and_then(
           [this](auto /* sent */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::InitialResponse);
+            stage(Stage::Response);
 
             return Result::SendToServer;
           })
@@ -1476,23 +1475,14 @@ ServerGreetor::client_greeting_after_tls() {
   return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
       .and_then(
           [this](auto /* unused */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::InitialResponse);
+            stage(Stage::Response);
 
             return Result::SendToServer;
           })
       .or_else([this](auto err) { return send_server_failed(err); });
 }
 
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::initial_response() {
-  connection()->push_processor(std::make_unique<AuthForwarder>(connection()));
-
-  stage(Stage::FinalResponse);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::final_response() {
+stdx::expected<Processor::Result, std::error_code> ServerGreetor::response() {
   // ERR|OK|EOF|other
   auto *socket_splicer = connection()->socket_splicer();
   auto src_channel = socket_splicer->server_channel();
@@ -1501,22 +1491,38 @@ ServerGreetor::final_response() {
   // ensure the recv_buf has at last frame-header (+ msg-byte)
   auto read_res =
       ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
+  if (!read_res) {
+    auto ec = read_res.error();
+
+    if (ec == TlsErrc::kWantRead) return Result::RecvFromServer;
+
+    return recv_server_failed(ec);
+  }
 
   const uint8_t msg_type = src_protocol->current_msg_type().value();
 
   enum class Msg {
+    AuthMethodSwitch = ClassicFrame::cmd_byte<
+        classic_protocol::message::server::AuthMethodSwitch>(),
     Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
     Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
+    AuthMethodData = ClassicFrame::cmd_byte<
+        classic_protocol::message::server::AuthMethodData>(),
   };
 
   switch (Msg{msg_type}) {
+    case Msg::AuthMethodSwitch:
+      stage(Stage::AuthMethodSwitch);
+      return Result::Again;
     case Msg::Ok:
       stage(Stage::AuthOk);
       return Result::Again;
     case Msg::Error:
       stage(Stage::AuthError);
       return Result::Again;
+    case Msg::AuthMethodData:
+      stage(Stage::AuthData);
+      return Result::Again;
   }
 
   // if there is another packet, dump its payload for now.
@@ -1588,6 +1594,426 @@ stdx::expected<Processor::Result, std::error_code> ServerGreetor::auth_ok() {
   return Result::Again;
 }
 
+stdx::expected<Processor::Result, std::error_code>
+ServerGreetor::auth_method_switch() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto *src_channel = socket_splicer->server_channel();
+  auto *src_protocol = connection()->server_protocol();
+  auto *dst_protocol = connection()->client_protocol();
+
+  auto msg_res = ClassicFrame::recv_msg<
+      classic_protocol::message::server::AuthMethodSwitch>(src_channel,
+                                                           src_protocol);
+  if (!msg_res) return recv_server_failed(msg_res.error());
+
+  auto msg = std::move(*msg_res);
+
+  src_protocol->auth_method_name(msg.auth_method());
+  src_protocol->auth_method_data(msg.auth_method_data());
+  dst_protocol->auth_method_name(msg.auth_method());
+  dst_protocol->auth_method_data(msg.auth_method_data());
+
+  trace(Tracer::Event().stage("server::auth::switch: " + msg.auth_method() +
+                              "\n" + hexify(msg.auth_method_data())));
+
+#if defined(DEBUG_IO)
+  std::cerr << __LINE__ << ": auth_method_name: " << msg.auth_method() << "\n";
+  std::cerr << __LINE__ << ": auth_method_data:\n"
+            << hexify(msg.auth_method_data()) << "\n";
+#endif
+
+  if (dst_protocol->password().has_value()) {
+    auto pwd = *(dst_protocol->password());
+
+    if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
+      using Auth = AuthSha256Password;
+
+      if (!src_channel->ssl()) {
+        discard_current_msg(src_channel, src_protocol);
+
+        if (pwd.empty()) {
+          // send empty passwords directly.
+          trace(Tracer::Event().stage("client::auth::plain"));
+
+          auto send_res =
+              Auth::send_plaintext_password(src_channel, src_protocol, pwd);
+          if (!send_res) return send_server_failed(send_res.error());
+
+          stage(Stage::Response);
+          return Result::SendToServer;
+        } else {
+          // the server is NOT encrypted: ask for the server's publickey
+          trace(Tracer::Event().stage("client::auth::request_public_key"));
+
+          auto send_res =
+              Auth::send_public_key_request(src_channel, src_protocol);
+          if (!send_res) return send_server_failed(send_res.error());
+
+          stage(Stage::Response);
+          return Result::SendToServer;
+        }
+      }
+    }
+
+    // if the password set and not empty, rehash it.
+    if (auto scramble_res = scramble_them_all(
+            msg.auth_method(), strip_trailing_null(msg.auth_method_data()),
+            pwd)) {
+      discard_current_msg(src_channel, src_protocol);
+
+      auto send_res = ClassicFrame::send_msg<classic_protocol::wire::String>(
+          src_channel, src_protocol, {*scramble_res});
+      if (!send_res) return stdx::make_unexpected(send_res.error());
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    } else {
+      return send_server_failed(make_error_code(std::errc::bad_message));
+    }
+  } else {
+    stage(Stage::ClientAuth);
+    return forward_server_to_client();
+  }
+}
+
+static bool connection_has_public_key(
+    MysqlRoutingClassicConnection *connection) {
+#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
+  if (!connection->context().source_ssl_ctx()) return false;
+
+  SSL_CTX *ssl_ctx = connection->context().source_ssl_ctx()->get();
+
+  return SSL_CTX_get0_certificate(ssl_ctx) != nullptr;
+#else
+  (void)connection;
+  return false;
+#endif
+}
+
+stdx::expected<Processor::Result, std::error_code>
+ServerGreetor::client_auth() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto *src_channel = socket_splicer->client_channel();
+  auto *src_protocol = connection()->client_protocol();
+  auto *dst_channel = socket_splicer->server_channel();
+  auto *dst_protocol = connection()->server_protocol();
+
+  auto msg_res =
+      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
+          src_channel, src_protocol);
+  if (!msg_res) return recv_client_failed(msg_res.error());
+
+  trace(Tracer::Event().stage("client::auth"));
+
+  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
+    using Auth = AuthCachingSha2Password;
+
+    if (Auth::is_public_key_request(msg_res->auth_method_data())) {
+      if (connection_has_public_key(connection())) {
+        discard_current_msg(src_channel, src_protocol);
+
+        trace(Tracer::Event().stage("server::auth::public_key"));
+
+        auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
+            connection()->context().source_ssl_ctx()->get());
+        if (!pubkey_res) {
+          auto ec = pubkey_res.error();
+
+          if (ec != std::errc::function_not_supported) {
+            return send_client_failed(ec);
+          }
+
+          // couldn't get the public key, fail the auth.
+          auto send_res =
+              ClassicFrame::send_msg<classic_protocol::message::server::Error>(
+                  src_channel, src_protocol,
+                  {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
+          if (!send_res) return send_client_failed(send_res.error());
+        } else {
+          auto send_res =
+              Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
+          if (!send_res) return send_client_failed(send_res.error());
+        }
+
+        return Result::SendToClient;
+      } else {
+        // client requested a public key, but router has no ssl-ctx
+        // (client-ssl-mode is DISABLED|PASSTHROUGH)
+        stage(Stage::Response);
+        return forward_client_to_server();
+      }
+    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
+               connection_has_public_key(connection())) {
+      trace(Tracer::Event().stage("client::auth::encrypted"));
+
+      auto recv_res = Auth::rsa_decrypt_password(
+          connection()->context().source_ssl_ctx()->get(),
+          msg_res->auth_method_data(), src_protocol->auth_method_data());
+      if (!recv_res) return recv_client_failed(recv_res.error());
+
+      src_protocol->password(*recv_res);
+
+      discard_current_msg(src_channel, src_protocol);
+
+      if (dst_channel->ssl()) {
+        trace(Tracer::Event().stage("client::auth::plaintext_password"));
+        // the server-side is encrypted: send plaintext password
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+        // the server is NOT encrypted: ask for the server's publickey
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    }
+  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
+    using Auth = AuthSha256Password;
+
+    if (msg_res->auth_method_data() == Auth::kEmptyPassword) {
+      // empty password.
+      src_protocol->password("");
+
+      stage(Stage::Response);
+      return forward_client_to_server();
+    } else if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
+               connection_has_public_key(connection())) {
+      // if the client is not encrypted, it may ask for the server's public-key
+      // via 0x01
+      //
+      // if the server is encrypted, it doesn't expect that 0x01 and will treat
+      // it as plaintext password.
+
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("server::auth::public_key"));
+
+      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
+          connection()->context().source_ssl_ctx()->get());
+      if (!pubkey_res) {
+        auto ec = pubkey_res.error();
+
+        if (ec != std::errc::function_not_supported) {
+          return send_client_failed(ec);
+        }
+
+        // couldn't get the public key, fail the auth.
+        auto send_res =
+            ClassicFrame::send_msg<classic_protocol::message::server::Error>(
+                src_channel, src_protocol,
+                {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
+        if (!send_res) return send_client_failed(send_res.error());
+      } else {
+        auto send_res =
+            Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
+        if (!send_res) return send_client_failed(send_res.error());
+      }
+
+      return Result::SendToClient;
+    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
+               connection_has_public_key(connection())) {
+      auto recv_res = Auth::rsa_decrypt_password(
+          connection()->context().source_ssl_ctx()->get(),
+          msg_res->auth_method_data(), src_protocol->auth_method_data());
+      if (!recv_res) return recv_client_failed(recv_res.error());
+
+      src_protocol->password(*recv_res);
+
+      discard_current_msg(src_channel, src_protocol);
+
+      if (dst_channel->ssl()) {
+        // the server-side is encrypted: send plaintext password
+        trace(Tracer::Event().stage("client::auth::password"));
+
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        // the server is NOT encrypted: ask for the server's public-key
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    }
+  }
+
+#if defined(DEBUG_IO)
+  std::cerr << __LINE__ << ": auth_method_data:\n"
+            << hexify(msg_res->auth_method_data()) << "\n";
+#endif
+
+  stage(Stage::Response);
+  return forward_client_to_server();
+}
+
+/**
+ *
+ * server->router
+ */
+stdx::expected<Processor::Result, std::error_code> ServerGreetor::auth_data() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto src_channel = socket_splicer->server_channel();
+  auto src_protocol = connection()->server_protocol();
+  auto dst_protocol = connection()->client_protocol();
+
+  auto msg_res =
+      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
+          src_channel, src_protocol);
+  if (!msg_res) return recv_server_failed(msg_res.error());
+
+  auto msg = std::move(*msg_res);
+
+  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
+    using Auth = AuthCachingSha2Password;
+
+    if (msg.auth_method_data().size() < 1) {
+      return recv_server_failed(make_error_code(std::errc::bad_message));
+    }
+
+    if (dst_protocol->password().has_value()) {
+      // client's password is known.
+
+      auto opt_pwd = dst_protocol->password();
+
+      switch (msg.auth_method_data()[0]) {
+        case Auth::kFastAuthDone:
+          trace(Tracer::Event().stage("server::auth::fastauthdone"));
+          // 0x03 means the client-greeting provided the right scrambled
+          // password that matches the cached entry.
+
+          // as there is a password provided by the client via
+          // client_recv_plaintext_password() the client side expects either
+          // server::Ok or server::Error now.
+          //
+          // c<-r: server::greeting (from router)
+          // c->r: client::greeting (with tls handshake)
+          // c<-r: 0x01 0x04
+          // c->r: password
+          //    r->s: connect()
+          //    r<-s: server::greeting
+          //    r->s: client::greeting (with tls handshake, rehashed pwd)
+          //    r<-s: 0x01 0x03   // current message
+          //    r<-s: server::Ok
+          // c<-r: server::Ok
+          discard_current_msg(src_channel, src_protocol);
+
+          stage(Stage::Response);
+          return Result::Again;
+        case Auth::kPerformFullAuth: {
+          trace(Tracer::Event().stage("server::auth::request::plain"));
+
+          // as the client already provided a password, provide it to the
+          // server directly.
+          discard_current_msg(src_channel, src_protocol);
+
+          trace(Tracer::Event().stage("client::auth::plain"));
+
+          if (src_channel->ssl()) {
+            auto send_res = Auth::send_plaintext_password(
+                src_channel, src_protocol, *opt_pwd);
+            if (!send_res) return send_server_failed(send_res.error());
+          } else {
+            // the server side isn't encrypted: request public-key
+            auto send_res =
+                Auth::send_public_key_request(src_channel, src_protocol);
+            if (!send_res) return send_server_failed(send_res.error());
+          }
+
+          // send it to the server.
+          stage(Stage::Response);
+          return Result::SendToServer;
+        }
+        case '-': {
+          auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
+          if (!pubkey_res) return recv_server_failed(pubkey_res.error());
+
+          discard_current_msg(src_channel, src_protocol);
+
+          trace(Tracer::Event().stage("client::auth::password"));
+
+          auto encrypted_res = Auth::rsa_encrypt_password(
+              *pubkey_res, *(dst_protocol->password()),
+              src_protocol->auth_method_data());
+          if (!encrypted_res) return send_server_failed(encrypted_res.error());
+
+          auto send_res = Auth::send_encrypted_password(
+              src_channel, src_protocol, *encrypted_res);
+          if (!send_res) return send_server_failed(send_res.error());
+
+          stage(Stage::Response);
+          return Result::SendToServer;
+        }
+      }
+    } else {
+      // client's password is NOT known.
+      switch (msg.auth_method_data()[0]) {
+        case Auth::kFastAuthDone:
+          trace(Tracer::Event().stage("server::auth::fastauthdone"));
+
+          stage(Stage::Response);
+          return forward_server_to_client(true);  // followed by "Ok"
+        case Auth::kPerformFullAuth:
+          trace(Tracer::Event().stage("server::auth::request::plain"));
+
+          stage(Stage::ClientAuth);
+          return forward_server_to_client();
+        case '-': {
+          trace(Tracer::Event().stage("server::auth::public_key"));
+
+          stage(Stage::ClientAuth);
+          return forward_server_to_client();
+        }
+      }
+    }
+  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
+    using Auth = AuthSha256Password;
+
+    trace(Tracer::Event().stage("server::auth::public-key:\n" +
+                                hexify(msg.auth_method_data())));
+
+    if (dst_protocol->password().has_value()) {
+      auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
+      if (!pubkey_res) return recv_server_failed(pubkey_res.error());
+
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("client::auth::password"));
+
+      auto encrypted_res =
+          Auth::rsa_encrypt_password(*pubkey_res, *(dst_protocol->password()),
+                                     src_protocol->auth_method_data());
+      if (!encrypted_res) return send_server_failed(encrypted_res.error());
+
+      auto send_res = Auth::send_encrypted_password(src_channel, src_protocol,
+                                                    *encrypted_res);
+      if (!send_res) return send_server_failed(send_res.error());
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    }
+
+    // public key.
+    stage(Stage::ClientAuth);
+    return forward_server_to_client();
+  }
+
+  std::cerr << __LINE__ << ":\n"
+            << src_protocol->auth_method_name() << "\n"
+            << hexify(msg.auth_method_data()) << "\n";
+
+  return recv_server_failed(make_error_code(std::errc::bad_message));
+}
+
 stdx::expected<Processor::Result, std::error_code>
 ServerFirstConnector::process() {
   switch (stage()) {
@@ -1686,10 +2112,14 @@ ServerFirstAuthenticator::process() {
       return tls_connect();
     case Stage::ClientGreetingAfterTls:
       return client_greeting_after_tls();
-    case Stage::InitialResponse:
-      return initial_response();
-    case Stage::FinalResponse:
-      return final_response();
+    case Stage::Response:
+      return response();
+    case Stage::AuthData:
+      return auth_data();
+    case Stage::AuthMethodSwitch:
+      return auth_method_switch();
+    case Stage::ClientAuth:
+      return client_auth();
     case Stage::AuthError:
       return auth_error();
     case Stage::AuthOk:
@@ -1966,7 +2396,7 @@ ServerFirstAuthenticator::client_greeting_full() {
   return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
       .and_then(
           [this](auto /* unused */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::InitialResponse);
+            stage(Stage::Response);
 
             return Result::SendToServer;
           })
@@ -2239,7 +2669,7 @@ ServerFirstAuthenticator::client_greeting_after_tls() {
   return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
       .and_then(
           [this](auto /* unused */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::InitialResponse);
+            stage(Stage::Response);
 
             return Result::SendToServer;
           })
@@ -2247,15 +2677,7 @@ ServerFirstAuthenticator::client_greeting_after_tls() {
 }
 
 stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::initial_response() {
-  connection()->push_processor(std::make_unique<AuthForwarder>(connection()));
-
-  stage(Stage::FinalResponse);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::final_response() {
+ServerFirstAuthenticator::response() {
   // ERR|OK|EOF|other
   auto *socket_splicer = connection()->socket_splicer();
   auto src_channel = socket_splicer->server_channel();
@@ -2264,22 +2686,38 @@ ServerFirstAuthenticator::final_response() {
   // ensure the recv_buf has at last frame-header (+ msg-byte)
   auto read_res =
       ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
+  if (!read_res) {
+    auto ec = read_res.error();
+
+    if (ec == TlsErrc::kWantRead) return Result::RecvFromServer;
+
+    return recv_server_failed(ec);
+  }
 
   const uint8_t msg_type = src_protocol->current_msg_type().value();
 
   enum class Msg {
+    AuthMethodSwitch = ClassicFrame::cmd_byte<
+        classic_protocol::message::server::AuthMethodSwitch>(),
     Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
     Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
+    AuthMethodData = ClassicFrame::cmd_byte<
+        classic_protocol::message::server::AuthMethodData>(),
   };
 
   switch (Msg{msg_type}) {
+    case Msg::AuthMethodSwitch:
+      stage(Stage::AuthMethodSwitch);
+      return Result::Again;
     case Msg::Ok:
       stage(Stage::AuthOk);
       return Result::Again;
     case Msg::Error:
       stage(Stage::AuthError);
       return Result::Again;
+    case Msg::AuthMethodData:
+      stage(Stage::AuthData);
+      return Result::Again;
   }
 
   // if there is another packet, dump its payload for now.
@@ -2289,7 +2727,7 @@ ServerFirstAuthenticator::final_response() {
   (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
 
   log_debug(
-      "received unexpected message from server after a client::Greeting:\n%s",
+      "received unexpected message from server after a client::Greeting: %s",
       hexify(recv_buf).c_str());
 
   return recv_server_failed(make_error_code(std::errc::bad_message));
@@ -2335,3 +2773,356 @@ ServerFirstAuthenticator::auth_ok() {
 
   return forward_server_to_client();
 }
+
+stdx::expected<Processor::Result, std::error_code>
+ServerFirstAuthenticator::auth_method_switch() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto *src_channel = socket_splicer->server_channel();
+  auto *src_protocol = connection()->server_protocol();
+  auto *dst_protocol = connection()->client_protocol();
+
+  auto msg_res = ClassicFrame::recv_msg<
+      classic_protocol::message::server::AuthMethodSwitch>(src_channel,
+                                                           src_protocol);
+  if (!msg_res) return recv_server_failed(msg_res.error());
+
+  trace(
+      Tracer::Event().stage("server::auth::switch: " + msg_res->auth_method()));
+
+  auto msg = std::move(*msg_res);
+
+  src_protocol->auth_method_name(msg.auth_method());
+  src_protocol->auth_method_data(msg.auth_method_data());
+
+#if defined(DEBUG_IO)
+  std::cerr << __LINE__ << ": auth_method_name: " << msg.auth_method() << "\n";
+  std::cerr << __LINE__ << ": auth_method_data:\n"
+            << hexify(msg.auth_method_data()) << "\n";
+#endif
+
+  if (dst_protocol->password().has_value()) {
+    auto pwd = *(dst_protocol->password());
+
+    if (msg.auth_method() == AuthSha256Password::kName && !src_channel->ssl()) {
+      using Auth = AuthSha256Password;
+
+      discard_current_msg(src_channel, src_protocol);
+      if (pwd.empty()) {
+        trace(Tracer::Event().stage("client::auth::plain"));
+
+        auto send_res =
+            Auth::send_plaintext_password(src_channel, src_protocol, pwd);
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        // the server is NOT encrypted: ask for the server's publickey
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+
+        auto send_res =
+            Auth::send_public_key_request(src_channel, src_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    }
+
+    // if the password set and not empty, rehash it.
+    if (auto scramble_res = scramble_them_all(
+            msg.auth_method(), strip_trailing_null(msg.auth_method_data()),
+            pwd)) {
+      discard_current_msg(src_channel, src_protocol);
+
+      auto send_res = ClassicFrame::send_msg<classic_protocol::wire::String>(
+          src_channel, src_protocol, {*scramble_res});
+      if (!send_res) return stdx::make_unexpected(send_res.error());
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    } else {
+      return send_server_failed(make_error_code(std::errc::bad_message));
+    }
+  } else {
+    dst_protocol->auth_method_name(msg.auth_method());
+    dst_protocol->auth_method_data(msg.auth_method_data());
+
+    stage(Stage::ClientAuth);
+    return forward_server_to_client();
+  }
+}
+
+stdx::expected<Processor::Result, std::error_code>
+ServerFirstAuthenticator::client_auth() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto *src_channel = socket_splicer->client_channel();
+  auto *src_protocol = connection()->client_protocol();
+  auto *dst_channel = socket_splicer->server_channel();
+  auto *dst_protocol = connection()->server_protocol();
+
+  auto msg_res =
+      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
+          src_channel, src_protocol);
+  if (!msg_res) return recv_client_failed(msg_res.error());
+
+  trace(Tracer::Event().stage("client::auth:\n" +
+                              src_protocol->auth_method_name()));
+
+  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
+    using Auth = AuthCachingSha2Password;
+
+    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
+        connection_has_public_key(connection())) {
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("server::auth::public_key"));
+
+      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
+          connection()->context().source_ssl_ctx()->get());
+      if (!pubkey_res) return send_client_failed(pubkey_res.error());
+
+      auto send_res =
+          Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
+      if (!send_res) return send_client_failed(send_res.error());
+
+      return Result::SendToClient;
+    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
+               connection_has_public_key(connection())) {
+      trace(Tracer::Event().stage("client::auth::encrypted:\n" +
+                                  hexify(src_protocol->auth_method_data())));
+
+      auto recv_res = Auth::rsa_decrypt_password(
+          connection()->context().source_ssl_ctx()->get(),
+          msg_res->auth_method_data(), src_protocol->auth_method_data());
+      if (!recv_res) return recv_client_failed(recv_res.error());
+
+      src_protocol->password(*recv_res);
+
+      trace(Tracer::Event().stage("client::auth::password\n" +
+                                  hexify(*src_protocol->password())));
+
+      discard_current_msg(src_channel, src_protocol);
+
+      if (dst_channel->ssl()) {
+        // the server-side is encrypted: send plaintext password
+        trace(Tracer::Event().stage("client::auth::plaintext_password"));
+
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        // the server is NOT encrypted: ask for the server's publickey
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    }
+  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
+    using Auth = AuthSha256Password;
+
+    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
+        connection_has_public_key(connection())) {
+      // if the client is not encrypted, it may ask for the server's public-key
+      // via 0x01
+      //
+      // if the server is encrypted, it doesn't expect that 0x01 and will treat
+      // it as plaintext password.
+
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("server::auth::public_key"));
+
+      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
+          connection()->context().source_ssl_ctx()->get());
+      if (!pubkey_res) return send_client_failed(pubkey_res.error());
+
+      auto send_res =
+          Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
+      if (!send_res) return send_client_failed(send_res.error());
+
+      return Result::SendToClient;
+    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
+               connection_has_public_key(connection())) {
+      auto recv_res = Auth::rsa_decrypt_password(
+          connection()->context().source_ssl_ctx()->get(),
+          msg_res->auth_method_data(), src_protocol->auth_method_data());
+      if (!recv_res) return recv_client_failed(recv_res.error());
+
+      src_protocol->password(*recv_res);
+
+      discard_current_msg(src_channel, src_protocol);
+
+      if (dst_channel->ssl()) {
+        trace(Tracer::Event().stage("client::auth::password"));
+        // the server-side is encrypted: send plaintext password
+        auto send_res = Auth::send_plaintext_password(
+            dst_channel, dst_protocol, *src_protocol->password());
+        if (!send_res) return send_server_failed(send_res.error());
+      } else {
+        // the server is NOT encrypted: ask for the server's public-key
+        trace(Tracer::Event().stage("client::auth::request_public_key"));
+        auto send_res =
+            Auth::send_public_key_request(dst_channel, dst_protocol);
+        if (!send_res) return send_server_failed(send_res.error());
+      }
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    }
+  }
+
+  stage(Stage::Response);
+  return forward_client_to_server();
+}
+
+/**
+ *
+ * server->router
+ */
+stdx::expected<Processor::Result, std::error_code>
+ServerFirstAuthenticator::auth_data() {
+  auto *socket_splicer = connection()->socket_splicer();
+  auto src_channel = socket_splicer->server_channel();
+  auto src_protocol = connection()->server_protocol();
+  auto dst_protocol = connection()->client_protocol();
+
+  auto msg_res =
+      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
+          src_channel, src_protocol);
+  if (!msg_res) return recv_server_failed(msg_res.error());
+
+  auto msg = std::move(*msg_res);
+
+  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
+    using Auth = AuthCachingSha2Password;
+
+    if (msg.auth_method_data().size() < 1) {
+      log_debug("%d", __LINE__);
+      return recv_server_failed(make_error_code(std::errc::bad_message));
+    }
+
+    if (dst_protocol->password().has_value()) {
+      // client's password is known.
+
+      auto opt_pwd = dst_protocol->password();
+
+      switch (msg.auth_method_data()[0]) {
+        case Auth::kFastAuthDone:
+          trace(Tracer::Event().stage("server::auth::fastauthdone"));
+          // 0x03 means the client-greeting provided the right scrambled
+          // password that matches the cached entry.
+
+          // as there is a password provided by the client via
+          // client_recv_plaintext_password() the client side expects either
+          // server::Ok or server::Error now.
+          //
+          // c<-r: server::greeting (from router)
+          // c->r: client::greeting (with tls handshake)
+          // c<-r: 0x01 0x04
+          // c->r: password
+          //    r->s: connect()
+          //    r<-s: server::greeting
+          //    r->s: client::greeting (with tls handshake, rehashed pwd)
+          //    r<-s: 0x01 0x03   // current message
+          //    r<-s: server::Ok
+          // c<-r: server::Ok
+          discard_current_msg(src_channel, src_protocol);
+
+          stage(Stage::Response);
+          return Result::Again;
+        case Auth::kPerformFullAuth: {
+          trace(Tracer::Event().stage("server::auth::request::plain"));
+
+          // as the client already provided a password, provide it to the
+          // server directly.
+          discard_current_msg(src_channel, src_protocol);
+
+          trace(Tracer::Event().stage("client::auth::plain"));
+
+          auto send_res = ClassicFrame::send_msg<
+              classic_protocol::message::client::AuthMethodData>(
+              src_channel, src_protocol, {*opt_pwd + "\0"s});
+          if (!send_res) return send_server_failed(send_res.error());
+
+          // send it to the server.
+          stage(Stage::Response);
+          return Result::SendToServer;
+        }
+        case '-': {
+          auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
+          if (!pubkey_res) return recv_server_failed(pubkey_res.error());
+
+          discard_current_msg(src_channel, src_protocol);
+
+          trace(Tracer::Event().stage("client::auth::password"));
+
+          auto encrypted_res = Auth::rsa_encrypt_password(
+              *pubkey_res, *(dst_protocol->password()),
+              src_protocol->auth_method_data());
+          if (!encrypted_res) return send_server_failed(encrypted_res.error());
+
+          auto send_res = Auth::send_encrypted_password(
+              src_channel, src_protocol, *encrypted_res);
+          if (!send_res) return send_server_failed(send_res.error());
+
+          stage(Stage::Response);
+          return Result::SendToServer;
+        }
+      }
+    } else {
+      // client's password is NOT known.
+      switch (msg.auth_method_data()[0]) {
+        case Auth::kFastAuthDone:
+          trace(Tracer::Event().stage("server::auth::fastauthdone"));
+
+          stage(Stage::Response);
+          return forward_server_to_client(true);  // followed by "Ok"
+        case Auth::kPerformFullAuth:
+          trace(Tracer::Event().stage("server::auth::request::plain"));
+
+          stage(Stage::ClientAuth);
+          return forward_server_to_client();
+        case '-':
+          trace(Tracer::Event().stage("server::auth::public_key"));
+
+          stage(Stage::ClientAuth);
+          return forward_server_to_client();
+      }
+    }
+  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
+    using Auth = AuthSha256Password;
+
+    if (dst_protocol->password().has_value()) {
+      auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
+      if (!pubkey_res) return recv_server_failed(pubkey_res.error());
+
+      discard_current_msg(src_channel, src_protocol);
+
+      trace(Tracer::Event().stage("client::auth::password"));
+
+      auto encrypted_res =
+          Auth::rsa_encrypt_password(*pubkey_res, *(dst_protocol->password()),
+                                     src_protocol->auth_method_data());
+      if (!encrypted_res) return send_server_failed(encrypted_res.error());
+
+      auto send_res = Auth::send_encrypted_password(src_channel, src_protocol,
+                                                    *encrypted_res);
+      if (!send_res) return send_server_failed(send_res.error());
+
+      stage(Stage::Response);
+      return Result::SendToServer;
+    }
+
+    stage(Stage::ClientAuth);
+    return forward_server_to_client();
+  }
+
+  log_debug("unexpected message from server at client::auth in %s\n%s",
+            src_protocol->auth_method_name().c_str(),
+            hexify(msg.auth_method_data()).c_str());
+
+  return recv_server_failed(make_error_code(std::errc::bad_message));
+}
diff --git a/router/src/routing/src/classic_greeting.h b/router/src/routing/src/classic_greeting.h
index 9c81624bd6d..88d9a2005d8 100644
--- a/router/src/routing/src/classic_greeting.h
+++ b/router/src/routing/src/classic_greeting.h
@@ -127,10 +127,12 @@ class ServerGreetor : public Processor {
     TlsConnectInit,
     TlsConnect,
     ClientGreetingAfterTls,
-    InitialResponse,
-    FinalResponse,
+    Response,
+    AuthMethodSwitch,
+    ClientAuth,
     AuthOk,
     AuthError,
+    AuthData,
 
     ServerGreetingSent,
     Error,
@@ -152,10 +154,12 @@ class ServerGreetor : public Processor {
   stdx::expected<Result, std::error_code> tls_connect_init();
   stdx::expected<Result, std::error_code> tls_connect();
   stdx::expected<Result, std::error_code> client_greeting_after_tls();
-  stdx::expected<Result, std::error_code> initial_response();
-  stdx::expected<Result, std::error_code> final_response();
+  stdx::expected<Result, std::error_code> response();
+  stdx::expected<Result, std::error_code> client_auth();
   stdx::expected<Result, std::error_code> auth_error();
   stdx::expected<Result, std::error_code> auth_ok();
+  stdx::expected<Result, std::error_code> auth_data();
+  stdx::expected<Result, std::error_code> auth_method_switch();
   stdx::expected<Result, std::error_code> error();
 
   void client_greeting_server_adjust_caps(ClassicProtocolState *src_protocol,
@@ -234,10 +238,12 @@ class ServerFirstAuthenticator : public Processor {
     TlsConnectInit,
     TlsConnect,
     ClientGreetingAfterTls,
-    InitialResponse,
-    FinalResponse,
+    Response,
+    AuthMethodSwitch,
+    ClientAuth,
     AuthOk,
     AuthError,
+    AuthData,
 
     Error,
     Ok,
@@ -257,10 +263,12 @@ class ServerFirstAuthenticator : public Processor {
   stdx::expected<Result, std::error_code> tls_connect_init();
   stdx::expected<Result, std::error_code> tls_connect();
   stdx::expected<Result, std::error_code> client_greeting_after_tls();
-  stdx::expected<Result, std::error_code> initial_response();
-  stdx::expected<Result, std::error_code> final_response();
+  stdx::expected<Result, std::error_code> response();
+  stdx::expected<Result, std::error_code> client_auth();
   stdx::expected<Result, std::error_code> auth_error();
   stdx::expected<Result, std::error_code> auth_ok();
+  stdx::expected<Result, std::error_code> auth_data();
+  stdx::expected<Result, std::error_code> auth_method_switch();
 
   void client_greeting_server_adjust_caps(ClassicProtocolState *src_protocol,
                                           ClassicProtocolState *dst_protocol);
-- 
2.37.2

