From fdb27f4dce47729dd2e773fb380bdebc71825069 Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:19:47 -0500
Subject: [PATCH 68/86] Revert "WL#12772 connection-sharing [9/28] -
 lazy-connect, greeting, query"

This reverts commit 8c244309a78c7ab48066f892d146e108b5ac423d.
---
 router/src/routing/src/CMakeLists.txt         |    7 -
 router/src/routing/src/classic_auth.cc        |  409 ---
 router/src/routing/src/classic_auth.h         |  149 -
 router/src/routing/src/classic_change_user.cc | 1060 ------
 router/src/routing/src/classic_change_user.h  |  107 -
 router/src/routing/src/classic_greeting.cc    | 3128 -----------------
 router/src/routing/src/classic_greeting.h     |  284 --
 router/src/routing/src/classic_init_schema.cc |  289 --
 router/src/routing/src/classic_init_schema.h  |   89 -
 .../src/routing/src/classic_lazy_connect.cc   |  215 --
 router/src/routing/src/classic_lazy_connect.h |   88 -
 router/src/routing/src/classic_query.cc       |  720 ----
 router/src/routing/src/classic_query.h        |  179 -
 .../routing/src/classic_reset_connection.cc   |  284 --
 .../routing/src/classic_reset_connection.h    |   82 -
 15 files changed, 7090 deletions(-)
 delete mode 100644 router/src/routing/src/classic_auth.cc
 delete mode 100644 router/src/routing/src/classic_auth.h
 delete mode 100644 router/src/routing/src/classic_change_user.cc
 delete mode 100644 router/src/routing/src/classic_change_user.h
 delete mode 100644 router/src/routing/src/classic_greeting.cc
 delete mode 100644 router/src/routing/src/classic_greeting.h
 delete mode 100644 router/src/routing/src/classic_init_schema.cc
 delete mode 100644 router/src/routing/src/classic_init_schema.h
 delete mode 100644 router/src/routing/src/classic_lazy_connect.cc
 delete mode 100644 router/src/routing/src/classic_lazy_connect.h
 delete mode 100644 router/src/routing/src/classic_query.cc
 delete mode 100644 router/src/routing/src/classic_query.h
 delete mode 100644 router/src/routing/src/classic_reset_connection.cc
 delete mode 100644 router/src/routing/src/classic_reset_connection.h

diff --git a/router/src/routing/src/CMakeLists.txt b/router/src/routing/src/CMakeLists.txt
index 477a4abf66b..7fcec33c3c5 100644
--- a/router/src/routing/src/CMakeLists.txt
+++ b/router/src/routing/src/CMakeLists.txt
@@ -46,16 +46,9 @@ ADD_LIBRARY(routing SHARED
   blocked_endpoints.cc
 
   processor.cc
-  classic_auth.cc
-  classic_change_user.cc
   classic_connect.cc
   classic_forwarder.cc
   classic_frame.cc
-  classic_greeting.cc
-  classic_init_schema.cc
-  classic_lazy_connect.cc
-  classic_query.cc
-  classic_reset_connection.cc
 
   sql_value.cc
 )
diff --git a/router/src/routing/src/classic_auth.cc b/router/src/routing/src/classic_auth.cc
deleted file mode 100644
index 33d3dc195d9..00000000000
--- a/router/src/routing/src/classic_auth.cc
+++ /dev/null
@@ -1,409 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_auth.h"
-
-#include <array>
-#include <memory>  // unique_ptr
-#include <system_error>
-
-#include <openssl/evp.h>
-#include <openssl/ssl.h>
-#include <openssl/x509.h>
-
-#include "auth_digest.h"
-#include "classic_frame.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysqlrouter/classic_protocol_wire.h"
-#include "openssl_version.h"
-
-template <>
-struct OsslDeleter<BIO> {
-  void operator()(BIO *b) { BIO_free_all(b); }
-};
-
-template <>
-struct OsslDeleter<EVP_PKEY_CTX> {
-  void operator()(EVP_PKEY_CTX *ctx) { EVP_PKEY_CTX_free(ctx); }
-};
-
-template <>
-struct OsslDeleter<X509> {
-  void operator()(X509 *x) { X509_free(x); }
-};
-
-#if OPENSSL_VERSION_NUMBER < ROUTER_OPENSSL_VERSION(1, 1, 0)
-template <>
-struct OsslDeleter<RSA> {
-  void operator()(RSA *rsa) { RSA_free(rsa); }
-};
-#endif
-
-using Bio = std::unique_ptr<BIO, OsslDeleter<BIO>>;
-using EvpPkey = std::unique_ptr<EVP_PKEY, OsslDeleter<EVP_PKEY>>;
-using X509_managed = std::unique_ptr<X509, OsslDeleter<X509>>;
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(3, 0, 0)
-using EvpPkeyCtx = std::unique_ptr<EVP_PKEY_CTX, OsslDeleter<EVP_PKEY_CTX>>;
-#endif
-#if OPENSSL_VERSION_NUMBER < ROUTER_OPENSSL_VERSION(1, 1, 0)
-using Rsa = std::unique_ptr<RSA, OsslDeleter<RSA>>;
-#endif
-
-stdx::expected<std::string, std::error_code>
-AuthBase::public_key_from_ssl_ctx_as_pem(SSL_CTX *ssl_ctx) {
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 1, 0)
-  const auto *pubkey = X509_get0_pubkey(SSL_CTX_get0_certificate(ssl_ctx));
-#elif OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
-  EvpPkey pubkey_managed(X509_get_pubkey(SSL_CTX_get0_certificate(ssl_ctx)));
-
-  const auto *pubkey = pubkey_managed.get();
-#endif
-  Bio bio{BIO_new(BIO_s_mem())};
-
-  PEM_write_bio_PUBKEY(bio.get(), const_cast<EVP_PKEY *>(pubkey));
-
-  char *data = nullptr;
-  auto data_len = BIO_get_mem_data(bio.get(), &data);
-
-  return {std::in_place, data, data + data_len};
-#else
-  // 1.0.1 has no SSL_CTX_get_certificate
-  (void)ssl_ctx;
-
-  return stdx::make_unexpected(
-      make_error_code(std::errc::function_not_supported));
-#endif
-}
-
-stdx::expected<EvpPkey, std::error_code> AuthBase::public_key_from_pem(
-    std::string_view pubkey) {
-  // openssl 1.0.1 needs to the const-cast.
-  Bio bio{BIO_new_mem_buf(const_cast<char *>(pubkey.data()), pubkey.size())};
-
-  EvpPkey pkey{PEM_read_bio_PUBKEY(bio.get(), nullptr, nullptr, nullptr)};
-  if (!pkey) {
-    return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-  }
-
-  return pkey;
-}
-
-stdx::expected<std::string, std::error_code> AuthBase::public_key_encrypt(
-    std::string plaintext, EVP_PKEY *pkey) {
-  std::string data;
-
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(3, 0, 0)
-  data.resize(EVP_PKEY_get_size(pkey));
-
-  EvpPkeyCtx key_ctx{EVP_PKEY_CTX_new(pkey, nullptr)};
-  EVP_PKEY_encrypt_init(key_ctx.get());
-  EVP_PKEY_CTX_set_rsa_padding(key_ctx.get(), RSA_PKCS1_OAEP_PADDING);
-
-  size_t encrypted_len;
-
-  EVP_PKEY_encrypt(key_ctx.get(),  //
-                   reinterpret_cast<unsigned char *>(data.data()),
-                   &encrypted_len,
-                   reinterpret_cast<const unsigned char *>(plaintext.data()),
-                   plaintext.size());
-#else
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 1, 0)
-  auto *rsa = EVP_PKEY_get0_RSA(pkey);
-#else
-  Rsa rsa_managed(EVP_PKEY_get1_RSA(pkey));
-  auto *rsa = rsa_managed.get();
-#endif
-  data.resize(RSA_size(rsa));
-
-  int encrypted_len = RSA_public_encrypt(
-      plaintext.size(), reinterpret_cast<unsigned char *>(plaintext.data()),
-      reinterpret_cast<unsigned char *>(data.data()), const_cast<RSA *>(rsa),
-      RSA_PKCS1_OAEP_PADDING);
-  if (encrypted_len == -1) {
-    return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-  }
-#endif
-
-  data.resize(encrypted_len);
-
-  return data;
-}
-
-stdx::expected<std::string, std::error_code> AuthBase::private_key_decrypt(
-    std::string_view ciphertext, EVP_PKEY *priv) {
-  if (ciphertext.empty()) {
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-
-  if (priv == nullptr) {
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-
-  std::array<unsigned char, 1024> plaintext;
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(3, 0, 0)
-  EvpPkeyCtx key_ctx{EVP_PKEY_CTX_new(priv, nullptr)};
-  {
-    auto init_res = EVP_PKEY_decrypt_init(key_ctx.get());
-    if (init_res != 1) {
-      return stdx::make_unexpected(
-          make_error_code(std::errc::invalid_argument));
-    }
-  }
-
-  {
-    auto padding_res =
-        EVP_PKEY_CTX_set_rsa_padding(key_ctx.get(), RSA_PKCS1_OAEP_PADDING);
-    if (padding_res != 1) {
-      return stdx::make_unexpected(
-          make_error_code(std::errc::invalid_argument));
-    }
-  }
-
-  size_t decrypted_len = plaintext.size();
-
-  {
-    const auto decrypt_res = EVP_PKEY_decrypt(
-        key_ctx.get(),                     //
-        plaintext.data(), &decrypted_len,  //
-        reinterpret_cast<const unsigned char *>(ciphertext.data()),
-        ciphertext.size());
-    if (decrypt_res != 1) {
-      switch (decrypt_res) {
-        case -2:
-          return stdx::make_unexpected(
-              make_error_code(std::errc::function_not_supported));
-        default:
-          return stdx::make_unexpected(
-              make_error_code(std::errc::invalid_argument));
-      }
-    }
-  }
-#else
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 1, 0)
-  auto *rsa = EVP_PKEY_get0_RSA(priv);
-#else
-  Rsa rsa_managed(EVP_PKEY_get1_RSA(priv));
-  auto *rsa = rsa_managed.get();
-#endif
-
-  // encrypted password
-  int decrypted_len = RSA_private_decrypt(
-      ciphertext.size(),
-      reinterpret_cast<const unsigned char *>(ciphertext.data()),
-      reinterpret_cast<unsigned char *>(plaintext.data()),
-      const_cast<RSA *>(rsa), RSA_PKCS1_OAEP_PADDING);
-  if (decrypted_len == -1) {
-    return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-  }
-#endif
-
-  return {std::in_place, plaintext.data(), plaintext.data() + decrypted_len};
-}
-
-// xor the plaintext password with the repeated scramble.
-static void xor_plaintext(std::string &plaintext, std::string_view pattern) {
-  for (size_t n = 0, p = 0; n < plaintext.size(); ++n, ++p) {
-    if (p == pattern.size()) p = 0;
-
-    plaintext[n] ^= pattern[p];
-  }
-}
-
-stdx::expected<std::string, std::error_code> AuthBase::rsa_decrypt_password(
-    SSL_CTX *ssl_ctx, std::string_view encrypted, std::string_view nonce) {
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
-  auto decrypted_res = AuthBase::private_key_decrypt(
-      encrypted, SSL_CTX_get0_privatekey(ssl_ctx));
-  if (!decrypted_res) return stdx::make_unexpected(decrypted_res.error());
-
-  auto plaintext = *decrypted_res;
-
-  xor_plaintext(plaintext, nonce);
-
-  if (plaintext.size() == 0 || plaintext.back() != '\0') {
-    // after decrypting and xor'ing the last byte should be a '\0'
-    return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-  }
-
-  // strip trailing \0
-  plaintext.resize(plaintext.size() - 1);
-
-  return plaintext;
-#else
-  (void)ssl_ctx;
-  (void)encrypted;
-  (void)nonce;
-
-  return stdx::make_unexpected(
-      make_error_code(std::errc::function_not_supported));
-#endif
-}
-
-stdx::expected<std::string, std::error_code> AuthBase::rsa_encrypt_password(
-    const EvpPkey &pkey, std::string_view password, std::string_view nonce) {
-  auto plaintext = std::string(password);
-  plaintext.push_back('\0');
-
-  if (nonce.empty()) {
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-  if (!pkey) {
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-
-  xor_plaintext(plaintext, nonce);
-
-  return AuthBase::public_key_encrypt(plaintext, pkey.get());
-}
-
-//  AuthCleartextPassword
-
-std::optional<std::string> AuthCleartextPassword::scramble(
-    [[maybe_unused]] std::string_view nonce, std::string_view pwd) {
-  std::string s(pwd);
-
-  s.push_back('\0');
-
-  return s;
-}
-
-// AuthNativePassword
-
-std::optional<std::string> AuthNativePassword::scramble(std::string_view nonce,
-                                                        std::string_view pwd) {
-  return mysql_native_password_scramble<std::string>(nonce, pwd);
-}
-
-// AuthCachingSha2Password
-
-std::optional<std::string> AuthCachingSha2Password::scramble(
-    std::string_view nonce, std::string_view pwd) {
-  return caching_sha2_password_scramble<std::string>(nonce, pwd);
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_public_key_request(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {std::string(kPublicKeyRequest)});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_public_key(Channel *dst_channel,
-                                         ClassicProtocolState *dst_protocol,
-                                         const std::string &public_key) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {public_key});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_plaintext_password_request(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::server::AuthMethodData>(
-      dst_channel, dst_protocol, {std::string(1, kPerformFullAuth)});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_plaintext_password(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    const std::string &password) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {password + '\0'});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthCachingSha2Password::send_encrypted_password(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    const std::string &encrypted) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {encrypted});
-}
-
-bool AuthCachingSha2Password::is_public_key_request(
-    const std::string_view &data) {
-  return data == kPublicKeyRequest;
-}
-
-bool AuthCachingSha2Password::is_public_key(const std::string_view &data) {
-  return data.size() == 256;
-}
-
-// AuthSha256Password
-
-std::optional<std::string> AuthSha256Password::scramble(
-    [[maybe_unused]] std::string_view nonce, std::string_view pwd) {
-  std::string s(pwd);
-
-  s.push_back('\0');
-
-  return s;
-}
-
-stdx::expected<size_t, std::error_code>
-AuthSha256Password::send_public_key_request(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {std::string(kPublicKeyRequest)});
-}
-
-stdx::expected<size_t, std::error_code> AuthSha256Password::send_public_key(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    const std::string &public_key) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {public_key});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthSha256Password::send_plaintext_password(Channel *dst_channel,
-                                            ClassicProtocolState *dst_protocol,
-                                            const std::string &password) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {password + '\0'});
-}
-
-stdx::expected<size_t, std::error_code>
-AuthSha256Password::send_encrypted_password(Channel *dst_channel,
-                                            ClassicProtocolState *dst_protocol,
-                                            const std::string &encrypted) {
-  return ClassicFrame::send_msg<
-      classic_protocol::message::client::AuthMethodData>(
-      dst_channel, dst_protocol, {encrypted});
-}
-
-bool AuthSha256Password::is_public_key_request(const std::string_view &data) {
-  return data == kPublicKeyRequest;
-}
-
-bool AuthSha256Password::is_public_key(const std::string_view &data) {
-  return data.size() == 256;
-}
diff --git a/router/src/routing/src/classic_auth.h b/router/src/routing/src/classic_auth.h
deleted file mode 100644
index 55c19de8bc5..00000000000
--- a/router/src/routing/src/classic_auth.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_AUTH_INCLUDED
-#define ROUTING_CLASSIC_AUTH_INCLUDED
-
-#include <memory>  // unique_ptr
-#include <string_view>
-#include <system_error>
-
-#include <openssl/ssl.h>
-
-#include "classic_connection.h"
-#include "mysql/harness/stdx/expected.h"
-
-template <class T>
-struct OsslDeleter;
-
-template <>
-struct OsslDeleter<EVP_PKEY> {
-  void operator()(EVP_PKEY *k) { EVP_PKEY_free(k); }
-};
-
-using EvpPkey = std::unique_ptr<EVP_PKEY, OsslDeleter<EVP_PKEY>>;
-
-class AuthBase {
- public:
-  static stdx::expected<std::string, std::error_code>
-  public_key_from_ssl_ctx_as_pem(SSL_CTX *ssl_ctx);
-
-  static stdx::expected<EvpPkey, std::error_code> public_key_from_pem(
-      std::string_view pubkey);
-
-  static stdx::expected<std::string, std::error_code> public_key_encrypt(
-      std::string plaintext, EVP_PKEY *pkey);
-
-  static stdx::expected<std::string, std::error_code> private_key_decrypt(
-      std::string_view ciphertext, EVP_PKEY *priv);
-
-  static stdx::expected<std::string, std::error_code> rsa_decrypt_password(
-      SSL_CTX *ssl_ctx, std::string_view encrypted, std::string_view nonce);
-
-  static stdx::expected<std::string, std::error_code> rsa_encrypt_password(
-      const EvpPkey &pkey, std::string_view password, std::string_view nonce);
-};
-
-class AuthNativePassword {
- public:
-  static constexpr const std::string_view kName{"mysql_native_password"};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-};
-
-class AuthCleartextPassword {
- public:
-  static constexpr const std::string_view kName{"mysql_clear_password"};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-};
-
-// low-level routings for caching_sha2_password
-class AuthCachingSha2Password : public AuthBase {
- public:
-  static constexpr const std::string_view kName{"caching_sha2_password"};
-
-  static constexpr const std::string_view kPublicKeyRequest{"\x02"};
-  static constexpr const uint8_t kFastAuthDone{0x03};
-  static constexpr const uint8_t kPerformFullAuth{0x04};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-
-  static stdx::expected<size_t, std::error_code> send_public_key_request(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol);
-
-  static stdx::expected<size_t, std::error_code> send_public_key(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &public_key);
-
-  static stdx::expected<size_t, std::error_code>
-  send_plaintext_password_request(Channel *dst_channel,
-                                  ClassicProtocolState *dst_protocol);
-
-  static stdx::expected<size_t, std::error_code> send_plaintext_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static stdx::expected<size_t, std::error_code> send_encrypted_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static bool is_public_key_request(const std::string_view &data);
-  static bool is_public_key(const std::string_view &data);
-};
-
-// low-level routings for sha256_password
-class AuthSha256Password : public AuthBase {
- public:
-  static constexpr const std::string_view kName{"sha256_password"};
-
-  static constexpr const std::string_view kEmptyPassword{"\x00", 1};
-  static constexpr const std::string_view kPublicKeyRequest{"\x01"};
-
-  static std::optional<std::string> scramble(std::string_view nonce,
-                                             std::string_view pwd);
-
-  static stdx::expected<size_t, std::error_code> send_public_key_request(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol);
-
-  static stdx::expected<size_t, std::error_code> send_public_key(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &public_key);
-
-  static stdx::expected<size_t, std::error_code> send_plaintext_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static stdx::expected<size_t, std::error_code> send_encrypted_password(
-      Channel *dst_channel, ClassicProtocolState *dst_protocol,
-      const std::string &password);
-
-  static bool is_public_key_request(const std::string_view &data);
-  static bool is_public_key(const std::string_view &data);
-};
-
-#endif
diff --git a/router/src/routing/src/classic_change_user.cc b/router/src/routing/src/classic_change_user.cc
deleted file mode 100644
index 8de69d1ce4a..00000000000
--- a/router/src/routing/src/classic_change_user.cc
+++ /dev/null
@@ -1,1060 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_change_user.h"
-
-#include <optional>
-
-#include <openssl/evp.h>
-
-#include "classic_auth.h"
-#include "classic_connect.h"
-#include "classic_connection.h"
-#include "classic_forwarder.h"
-#include "classic_frame.h"
-#include "classic_greeting.h"
-#include "classic_query.h"
-#include "hexify.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysql/harness/tls_error.h"
-#include "mysqld_error.h"  // mysql-server error-codes
-#include "openssl_version.h"
-#include "tracer.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-using mysql_harness::hexify;
-
-using namespace std::string_literals;
-using namespace std::string_view_literals;
-
-static bool connection_has_public_key(
-    MysqlRoutingClassicConnection *connection) {
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
-  if (!connection->context().source_ssl_ctx()) return false;
-
-  SSL_CTX *ssl_ctx = connection->context().source_ssl_ctx()->get();
-
-  return SSL_CTX_get0_certificate(ssl_ctx) != nullptr;
-#else
-  (void)connection;
-  return false;
-#endif
-}
-
-/**
- * forward the change-user message flow.
- *
- * Expected overall flow:
- *
- * @code
- * c->s: COM_CHANGE_USER
- * alt fast-path
- * alt
- * c<-s: Error
- * else
- * c<-s: Ok
- * end
- * else auth-method-switch
- * c<-s: auth-method-switch
- * c->s: auth-method-data
- * loop more data
- * c<-s: auth-method-data
- * opt
- * c->s: auth-method-data
- * end
- * end
- * alt
- * c<-s: Error
- * else
- * c<-s: Ok
- * end
- * end
- * @endcode
- *
- * If there is no server connection, it is created on demand.
- */
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserForwarder::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Connect:
-      return connect();
-    case Stage::Connected:
-      return connected();
-    case Stage::Response:
-      return response();
-    case Stage::Ok:
-      return ok();
-    case Stage::Error:
-      return error();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserForwarder::command() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::ChangeUser>(
-          src_channel, src_protocol, src_protocol->server_capabilities());
-  if (!msg_res) {
-    if (msg_res.error().category() ==
-        make_error_code(classic_protocol::codec_errc::invalid_input)
-            .category()) {
-      // a codec error.
-
-      discard_current_msg(src_channel, src_protocol);
-
-      auto send_res =
-          ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-              src_channel, src_protocol, {1047, "Unknown command", "08S01"});
-      if (!send_res) return send_client_failed(send_res.error());
-
-      stage(Stage::Done);
-      return Result::SendToClient;
-    }
-    return recv_client_failed(msg_res.error());
-  }
-
-  src_protocol->username(msg_res->username());
-  src_protocol->schema(msg_res->schema());
-  src_protocol->attributes(msg_res->attributes());
-  src_protocol->password(std::nullopt);
-  src_protocol->auth_method_name(msg_res->auth_method_name());
-
-  discard_current_msg(src_channel, src_protocol);
-
-  trace(Tracer::Event().stage("change_user::command"));
-
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  if (!server_conn.is_open()) {
-    stage(Stage::Connect);
-  } else {
-    // connection to the server exists, create a new ChangeUser command (don't
-    // forward the client's as is) as the attributes need to be modified.
-    connection()->push_processor(std::make_unique<ChangeUserSender>(
-        connection(), true /* in-handshake */));
-
-    stage(Stage::Response);
-  }
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserForwarder::connect() {
-  trace(Tracer::Event().stage("change_user::connect"));
-
-  stage(Stage::Connected);
-
-  // connect or take connection from pool
-  //
-  // don't use LazyConnector here as it would call authenticate with the old
-  // user and then switch to the new one in a 2nd ChangeUser.
-  connection()->push_processor(
-      std::make_unique<ConnectProcessor>(connection()));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserForwarder::connected() {
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  auto server_protocol = connection()->server_protocol();
-
-  if (!server_conn.is_open()) {
-    // Connector sent an server::Error already.
-    auto *socket_splicer = connection()->socket_splicer();
-    auto src_channel = socket_splicer->client_channel();
-    auto src_protocol = connection()->client_protocol();
-
-    // take the client::command from the connection.
-    auto recv_res =
-        ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-    if (!recv_res) return recv_client_failed(recv_res.error());
-
-    discard_current_msg(src_channel, src_protocol);
-
-    trace(Tracer::Event().stage("change_user::connect::error"));
-
-    stage(Stage::Done);
-    return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("change_user::connected"));
-
-  if (server_protocol->server_greeting()) {
-    // from pool.
-    connection()->push_processor(
-        std::make_unique<ChangeUserSender>(connection(), true));
-  } else {
-    // connector, but not greeted yet.
-    connection()->push_processor(
-        std::make_unique<ServerGreetor>(connection(), true));
-  }
-
-  stage(Stage::Response);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserForwarder::response() {
-  // ChangeUserSender will set ->authenticated if it succeed.
-  if (!connection()->authenticated()) {
-    stage(Stage::Error);
-  } else {
-    stage(Stage::Ok);
-  }
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> ChangeUserForwarder::ok() {
-  trace(Tracer::Event().stage("change_user::ok"));
-
-  // allow connection sharing again.
-  connection()->connection_sharing_allowed_reset();
-
-  // clear the warnings
-  connection()->execution_context().diagnostics_area().warnings().clear();
-
-  if (connection()->context().connection_sharing() &&
-      connection()->greeting_from_router()) {
-    // if connection sharing is enabled in the config, enable the
-    // session-tracker.
-    connection()->push_processor(std::make_unique<QuerySender>(connection(), R"(
-SET @@SESSION.session_track_schema           = 'ON',
-    @@SESSION.session_track_system_variables = '*',
-    @@SESSION.session_track_transaction_info = 'CHARACTERISTICS',
-    @@SESSION.session_track_gtids            = 'OWN_GTID',
-    @@SESSION.session_track_state_change     = 'ON')"));
-
-    stage(Stage::Done);
-  } else {
-    stage(Stage::Done);
-  }
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserForwarder::error() {
-  trace(Tracer::Event().stage("change_user::error"));
-
-  auto *socket_splicer = connection()->socket_splicer();
-
-  // after the error the server will close the server connection.
-  auto &server_conn = socket_splicer->server_conn();
-
-  (void)server_conn.close();
-
-  stage(Stage::Done);
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> ChangeUserSender::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Response:
-      return response();
-    case Stage::AuthMethodSwitch:
-      return auth_method_switch();
-    case Stage::ClientData:
-      return client_data();
-    case Stage::AuthResponse:
-      return auth_response();
-    case Stage::ServerData:
-      return server_data();
-    case Stage::Ok:
-      return ok();
-    case Stage::Error:
-      return error();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-/**
- * router specific connection attributes.
- *
- * @param[in] ssl pointer to a SSL struct of the client connection. May be
- * nullptr.
- */
-static std::vector<std::pair<std::string, std::string>>
-client_ssl_connection_attributes(const SSL *ssl) {
-  if (ssl == nullptr) return {};
-
-  return {{"_client_ssl_cipher", SSL_get_cipher_name(ssl)},
-          {"_client_ssl_version", SSL_get_version(ssl)}};
-}
-
-/**
- * splice two vectors together.
- *
- * appends all elements of other to the vector v.
- */
-template <class T>
-std::vector<T> vector_splice(std::vector<T> v, const std::vector<T> &other) {
-  v.insert(v.end(), other.begin(), other.end());
-  return v;
-}
-
-/**
- * verify connection attributes are sane.
- *
- * connection attributes are a key-value-key-value-...
- *
- * - decodes as var-string
- * - each key must have a value
- */
-static stdx::expected<void, std::error_code>
-classic_proto_verify_connection_attributes(const std::string &attrs) {
-  // track if each key has a matching value.
-  bool is_key{true};
-  auto attr_buf = net::buffer(attrs);
-
-  while (net::buffer_size(attr_buf) != 0) {
-    const auto decode_res =
-        classic_protocol::decode<classic_protocol::wire::VarString>(attr_buf,
-                                                                    {});
-    if (!decode_res) return decode_res.get_unexpected();
-
-    const auto bytes_read = decode_res->first;
-    const auto kv = decode_res->second;
-
-    attr_buf += bytes_read;
-
-    // toggle the key/value tracker.
-    is_key = !is_key;
-  }
-
-  // if the last key doesn't have a value, fail
-  if (!is_key || net::buffer_size(attr_buf) != 0) {
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-
-  return {};
-}
-
-static stdx::expected<size_t, std::error_code> classic_proto_append_attribute(
-    std::string &attrs_buf, const std::string &key, const std::string &value) {
-  auto encode_res =
-      classic_protocol::encode(classic_protocol::wire::VarString(key), {},
-                               net::dynamic_buffer(attrs_buf));
-  if (!encode_res) {
-    return encode_res.get_unexpected();
-  }
-
-  size_t encoded_bytes = encode_res.value();
-
-  encode_res =
-      classic_protocol::encode(classic_protocol::wire::VarString(value), {},
-                               net::dynamic_buffer(attrs_buf));
-  if (!encode_res) {
-    return encode_res.get_unexpected();
-  }
-
-  encoded_bytes += encode_res.value();
-
-  return encoded_bytes;
-}
-
-/**
- * remove trailing \0 in a string_view.
- *
- * returns the original string-view, if there is no trailing NUL-char.
- */
-static auto strip_trailing_null(std::string_view s) {
-  if (s.empty()) return s;
-
-  if (s.back() == '\0') s.remove_suffix(1);
-
-  return s;
-}
-
-/**
- * merge connection attributes.
- *
- * - verifies the connection attributes
- * - appends new attributes.
- * - sets attributes back to the client-greeting-msg
- *
- * @returns bytes appended on success, std::error_code on error.
- */
-static stdx::expected<std::string, std::error_code>
-classic_proto_decode_and_add_connection_attributes(
-    std::string attrs,
-    const std::vector<std::pair<std::string, std::string>> &extra_attributes) {
-  // add attributes if they are sane.
-  const auto verify_res = classic_proto_verify_connection_attributes(attrs);
-  if (!verify_res) return verify_res.get_unexpected();
-
-  for (const auto &attr : extra_attributes) {
-    const auto append_res =
-        classic_proto_append_attribute(attrs, attr.first, attr.second);
-    if (!append_res) return append_res.get_unexpected();
-  }
-
-  return {attrs};
-}
-
-static std::optional<std::string> scramble_them_all(
-    std::string_view auth_method, std::string_view nonce,
-    std::string_view pwd) {
-  if (auth_method == AuthCachingSha2Password::kName) {
-    return AuthCachingSha2Password::scramble(nonce, pwd);
-  } else if (auth_method == AuthNativePassword::kName) {
-    return AuthNativePassword::scramble(nonce, pwd);
-  } else if (auth_method == AuthSha256Password::kName) {
-    return AuthSha256Password::scramble(nonce, pwd);
-  } else if (auth_method == AuthCleartextPassword::kName) {
-    return AuthCleartextPassword::scramble(nonce, pwd);
-  } else {
-    return std::nullopt;
-  }
-}
-
-static classic_protocol::message::client::ChangeUser change_user_for_reuse(
-    Channel *src_channel, ClassicProtocolState *src_protocol,
-    [[maybe_unused]] ClassicProtocolState *dst_protocol,
-    std::vector<std::pair<std::string, std::string>>
-        initial_connection_attributes) {
-  harness_assert(src_protocol->client_greeting().has_value());
-  harness_assert(dst_protocol->server_greeting().has_value());
-
-  const auto append_attrs_res =
-      classic_proto_decode_and_add_connection_attributes(
-          src_protocol->attributes(),
-          vector_splice(initial_connection_attributes,
-                        client_ssl_connection_attributes(src_channel->ssl())));
-  // if decode/append fails forward the attributes as is. The server should
-  // fail too.
-  auto attrs = append_attrs_res.value_or(src_protocol->attributes());
-
-  if (src_protocol->password().has_value()) {
-    // scramble with the server's auth-data to trigger a fast-auth.
-
-    auto pwd = *(src_protocol->password());
-
-    // if the password set and not empty, rehash it.
-    if (auto scramble_res = scramble_them_all(
-            src_protocol->auth_method_name(),
-            strip_trailing_null(dst_protocol->auth_method_data()), pwd)) {
-      return {
-          src_protocol->username(),                      // username
-          *scramble_res,                                 // auth_method_data
-          src_protocol->schema(),                        // schema
-          src_protocol->client_greeting()->collation(),  // collation
-          src_protocol->auth_method_name(),              // auth_method_name
-          attrs,                                         // attributes
-      };
-    }
-  }
-
-  return {
-      src_protocol->username(),                      // username
-      "",                                            // auth_method_data
-      src_protocol->schema(),                        // schema
-      src_protocol->client_greeting()->collation(),  // collation
-      "switch_me_if_you_can",                        // auth_method_name
-      attrs,                                         // attributes
-  };
-}
-
-stdx::expected<Processor::Result, std::error_code> ChangeUserSender::command() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto &src_conn = socket_splicer->client_conn();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  change_user_msg_ =
-      change_user_for_reuse(src_channel, src_protocol, dst_protocol,
-                            src_conn.initial_connection_attributes());
-#if 0
-  std::cerr << __LINE__ << ": username: " << change_user_msg_->username()
-            << "\n"
-            << ".. schema: " << change_user_msg_->schema() << "\n"
-            << ".. auth-method-name: " << change_user_msg_->auth_method_name()
-            << "\n"
-            << ".. auth-method-data: "
-            << hexify(change_user_msg_->auth_method_data()) << "\n"
-      //
-      ;
-#endif
-
-  trace(Tracer::Event().stage("change_user::command"));
-
-  dst_protocol->seq_id(0xff);  // reset seq-id
-
-  auto send_res =
-      ClassicFrame::send_msg(dst_channel, dst_protocol, *change_user_msg_);
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserSender::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    AuthMethodSwitch = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodSwitch>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthMethodSwitch:
-      stage(Stage::AuthMethodSwitch);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("change_user::response"));
-
-  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserSender::auth_method_switch() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-  auto dst_protocol = connection()->client_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(src_channel,
-                                                           src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  trace(Tracer::Event().stage("change_user::auth_method_switch: " +
-                              msg.auth_method()));
-
-  src_protocol->auth_method_name(msg.auth_method());
-  src_protocol->auth_method_data(msg.auth_method_data());
-  dst_protocol->auth_method_name(msg.auth_method());
-  dst_protocol->auth_method_data(msg.auth_method_data());
-
-  if (dst_protocol->password().has_value()) {
-    auto pwd = *(dst_protocol->password());
-
-    discard_current_msg(src_channel, src_protocol);
-
-    if (!src_channel->ssl() && !pwd.empty() &&
-        dst_protocol->auth_method_name() == AuthSha256Password::kName) {
-      // the server channel isn't encrypted, request the public-key.
-
-      auto send_res = AuthSha256Password::send_public_key_request(src_channel,
-                                                                  src_protocol);
-
-      if (!send_res) return send_server_failed(send_res.error());
-    } else {
-      trace(Tracer::Event().stage("change_user::client_data"));
-
-      auto scramble_res = scramble_them_all(
-          msg.auth_method(), strip_trailing_null(msg.auth_method_data()), pwd);
-
-      if (!scramble_res) {
-        return recv_server_failed(make_error_code(std::errc::bad_message));
-      }
-
-      auto send_res = ClassicFrame::send_msg<classic_protocol::wire::String>(
-          src_channel, src_protocol, {*scramble_res});
-      if (!send_res) return send_server_failed(send_res.error());
-    }
-
-    stage(Stage::AuthResponse);
-    return Result::SendToServer;
-  } else {
-    stage(Stage::ClientData);
-    return forward_server_to_client();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserSender::client_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-  auto *dst_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("change_user::client_data:\n" +
-                              hexify(msg_res->auth_method_data())));
-
-  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
-    using Auth = AuthCachingSha2Password;
-
-    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
-        connection_has_public_key(connection())) {
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("server::auth::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) {
-        auto ec = pubkey_res.error();
-
-        if (ec != std::errc::function_not_supported) {
-          return send_client_failed(ec);
-        }
-
-        // couldn't get the public key, fail the auth.
-        auto send_res =
-            ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-                src_channel, src_protocol,
-                {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
-        if (!send_res) return send_client_failed(send_res.error());
-      } else {
-        auto send_res =
-            Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-        if (!send_res) return send_client_failed(send_res.error());
-      }
-
-      return Result::SendToClient;
-    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
-               connection_has_public_key(connection())) {
-      auto recv_res = Auth::rsa_decrypt_password(
-          connection()->context().source_ssl_ctx()->get(),
-          msg_res->auth_method_data(), src_protocol->auth_method_data());
-      if (!recv_res) return recv_client_failed(recv_res.error());
-
-      src_protocol->password(*recv_res);
-
-      trace(Tracer::Event().stage("change_user::password"));
-
-      discard_current_msg(src_channel, src_protocol);
-
-      if (dst_channel->ssl()) {
-        // the server-side is encrypted: send plaintext password
-        trace(Tracer::Event().stage("change_user::plaintext_password"));
-
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        // the server is NOT encrypted: ask for the server's publickey
-        trace(Tracer::Event().stage("change_user::request_public_key"));
-
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::AuthResponse);
-      return Result::SendToServer;
-    } else if (src_channel->ssl() && msg_res->auth_method_data().size() == 32) {
-      // try fast auth first.
-
-      stage(Stage::AuthResponse);
-      return forward_client_to_server();
-    } else if (src_channel->ssl()) {
-      discard_current_msg(src_channel, src_protocol);
-
-      auto pwd = msg_res->auth_method_data();
-      pwd.resize(pwd.size() - 1);
-
-      // the plaintext password.
-      src_protocol->password(pwd);
-
-      if (dst_channel->ssl() || pwd.empty()) {
-        trace(Tracer::Event().stage("client::auth::plaintext_password"));
-        // the server-side is encrypted: send plaintext password with trailing
-        // \0
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-        // the server is NOT encrypted: ask for the server's publickey
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::AuthResponse);
-      return Result::SendToServer;
-    }
-  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
-    using Auth = AuthSha256Password;
-
-    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
-        connection_has_public_key(connection())) {
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("server::auth::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) return send_client_failed(pubkey_res.error());
-
-      auto send_res =
-          Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-      if (!send_res) return send_client_failed(send_res.error());
-
-      return Result::SendToClient;
-    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
-               connection()->context().source_ssl_ctx()) {
-      auto recv_res = Auth::rsa_decrypt_password(
-          connection()->context().source_ssl_ctx()->get(),
-          msg_res->auth_method_data(), src_protocol->auth_method_data());
-      if (!recv_res) return recv_client_failed(recv_res.error());
-
-      src_protocol->password(*recv_res);
-
-      discard_current_msg(src_channel, src_protocol);
-
-      if (dst_channel->ssl()) {
-        trace(Tracer::Event().stage("client::auth_data::password"));
-        // the server-side is encrypted: send plaintext password
-
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        // the server is NOT encrypted: ask for the server's public-key
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::AuthResponse);
-      return Result::SendToServer;
-    } else if (src_channel->ssl()) {
-      discard_current_msg(src_channel, src_protocol);
-      auto pwd = msg_res->auth_method_data();
-      pwd.resize(pwd.size() - 1);
-
-      // the plaintext password.
-      src_protocol->password(pwd);
-
-      if (dst_channel->ssl() || pwd.empty()) {
-        trace(Tracer::Event().stage("client::auth_data::password"));
-        // the server-side is encrypted (or the password is empty)
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        // the server is NOT encrypted: ask for the server's public-key
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::AuthResponse);
-      return Result::SendToServer;
-    }
-  }
-
-  stage(Stage::AuthResponse);
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserSender::auth_response() {
-  // ERR|OK|data
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    AuthData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::AuthData:
-      stage(Stage::ServerData);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("change_user::auth::response"));
-
-  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-}
-
-/**
- * receive auth-data from the server handle it.
- */
-stdx::expected<Processor::Result, std::error_code>
-ChangeUserSender::server_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-  auto dst_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
-    using Auth = AuthCachingSha2Password;
-
-    // if ensure_has_full_frame fails, we'll fail later with bad_message.
-
-    if (msg.auth_method_data().size() < 1) {
-      return recv_server_failed(make_error_code(std::errc::bad_message));
-    }
-
-    switch (msg.auth_method_data()[0]) {
-      case Auth::kFastAuthDone:
-        trace(Tracer::Event().stage("change_user::auth::fast-auth-ok"));
-
-        stage(Stage::AuthResponse);
-
-        // fast-auth-ok is followed by Ok
-        if (dst_protocol->password().has_value()) {
-          // as the client provided a password already, it expects a Ok next.
-          discard_current_msg(src_channel, src_protocol);
-
-          return Result::Again;
-        } else {
-          // client provided a hash and expects the 0x03 and OK.
-          return forward_server_to_client(true /* noflush */);
-        }
-      case Auth::kPerformFullAuth:
-        trace(Tracer::Event().stage("change_user::auth::full-auth"));
-
-        if (dst_protocol->password().has_value()) {
-          auto opt_pwd = dst_protocol->password();
-
-          discard_current_msg(src_channel, src_protocol);
-
-          if (!src_channel->ssl()) {
-            // the server is NOT encrypted: ask for the server's publickey
-            trace(
-                Tracer::Event().stage("change_user::auth::request_public_key"));
-            auto send_res =
-                Auth::send_public_key_request(src_channel, src_protocol);
-            if (!send_res) return send_server_failed(send_res.error());
-          } else {
-            trace(
-                Tracer::Event().stage("change_user::auth::plaintext_password"));
-            auto send_res = Auth::send_plaintext_password(
-                src_channel, src_protocol, *opt_pwd);
-            if (!send_res) return send_server_failed(send_res.error());
-          }
-
-          // send it to the server.
-          stage(Stage::AuthResponse);
-          return Result::SendToServer;
-        } else {
-          // forward request for full auth to the client.
-          stage(Stage::ClientData);
-
-          return forward_server_to_client();
-        }
-      case '-': {
-        trace(Tracer::Event().stage("change_user::auth::public_key"));
-
-        if (dst_protocol->password().has_value()) {
-          // the client's password is known: answer the server directly.
-          auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-          if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-          discard_current_msg(src_channel, src_protocol);
-
-          trace(Tracer::Event().stage("client::auth::password"));
-
-          auto encrypted_res = Auth::rsa_encrypt_password(
-              *pubkey_res, *(dst_protocol->password()),
-              src_protocol->auth_method_data());
-          if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-          auto send_res = Auth::send_encrypted_password(
-              src_channel, src_protocol, *encrypted_res);
-          if (!send_res) return send_server_failed(send_res.error());
-
-          stage(Stage::Response);
-          return Result::SendToServer;
-        } else {
-          // ... otherwise forward the public-key to the client and send its
-          // encrypted password.
-          stage(Stage::ClientData);
-
-          return forward_server_to_client();
-        }
-      }
-    }
-  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
-    using Auth = AuthSha256Password;
-    // public key
-    trace(Tracer::Event().stage("server::auth::public-key"));
-
-    if (dst_protocol->password().has_value()) {
-      // the client's password is known: answer the server directly.
-      auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-      if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("client::auth::password"));
-
-      auto encrypted_res =
-          Auth::rsa_encrypt_password(*pubkey_res, *(dst_protocol->password()),
-                                     src_protocol->auth_method_data());
-      if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-      auto send_res = Auth::send_encrypted_password(src_channel, src_protocol,
-                                                    *encrypted_res);
-      if (!send_res) return send_server_failed(send_res.error());
-
-      stage(Stage::AuthResponse);
-      return Result::SendToServer;
-    } else {
-      // ... otherwise forward the public-key to the client and send its
-      // encrypted password.
-      stage(Stage::ClientData);
-
-      return forward_server_to_client();
-    }
-  }
-
-  log_debug("change_user::auth::data: %s",
-            hexify(msg.auth_method_data()).c_str());
-
-  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> ChangeUserSender::ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-  auto dst_protocol = connection()->client_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("change_user::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  connection()->authenticated(true);
-
-  src_protocol->username(change_user_msg_->username());
-  dst_protocol->username(change_user_msg_->username());
-  src_protocol->schema(change_user_msg_->schema());
-  dst_protocol->schema(change_user_msg_->schema());
-  src_protocol->sent_attributes(change_user_msg_->attributes());
-  dst_protocol->sent_attributes(change_user_msg_->attributes());
-
-  stage(Stage::Done);
-  if (in_handshake_) {
-    return forward_server_to_client();
-  } else {
-    discard_current_msg(src_channel, src_protocol);
-    return Result::Again;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> ChangeUserSender::error() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::Error>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("change_user::error: " + msg_res->message()));
-
-  connection()->authenticated(false);
-
-  stage(Stage::Done);
-  if (in_handshake_) {
-    // forward the error to the client.
-    return forward_server_to_client();
-  } else {
-    discard_current_msg(src_channel, src_protocol);
-    return Result::Again;
-  }
-}
diff --git a/router/src/routing/src/classic_change_user.h b/router/src/routing/src/classic_change_user.h
deleted file mode 100644
index 2fda7f28d0a..00000000000
--- a/router/src/routing/src/classic_change_user.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_CHANGE_USER_INCLUDED
-#define ROUTING_CLASSIC_CHANGE_USER_INCLUDED
-
-#include "processor.h"
-
-/**
- * forwards COM_CHANGE_USER from client to the server.
- */
-class ChangeUserForwarder : public Processor {
- public:
-  using Processor::Processor;
-
-  enum class Stage {
-    Command,
-    Connect,
-    Connected,
-    Response,
-    Ok,
-    Error,
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> connect();
-  stdx::expected<Result, std::error_code> connected();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> ok();
-  stdx::expected<Result, std::error_code> error();
-
-  Stage stage_{Stage::Command};
-};
-
-/**
- * sends COM_CHANGE_USER from router to the server.
- */
-class ChangeUserSender : public Processor {
- public:
-  using Processor::Processor;
-
-  ChangeUserSender(MysqlRoutingClassicConnection *conn, bool in_handshake)
-      : Processor(conn), in_handshake_{in_handshake} {}
-
-  enum class Stage {
-    Command,
-    Response,
-    AuthMethodSwitch,
-    ClientData,
-    AuthResponse,
-    ServerData,
-    Ok,
-    Error,
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> auth_method_switch();
-  stdx::expected<Result, std::error_code> client_data();
-  stdx::expected<Result, std::error_code> auth_response();
-  stdx::expected<Result, std::error_code> server_data();
-  stdx::expected<Result, std::error_code> ok();
-  stdx::expected<Result, std::error_code> error();
-
-  Stage stage_{Stage::Command};
-
-  bool in_handshake_{false};
-
-  std::optional<classic_protocol::message::client::ChangeUser> change_user_msg_;
-};
-
-#endif
diff --git a/router/src/routing/src/classic_greeting.cc b/router/src/routing/src/classic_greeting.cc
deleted file mode 100644
index cca2d6dd701..00000000000
--- a/router/src/routing/src/classic_greeting.cc
+++ /dev/null
@@ -1,3128 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_greeting.h"
-
-#include <cctype>
-#include <iostream>
-#include <random>  // uniform_int_distribution
-#include <system_error>
-
-#include "classic_auth.h"
-#include "classic_change_user.h"
-#include "classic_connect.h"
-#include "classic_connection.h"
-#include "classic_forwarder.h"
-#include "classic_frame.h"
-#include "classic_lazy_connect.h"
-#include "harness_assert.h"
-#include "hexify.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/net_ts/socket.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysql/harness/tls_error.h"
-#include "mysqld_error.h"  // mysql-server error-codes
-#include "mysqlrouter/classic_protocol_constants.h"
-#include "mysqlrouter/connection_base.h"
-#include "openssl_version.h"
-#include "processor.h"
-#include "tracer.h"
-
-using namespace std::string_literals;
-
-IMPORT_LOG_FUNCTIONS()
-
-using mysql_harness::hexify;
-
-using namespace std::string_view_literals;
-
-static constexpr const std::array supported_authentication_methods{
-    AuthCachingSha2Password::kName,
-    AuthNativePassword::kName,
-    AuthCleartextPassword::kName,
-    AuthSha256Password::kName,
-};
-
-static constexpr const bool kCapturePlaintextPassword{true};
-
-/**
- * router specific connection attributes.
- *
- * @param[in] ssl pointer to a SSL struct of the client connection. May be
- * nullptr.
- */
-static std::vector<std::pair<std::string, std::string>>
-client_ssl_connection_attributes(const SSL *ssl) {
-  if (ssl == nullptr) return {};
-
-  return {{"_client_ssl_cipher", SSL_get_cipher_name(ssl)},
-          {"_client_ssl_version", SSL_get_version(ssl)}};
-}
-
-/**
- * splice two vectors together.
- *
- * appends all elements of other to the vector v.
- */
-template <class T>
-std::vector<T> vector_splice(std::vector<T> v, const std::vector<T> &other) {
-  v.insert(v.end(), other.begin(), other.end());
-  return v;
-}
-
-static std::optional<std::string> scramble_them_all(
-    std::string_view auth_method, std::string_view nonce,
-    std::string_view pwd) {
-  if (auth_method == AuthCachingSha2Password::kName) {
-    return AuthCachingSha2Password::scramble(nonce, pwd);
-  } else if (auth_method == AuthNativePassword::kName) {
-    return AuthNativePassword::scramble(nonce, pwd);
-  } else if (auth_method == AuthSha256Password::kName) {
-    return AuthSha256Password::scramble(nonce, pwd);
-  } else if (auth_method == AuthCleartextPassword::kName) {
-    return AuthCleartextPassword::scramble(nonce, pwd);
-  } else {
-    return std::nullopt;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> ClientGreetor::process() {
-  switch (stage()) {
-    case Stage::Init:
-      return init();
-    case Stage::ServerGreeting:
-      return server_greeting();
-    case Stage::ServerFirstGreeting:
-      return server_first_greeting();
-    case Stage::ClientGreeting:
-      return client_greeting();
-    case Stage::TlsAcceptInit:
-      return tls_accept_init();
-    case Stage::TlsAccept:
-      return tls_accept();
-    case Stage::ClientGreetingAfterTls:
-      return client_greeting_after_tls();
-    case Stage::RequestPlaintextPassword:
-      return request_plaintext_password();
-    case Stage::PlaintextPassword:
-      return plaintext_password();
-
-    case Stage::Accepted:
-      return accepted();
-
-    case Stage::Authenticated:
-      return authenticated();
-
-      // the two exit-stages:
-      // - Error
-      // - Ok
-    case Stage::Error:
-      return error();
-    case Stage::Ok:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> ClientGreetor::error() {
-  // after the greetings error has been sent to the client.
-  trace(Tracer::Event().stage("client::greeting::error"));
-
-  auto &client_conn = connection()->socket_splicer()->client_conn();
-
-  (void)client_conn.cancel();
-  (void)client_conn.shutdown(net::socket_base::shutdown_both);
-
-  return Result::Done;
-}
-
-stdx::expected<Processor::Result, std::error_code> ClientGreetor::init() {
-  trace(Tracer::Event().stage("client::init"));
-
-  if (!connection()->greeting_from_router()) {
-    stage(Stage::ServerFirstGreeting);
-
-    connection()->push_processor(
-        std::make_unique<ServerFirstConnector>(connection()));
-  } else {
-    stage(Stage::ServerGreeting);
-  }
-  return Result::Again;
-}
-
-/**
- * client<-router: server::greeting.
- */
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::server_greeting() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  classic_protocol::capabilities::value_type router_capabilities(
-      classic_protocol::capabilities::long_password |
-      classic_protocol::capabilities::found_rows |
-      classic_protocol::capabilities::long_flag |
-      classic_protocol::capabilities::connect_with_schema |
-      classic_protocol::capabilities::no_schema |
-      // compress (not yet)
-      classic_protocol::capabilities::odbc |
-      classic_protocol::capabilities::local_files |
-      // ignore_space (client only)
-      classic_protocol::capabilities::protocol_41 |
-      classic_protocol::capabilities::interactive |
-      // ssl (below)
-      // ignore sigpipe (client-only)
-      classic_protocol::capabilities::transactions |
-      classic_protocol::capabilities::secure_connection |
-      classic_protocol::capabilities::multi_statements |
-      classic_protocol::capabilities::multi_results |
-      classic_protocol::capabilities::ps_multi_results |
-      classic_protocol::capabilities::plugin_auth |
-      classic_protocol::capabilities::connect_attributes |
-      classic_protocol::capabilities::client_auth_method_data_varint |
-      classic_protocol::capabilities::expired_passwords |
-      classic_protocol::capabilities::session_track |
-      classic_protocol::capabilities::text_result_with_session_tracking |
-      classic_protocol::capabilities::optional_resultset_metadata
-      // compress_zstd (not yet)
-  );
-
-  if (connection()->source_ssl_mode() != SslMode::kDisabled) {
-    router_capabilities.set(classic_protocol::capabilities::pos::ssl);
-  }
-
-  dst_protocol->server_capabilities(router_capabilities);
-
-  auto random_auth_method_data = []() {
-    std::random_device rd;
-    std::mt19937 gen(rd());
-    // 1..255 ... no \0 chars
-    std::uniform_int_distribution<> distrib(1, 255);
-
-    std::string scramble;
-    scramble.resize(20 + 1);  // 20 random data + [trailing, explicit \0]
-
-    for (size_t n{}; n < scramble.size() - 1; ++n) {
-      scramble[n] = distrib(gen);
-    }
-
-    return scramble;
-  };
-
-  auto server_greeting_version = []() {
-    using namespace std::string_literals;
-
-    return MYSQL_ROUTER_VERSION "-router"s;
-  };
-
-  classic_protocol::message::server::Greeting server_greeting_msg{
-      10,                                           // protocol
-      server_greeting_version(),                    // version
-      0,                                            // connection-id
-      random_auth_method_data(),                    // auth-method-data
-      dst_protocol->server_capabilities(),          // server-caps
-      255,                                          // 8.0.20 sends 0xff here
-      classic_protocol::status::autocommit,         // status-flags
-      std::string(AuthCachingSha2Password::kName),  // auth-method-name
-  };
-
-  auto send_res =
-      ClassicFrame::send_msg(dst_channel, dst_protocol, server_greeting_msg,
-                             {/* no shared caps yet */});
-  if (!send_res) return send_client_failed(send_res.error());
-
-  trace(Tracer::Event().stage("server::greeting"));
-
-  dst_protocol->auth_method_data(server_greeting_msg.auth_method_data());
-  dst_protocol->server_greeting(server_greeting_msg);
-
-  stage(Stage::ClientGreeting);
-  return Result::SendToClient;
-}
-
-/**
- * client<-router: server::greeting.
- */
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::server_first_greeting() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  // ServerFirstGreetor either
-  // - sent the server-greeting to the client and
-  //   left the server connection open, or
-  // - sent the error to the client and
-  //   closed the connection.
-
-  auto &server_conn = socket_splicer->server_conn();
-
-  if (server_conn.is_open()) {
-    stage(Stage::ClientGreeting);
-  } else {
-    stage(Stage::Error);
-  }
-
-  return Result::Again;
-}
-
-static void adjust_supported_capabilities(
-    SslMode source_ssl_mode, SslMode dest_ssl_mode,
-    classic_protocol::capabilities::value_type &caps) {
-  // don't modify caps on passthrough.
-  if (source_ssl_mode == SslMode::kPassthrough) return;
-
-  // disable compression as we don't support it yet.
-  caps.reset(classic_protocol::capabilities::pos::compress);
-  caps.reset(classic_protocol::capabilities::pos::compress_zstd);
-  caps.reset(classic_protocol::capabilities::pos::query_attributes);
-
-  switch (source_ssl_mode) {
-    case SslMode::kDisabled:
-      // server supports SSL, but client should be forced to be unencrypted.
-      //
-      // disabling will pretend the server doesn't speak SSL
-      //
-      // if the client uses SslMode::kPreferred or kDisabled, it will use an
-      // unencrypted connection otherwise it will abort the connection.
-      caps.reset(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kRequired:
-      // config requires: client MUST be encrypted.
-      //
-      // if the server hasn't set it yet, set it.
-      caps.set(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kPreferred:
-      // force-set the ssl-cap for the client-side only if we later don't have
-      // to use AS_CLIENT when speaking to a non-TLS server.
-      if (dest_ssl_mode != SslMode::kAsClient) {
-        caps.set(classic_protocol::capabilities::pos::ssl);
-      }
-      break;
-    default:
-      break;
-  }
-}
-
-static bool client_ssl_mode_is_satisfied(
-    SslMode client_ssl_mode,
-    classic_protocol::capabilities::value_type shared_capabilities) {
-  if ((client_ssl_mode == SslMode::kRequired) &&
-      !shared_capabilities.test(classic_protocol::capabilities::pos::ssl)) {
-    return false;
-  }
-
-  return true;
-}
-
-static stdx::expected<size_t, std::error_code> send_ssl_connection_error_msg(
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    const std::string &msg) {
-  return ClassicFrame::send_msg(
-      dst_channel, dst_protocol,
-      classic_protocol::message::server::Error{CR_SSL_CONNECTION_ERROR, msg});
-}
-
-/**
- * handle client greeting.
- */
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::client_greeting() {
-  auto *src_channel = connection()->socket_splicer()->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::Greeting>(
-          src_channel, src_protocol, src_protocol->server_capabilities());
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  if (src_protocol->seq_id() != 1) {
-    // client-greeting has seq-id 1
-    return recv_client_failed(make_error_code(std::errc::bad_message));
-  }
-
-  trace(Tracer::Event().stage("client::greeting"));
-
-  src_protocol->client_greeting(msg);
-  src_protocol->client_capabilities(msg.capabilities());
-  src_protocol->auth_method_name(msg.auth_method_name());
-  src_protocol->username(msg.username());
-  src_protocol->schema(msg.schema());
-  src_protocol->attributes(msg.attributes());
-
-  if (!client_ssl_mode_is_satisfied(connection()->source_ssl_mode(),
-                                    src_protocol->shared_capabilities())) {
-    // config says: client->router MUST be encrypted, but client didn't set
-    // the SSL cap.
-    //
-    const auto send_res = send_ssl_connection_error_msg(
-        src_channel, src_protocol,
-        "SSL connection error: SSL is required from client");
-    if (!send_res) return send_client_failed(send_res.error());
-
-    stage(Stage::Error);
-    return Result::SendToClient;
-  }
-
-  // remove the frame and message from the recv-buffer
-  discard_current_msg(src_channel, src_protocol);
-
-  if (!src_protocol->shared_capabilities().test(
-          classic_protocol::capabilities::pos::ssl)) {
-    // client wants to stay with plaintext
-    if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName &&
-        msg.auth_method_data() == "\x00"sv) {
-      // password is empty.
-      src_protocol->password("");
-    }
-
-    stage(Stage::Accepted);
-    return Result::Again;
-  } else if (connection()->source_ssl_mode() == SslMode::kPassthrough) {
-    stage(Stage::Accepted);
-    return Result::Again;
-  } else {
-    stage(Stage::TlsAcceptInit);
-    return Result::Again;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::tls_accept_init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-
-  src_channel->is_tls(true);
-
-  auto *ssl_ctx = connection()->context().source_ssl_ctx()->get();
-  // tls <-> (any)
-  if (ssl_ctx == nullptr) {
-    // shouldn't happen. But if it does, close the connection.
-    log_warning("failed to create SSL_CTX");
-    return recv_client_failed(make_error_code(std::errc::invalid_argument));
-  }
-  src_channel->init_ssl(ssl_ctx);
-
-  stage(Stage::TlsAccept);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> ClientGreetor::tls_accept() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *client_channel = socket_splicer->client_channel();
-
-  if (!client_channel->tls_init_is_finished()) {
-    trace(Tracer::Event().stage("tls::accept"));
-
-    auto res = socket_splicer->tls_accept();
-    if (!res) {
-      const auto ec = res.error();
-
-      // the send-buffer contains an alert message telling the client why the
-      // accept failed.
-      if (!client_channel->send_buffer().empty()) {
-        if (ec != TlsErrc::kWantRead) {
-          log_debug("tls-accept failed: %s", ec.message().c_str());
-
-          stage(Stage::Error);
-        }
-        return Result::SendToClient;
-      }
-
-      if (ec == TlsErrc::kWantRead) return Result::RecvFromClient;
-
-      log_fatal_error_code("tls-accept failed", ec);
-
-      return recv_client_failed(ec);
-    }
-  }
-
-  stage(Stage::ClientGreetingAfterTls);
-
-  // after tls_accept() there may still be data in the send-buffer that must
-  // be sent.
-  if (!client_channel->send_buffer().empty()) {
-    return Result::SendToClient;
-  }
-  // TLS is accepted, more client greeting should follow.
-
-  return Result::Again;
-}
-
-/**
- * check if the authentication method is supported.
- *
- * @see supported_authentication_methods
- *
- * @retval true auth_method_name is supported
- * @retval false auth_method_name is not supported
- */
-static bool authentication_method_is_supported(
-    const std::string &auth_method_name) {
-  auto it = std::find(supported_authentication_methods.begin(),
-                      supported_authentication_methods.end(), auth_method_name);
-  return it != supported_authentication_methods.end();
-}
-
-static bool client_compress_is_satisfied(
-    classic_protocol::capabilities::value_type client_capabilities,
-    classic_protocol::capabilities::value_type shared_capabilities) {
-  // client enabled "zlib-compress" without checking the server's caps.
-  //
-  // fail the connect.
-  if (client_capabilities.test(classic_protocol::capabilities::pos::compress) &&
-      !shared_capabilities.test(
-          classic_protocol::capabilities::pos::compress)) {
-    return false;
-  }
-
-  return true;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::client_greeting_after_tls() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::Greeting>(
-          src_channel, src_protocol, src_protocol->server_capabilities());
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  trace(Tracer::Event().stage("client::greeting"));
-
-  src_protocol->client_greeting(msg);
-  src_protocol->auth_method_name(msg.auth_method_name());
-  src_protocol->client_capabilities(msg.capabilities());
-  src_protocol->username(msg.username());
-  src_protocol->schema(msg.schema());
-  src_protocol->attributes(msg.attributes());
-
-  discard_current_msg(src_channel, src_protocol);
-
-  if (!authentication_method_is_supported(msg.auth_method_name())) {
-    trace(Tracer::Event().stage("client::greeting::error"));
-
-    const auto send_res =
-        ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-            src_channel, src_protocol,
-            {CR_AUTH_PLUGIN_CANNOT_LOAD,
-             "Authentication method " + msg.auth_method_name() +
-                 " is not supported",
-             "HY000"});
-    if (!send_res) return send_client_failed(send_res.error());
-
-    stage(Stage::Error);
-    return Result::SendToClient;
-  }
-
-  // fail connection from buggy clients that set the compress-cap without
-  // checking if the server's capabilities.
-  if (!client_compress_is_satisfied(src_protocol->client_capabilities(),
-                                    src_protocol->shared_capabilities())) {
-    trace(Tracer::Event().stage("client::greeting::error"));
-    const auto send_res =
-        ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-            src_channel, src_protocol,
-            {ER_WRONG_COMPRESSION_ALGORITHM_CLIENT,
-             "Compression not supported by router."});
-    if (!send_res) return send_client_failed(send_res.error());
-
-    stage(Stage::Error);
-    return Result::SendToClient;
-  }
-
-  if (src_protocol->client_greeting()->auth_method_data() == "\x00"sv) {
-    // special value for 'empty password'. Not scrambled.
-    src_protocol->password("");
-
-    stage(Stage::Accepted);
-    return Result::Again;
-  } else if (kCapturePlaintextPassword &&
-             src_protocol->auth_method_name() ==
-                 AuthCachingSha2Password::kName &&
-             src_channel->is_tls()) {
-    stage(Stage::RequestPlaintextPassword);
-    return Result::Again;
-  } else {
-    stage(Stage::Accepted);
-    return Result::Again;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::request_plaintext_password() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  auto send_res = AuthCachingSha2Password::send_plaintext_password_request(
-      dst_channel, dst_protocol);
-  if (!send_res) return send_client_failed(send_res.error());
-
-  trace(Tracer::Event().stage("server::auth::request::plain"));
-
-  stage(Stage::PlaintextPassword);
-  return Result::SendToClient;
-}
-
-/**
- * remove trailing \0 in a string_view.
- *
- * returns the original string-view, if there is no trailing NUL-char.
- */
-static auto strip_trailing_null(std::string_view s) {
-  if (s.empty()) return s;
-
-  if (s.back() == '\0') s.remove_suffix(1);
-
-  return s;
-}
-
-/**
- * extract the password from auth-method-data.
- *
- * @returns the payload without the trailing NUL-char.
- * @retval false in there is no password.
- */
-static std::optional<std::string> password_from_auth_method_data(
-    std::string auth_data) {
-  if (auth_data.empty() || auth_data.back() != '\0') return std::nullopt;
-
-  // strip the trailing \0
-  auth_data.pop_back();
-
-  return auth_data;
-}
-
-/**
- * receive the client's plaintext password.
- *
- * after client_send_request_for_plaintext_password()
- */
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::plaintext_password() {
-  auto *src_channel = connection()->socket_splicer()->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::wire::String>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("client::auth::plain"));
-
-  if (auto pwd = password_from_auth_method_data(msg_res->value())) {
-    src_protocol->password(*pwd);
-  }
-
-  // discard the current frame.
-  discard_current_msg(src_channel, src_protocol);
-
-  stage(Stage::Accepted);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> ClientGreetor::accepted() {
-  trace(Tracer::Event().stage("client::greeting::client_done"));
-
-  auto *dst_protocol = connection()->server_protocol();
-
-  stage(Stage::Authenticated);
-
-  if (dst_protocol->server_greeting().has_value()) {
-    // server-greeting is already present.
-    connection()->push_processor(
-        std::make_unique<ServerFirstAuthenticator>(connection()));
-  } else {
-    // server side requires TLS?
-
-    auto dest_ssl_mode = connection()->dest_ssl_mode();
-    auto source_ssl_mode = connection()->source_ssl_mode();
-
-    // if a connection is taken from the pool, make sure it matches the TLS
-    // requirements.
-    connection()->requires_tls(dest_ssl_mode == SslMode::kRequired ||
-                               dest_ssl_mode == SslMode::kPreferred ||
-                               (dest_ssl_mode == SslMode::kAsClient &&
-                                (source_ssl_mode == SslMode::kPreferred ||
-                                 source_ssl_mode == SslMode::kRequired)));
-
-    connection()->push_processor(
-        std::make_unique<LazyConnector>(connection(), true /* in handshake */));
-  }
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ClientGreetor::authenticated() {
-  if (connection()->authenticated()) {
-    trace(Tracer::Event().stage("greeting::auth::done"));
-    stage(Stage::Ok);
-  } else {
-    trace(Tracer::Event().stage("greeting::error"));
-    stage(Stage::Error);
-  }
-  return Result::Again;
-}
-
-static bool server_ssl_mode_is_satisfied(
-    SslMode server_ssl_mode,
-    classic_protocol::capabilities::value_type server_capabilities) {
-  if ((server_ssl_mode == SslMode::kRequired) &&
-      !server_capabilities.test(classic_protocol::capabilities::pos::ssl)) {
-    return false;
-  }
-
-  return true;
-}
-
-static stdx::expected<size_t, std::error_code> classic_proto_append_attribute(
-    std::string &attrs_buf, const std::string &key, const std::string &value) {
-  auto encode_res =
-      classic_protocol::encode(classic_protocol::wire::VarString(key), {},
-                               net::dynamic_buffer(attrs_buf));
-  if (!encode_res) {
-    return encode_res.get_unexpected();
-  }
-
-  size_t encoded_bytes = encode_res.value();
-
-  encode_res =
-      classic_protocol::encode(classic_protocol::wire::VarString(value), {},
-                               net::dynamic_buffer(attrs_buf));
-  if (!encode_res) {
-    return encode_res.get_unexpected();
-  }
-
-  encoded_bytes += encode_res.value();
-
-  return encoded_bytes;
-}
-
-/**
- * verify connection attributes are sane.
- *
- * connection attributes are a key-value-key-value-...
- *
- * - decodes as var-string
- * - each key must have a value
- */
-static stdx::expected<void, std::error_code>
-classic_proto_verify_connection_attributes(const std::string &attrs) {
-  // track if each key has a matching value.
-  bool is_key{true};
-  auto attr_buf = net::buffer(attrs);
-
-  while (net::buffer_size(attr_buf) != 0) {
-    const auto decode_res =
-        classic_protocol::decode<classic_protocol::wire::VarString>(attr_buf,
-                                                                    {});
-    if (!decode_res) return decode_res.get_unexpected();
-
-    const auto bytes_read = decode_res->first;
-    const auto kv = decode_res->second;
-
-    attr_buf += bytes_read;
-
-    // toggle the key/value tracker.
-    is_key = !is_key;
-  }
-
-  // if the last key doesn't have a value, fail
-  if (!is_key || net::buffer_size(attr_buf) != 0) {
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-
-  return {};
-}
-
-/**
- * merge connection attributes.
- *
- * - verifies the connection attributes
- * - appends new attributes.
- * - sets attributes back to the client-greeting-msg
- *
- * @returns bytes appended on success, std::error_code on error.
- */
-static stdx::expected<std::string, std::error_code>
-classic_proto_decode_and_add_connection_attributes(
-    std::string attrs,
-    const std::vector<std::pair<std::string, std::string>> &extra_attributes) {
-  // add attributes if they are sane.
-  const auto verify_res = classic_proto_verify_connection_attributes(attrs);
-  if (!verify_res) return verify_res.get_unexpected();
-
-  for (const auto &attr : extra_attributes) {
-    const auto append_res =
-        classic_proto_append_attribute(attrs, attr.first, attr.second);
-    if (!append_res) return append_res.get_unexpected();
-  }
-
-  return {attrs};
-}
-
-// server-side handshake
-
-stdx::expected<Processor::Result, std::error_code> ServerGreetor::process() {
-  switch (stage()) {
-    case Stage::ServerGreeting:
-      return server_greeting();
-    case Stage::ServerGreetingError:
-      return server_greeting_error();
-    case Stage::ServerGreetingGreeting:
-      return server_greeting_greeting();
-    case Stage::ClientGreeting:
-      return client_greeting();
-    case Stage::ClientGreetingStartTls:
-      return client_greeting_start_tls();
-    case Stage::ClientGreetingFull:
-      return client_greeting_full();
-    case Stage::TlsConnectInit:
-      return tls_connect_init();
-    case Stage::TlsConnect:
-      return tls_connect();
-    case Stage::ClientGreetingAfterTls:
-      return client_greeting_after_tls();
-    case Stage::Response:
-      return response();
-    case Stage::AuthData:
-      return auth_data();
-    case Stage::AuthMethodSwitch:
-      return auth_method_switch();
-    case Stage::ClientAuth:
-      return client_auth();
-    case Stage::AuthError:
-      return auth_error();
-    case Stage::AuthOk:
-      return auth_ok();
-
-      // the exit-stages
-    case Stage::Error:
-      return error();
-    case Stage::ServerGreetingSent:
-      return Result::Done;
-    case Stage::Ok:
-      connection()->authenticated(true);
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-// error has been sent to the client.
-stdx::expected<Processor::Result, std::error_code> ServerGreetor::error() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  // ConnectProcessor either:
-  //
-  // - closes the connection and sends an error to the client, or
-  // - keeps the connection open.
-  auto &server_conn = socket_splicer->server_conn();
-
-  (void)server_conn.close();
-
-  return Result::Done;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::server_greeting() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  namespace message = classic_protocol::message;
-
-  if (msg_type == ClassicFrame::cmd_byte<message::server::Error>()) {
-    stage(Stage::ServerGreetingError);
-  } else {
-    stage(Stage::ServerGreetingGreeting);
-  }
-  return Result::Again;
-}
-
-/**
- * received an server::error from the server.
- *
- * forward it to the client and close the connection.
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::server_greeting_error() {
-  trace(Tracer::Event().stage("server::greeting::error"));
-
-  // don't increment the error-counter
-  connection()->client_greeting_sent(true);
-
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::Error>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  auto msg = *msg_res;
-
-  // RouterRoutingTest.RoutingTooManyServerConnections expects this
-  // message.
-  log_debug(
-      "Error from the server while waiting for greetings message: "
-      "%u, '%s'",
-      msg.error_code(), msg.message().c_str());
-
-  stage(Stage::Error);  // forward the packet and close the connection.
-
-  return forward_server_to_client();
-}
-
-// called after server connection is established.
-void ServerGreetor::client_greeting_server_adjust_caps(
-    ClassicProtocolState *src_protocol, ClassicProtocolState *dst_protocol) {
-  auto client_caps = src_protocol->client_capabilities();
-
-  if (!src_protocol->shared_capabilities().test(
-          classic_protocol::capabilities::pos::ssl)) {
-    auto attrs_res = classic_proto_decode_and_add_connection_attributes(
-        src_protocol->attributes(), connection()
-                                        ->socket_splicer()
-                                        ->client_conn()
-                                        .initial_connection_attributes());
-
-    // client hasn't set the SSL cap, this is the real client greeting
-    auto attrs = attrs_res.value_or(src_protocol->attributes());
-
-    dst_protocol->sent_attributes(attrs);
-    src_protocol->sent_attributes(attrs);
-
-    auto client_greeting_msg = src_protocol->client_greeting().value();
-    client_greeting_msg.attributes(attrs);
-    dst_protocol->client_greeting(client_greeting_msg);
-  }
-
-  switch (connection()->dest_ssl_mode()) {
-    case SslMode::kDisabled:
-      // config says: communication to server is unencrypted
-      client_caps.reset(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kRequired:
-      // config says: communication to server must be encrypted
-      client_caps.set(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kPreferred:
-      // config says: communication to server should be encrypted if server
-      // supports it.
-      if (dst_protocol->server_capabilities().test(
-              classic_protocol::capabilities::pos::ssl)) {
-        client_caps.set(classic_protocol::capabilities::pos::ssl);
-      }
-      break;
-    case SslMode::kAsClient:
-      break;
-    case SslMode::kPassthrough:
-    case SslMode::kDefault:
-      harness_assert_this_should_not_execute();
-      break;
-  }
-  dst_protocol->client_capabilities(client_caps);
-}
-
-/**
- * received a server::greeting from the server.
- *
- * decode it.
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::server_greeting_greeting() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  const auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::Greeting>(
-          src_channel, src_protocol, {/* no shared caps yet */});
-  if (!msg_res) return msg_res.get_unexpected();
-
-#if defined(DEBUG_STATE)
-  log_debug("client-ssl-mode=%s, server-ssl-mode=%s",
-            ssl_mode_to_string(source_ssl_mode()),
-            ssl_mode_to_string(dest_ssl_mode()));
-#endif
-
-  auto server_greeting_msg = *msg_res;
-
-  auto caps = server_greeting_msg.capabilities();
-
-  src_protocol->server_capabilities(caps);
-  src_protocol->server_greeting(server_greeting_msg);
-
-  trace(Tracer::Event().stage("server::greeting::greeting"));
-
-  auto msg = src_protocol->server_greeting().value();
-
-#if 0
-  std::cerr << __LINE__ << ": proto-version: " << (int)msg.protocol_version()
-            << "\n";
-  std::cerr << __LINE__ << ": caps: " << msg.capabilities() << "\n";
-  std::cerr << __LINE__ << ": auth-method-name: " << msg.auth_method_name()
-            << "\n";
-  std::cerr << __LINE__ << ": auth-method-data:\n"
-            << hexify(msg.auth_method_data()) << "\n";
-  std::cerr << __LINE__ << ": status-flags: " << msg.status_flags() << "\n";
-#endif
-
-  if (!server_ssl_mode_is_satisfied(connection()->dest_ssl_mode(),
-                                    src_protocol->server_capabilities())) {
-    discard_current_msg(src_channel, src_protocol);
-
-    // destination does not support TLS, but config requires encryption.
-    log_debug(
-        "server_ssl_mode=REQUIRED, but destination doesn't support "
-        "encryption.");
-    auto send_res = send_ssl_connection_error_msg(
-        dst_channel, dst_protocol,
-        "SSL connection error: SSL is required by router, but the "
-        "server doesn't support it");
-    if (!send_res) {
-      auto ec = send_res.error();
-      log_fatal_error_code("sending error-msg failed", ec);
-
-      return send_client_failed(ec);
-    }
-
-    stage(Stage::Error);
-    return Result::SendToClient;
-  }
-
-  // the server side's auth-method-data
-  src_protocol->auth_method_data(msg.auth_method_data());
-
-  if (!dst_protocol->server_greeting()) {
-    discard_current_msg(src_channel, src_protocol);
-    // client doesn't have server greeting yet, send it the server's.
-
-    auto caps = src_protocol->server_capabilities();
-
-    adjust_supported_capabilities(connection()->source_ssl_mode(),
-                                  connection()->dest_ssl_mode(), caps);
-
-    // update the client side's auth-method-data.
-    dst_protocol->auth_method_data(msg.auth_method_data());
-    dst_protocol->server_capabilities(caps);
-    dst_protocol->seq_id(0xff);  // will be incremented by 1
-
-    msg.capabilities(caps);
-
-    auto send_res =
-        ClassicFrame::send_msg<classic_protocol::message::server::Greeting>(
-            dst_channel, dst_protocol, msg);
-    if (!send_res) return send_client_failed(send_res.error());
-
-    stage(Stage::ServerGreetingSent);  // hand over to the ServerFirstConnector
-    return Result::SendToClient;
-  } else {
-    discard_current_msg(src_channel, src_protocol);
-
-    stage(Stage::ClientGreeting);
-    return Result::Again;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::client_greeting() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_protocol = connection()->server_protocol();
-
-  bool server_supports_tls = dst_protocol->server_capabilities().test(
-      classic_protocol::capabilities::pos::ssl);
-  bool client_uses_tls = src_protocol->shared_capabilities().test(
-      classic_protocol::capabilities::pos::ssl);
-
-  if (connection()->dest_ssl_mode() == SslMode::kAsClient && client_uses_tls &&
-      !server_supports_tls) {
-    // config says: do as the client did, and the client did SSL and server
-    // doesn't support it -> error
-
-    // send back to the client
-    const auto send_res = send_ssl_connection_error_msg(
-        src_channel, src_protocol,
-        "SSL connection error: Requirements can not be satisfied");
-    if (!send_res) return send_client_failed(send_res.error());
-
-    stage(Stage::Error);
-    return Result::SendToClient;
-  }
-
-  client_greeting_server_adjust_caps(src_protocol, dst_protocol);
-
-  // use the client-side's capabilities to make sure the server encodes
-  // the packets according to the client.
-  //
-  // src_protocol->shared_caps must be used here as the ->client_caps may
-  // contain more than what the router advertised.
-  auto client_caps = src_protocol->shared_capabilities();
-
-  switch (connection()->dest_ssl_mode()) {
-    case SslMode::kDisabled:
-      client_caps.reset(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kPreferred:
-      client_caps.set(classic_protocol::capabilities::pos::ssl,
-                      server_supports_tls);
-      break;
-    case SslMode::kRequired:
-      client_caps.set(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kAsClient:
-      client_caps.set(classic_protocol::capabilities::pos::ssl,
-                      client_uses_tls);
-      break;
-    case SslMode::kPassthrough:
-      // don't check caps on passthrough.
-      break;
-    case SslMode::kDefault:
-      log_debug("dest_ssl_mode::Default ... should not happen.");
-
-      return recv_client_failed(make_error_code(std::errc::invalid_argument));
-  }
-
-  // ensure that "with_schema" cap is set when sending a schema to the server.
-  //
-  // if the client didn't sent a schema initially, the connect-with-schema cap
-  // will not be part of the client's caps.
-  const auto with_schema_pos =
-      classic_protocol::capabilities::pos::connect_with_schema;
-  if (src_protocol->schema().empty()) {
-    client_caps.reset(with_schema_pos);
-  } else {
-    client_caps.set(with_schema_pos);
-  }
-
-  dst_protocol->client_capabilities(client_caps);
-  dst_protocol->auth_method_name(src_protocol->auth_method_name());
-  dst_protocol->username(src_protocol->username());
-  dst_protocol->attributes(src_protocol->attributes());
-
-  // the client greeting was received and will be forwarded to the server
-  // soon.
-  connection()->client_greeting_sent(true);
-  connection()->on_handshake_received();
-
-  if (dst_protocol->shared_capabilities().test(
-          classic_protocol::capabilities::pos::ssl)) {
-    stage(Stage::ClientGreetingStartTls);
-  } else {
-    stage(Stage::ClientGreetingFull);
-  }
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::client_greeting_start_tls() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_protocol = connection()->server_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-
-  if (!src_protocol->client_greeting()) {
-    return send_server_failed(make_error_code(std::errc::invalid_argument));
-  }
-
-  auto initial_client_greeting_msg = src_protocol->client_greeting().value();
-
-  // setting username == "" leads to a short, switch-to-ssl
-  // client::Greeting.
-  auto send_res =
-      ClassicFrame::send_msg<classic_protocol::message::client::Greeting>(
-          dst_channel, dst_protocol,
-          {
-              dst_protocol->client_capabilities(),
-              initial_client_greeting_msg.max_packet_size(),
-              initial_client_greeting_msg.collation(),
-              "",  // username
-              "",  // auth_method_data
-              "",  // schema
-              "",  // auth_method_name
-              ""   // attributes
-          });
-  if (!send_res) return send_server_failed(send_res.error());
-
-  trace(Tracer::Event().stage("client::greeting (start-tls)"));
-
-  stage(Stage::TlsConnectInit);
-
-  // leave msg in the send buffer as tls_connect() will flush it.
-
-  // Result::SendToServer
-  //       2041 us (      +115 us)      r<-s io::recv
-  //       2044 us (        +2 us)           server::greeting?
-  //       2049 us (        +5 us)           server::greeting::greeting
-  //       2056 us (        +6 us)           client::greeting
-  //       2068 us (       +12 us)      r->s io::send  << this one
-  //       2233 us (      +164 us)           tls::connect
-  //       2249 us (       +16 us)      r->s io::send
-
-  // Result::Again
-  //       2005 us (      +138 us)      r<-s io::recv
-  //       2008 us (        +2 us)           server::greeting?
-  //       2014 us (        +6 us)           server::greeting::greeting
-  //       2021 us (        +6 us)           client::greeting
-  //       2090 us (       +68 us)           tls::connect
-  //       2113 us (       +23 us)      r->s io::send
-  return Result::Again;
-}
-
-/**
- * send a non-TLS client greeting to the server.
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::client_greeting_full() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-  auto *dst_protocol = connection()->server_protocol();
-
-  auto client_greeting_msg = src_protocol->client_greeting().value();
-
-  const auto attrs_res = classic_proto_decode_and_add_connection_attributes(
-      src_protocol->attributes(),
-      vector_splice(
-          socket_splicer->client_conn().initial_connection_attributes(),
-          client_ssl_connection_attributes(src_channel->ssl())));
-  if (!attrs_res) {
-    auto ec = attrs_res.error();
-    // if decode/append fails forward the attributes as is. The server should
-    // fail too.
-    //
-    if (src_protocol->client_capabilities().test(
-            classic_protocol::capabilities::pos::connect_attributes)) {
-      log_warning("%d: decoding connection attributes failed [ignored]: (%s) ",
-                  __LINE__, ec.message().c_str());
-    }
-  }
-
-  client_greeting_msg.capabilities(dst_protocol->client_capabilities());
-  client_greeting_msg.username(src_protocol->username());
-  client_greeting_msg.schema(src_protocol->schema());
-
-  auto attrs = attrs_res.value_or(src_protocol->attributes());
-  dst_protocol->sent_attributes(attrs);
-  src_protocol->sent_attributes(attrs);
-
-  client_greeting_msg.attributes(attrs);
-
-  trace(Tracer::Event().stage("client::greeting::plain"));
-
-  if (src_protocol->password().has_value()) {
-    // scramble with the server's auth-data to trigger a fast-auth.
-
-    auto pwd = *(src_protocol->password());
-
-    // if the password set and not empty, rehash it.
-    if (!pwd.empty()) {
-      if (auto scramble_res = scramble_them_all(
-              client_greeting_msg.auth_method_name(),
-              strip_trailing_null(
-                  dst_protocol->server_greeting()->auth_method_data()),
-              pwd)) {
-        client_greeting_msg.auth_method_data(*scramble_res);
-      }
-    }
-  } else if (src_protocol->auth_method_name() ==
-                 AuthCachingSha2Password::kName &&
-             !src_channel->ssl() && connection()->greeting_from_router()) {
-    // the client tried the fast-auth path and scrambled it with the router's
-    // nonce.
-    //
-    // That will fail on the server side as it used another scramble.
-    //
-    // replace the auth-method-method to force a "auth-method-switch" which
-    // contains the server's nonce.
-    client_greeting_msg.auth_method_name("switch_me_if_you_can");
-  } else {
-    dst_protocol->auth_method_name(src_protocol->auth_method_name());
-  }
-
-  return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
-      .and_then(
-          [this](auto /* sent */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::Response);
-
-            return Result::SendToServer;
-          })
-      .or_else([this](auto err) { return send_server_failed(err); });
-}
-
-static stdx::expected<SSL_CTX *, std::error_code> get_dest_ssl_ctx(
-    MySQLRoutingContext &ctx, const std::string &id) {
-  return mysql_harness::make_tcp_address(id).and_then(
-      [&ctx](const auto &addr) -> stdx::expected<SSL_CTX *, std::error_code> {
-        return ctx.dest_ssl_ctx(addr.address())->get();
-      });
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::tls_connect_init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *dst_channel = socket_splicer->server_channel();
-
-  auto ssl_ctx_res = get_dest_ssl_ctx(connection()->context(),
-                                      connection()->get_destination_id());
-  if (!ssl_ctx_res || ssl_ctx_res.value() == nullptr) {
-    // shouldn't happen. But if it does, close the connection.
-    log_warning("failed to create SSL_CTX");
-
-    return send_server_failed(make_error_code(std::errc::invalid_argument));
-  }
-  dst_channel->init_ssl(*ssl_ctx_res);
-
-  // when a connection is taken from the pool for this client-connection, make
-  // sure it is TLS again.
-  connection()->requires_tls(true);
-
-  stage(Stage::TlsConnect);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::tls_connect() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-
-  {
-    const auto flush_res = dst_channel->flush_from_recv_buf();
-    if (!flush_res) {
-      auto ec = flush_res.error();
-      log_fatal_error_code("tls_connect::recv::flush() failed", ec);
-
-      return recv_server_failed(ec);
-    }
-  }
-
-  if (!dst_channel->tls_init_is_finished()) {
-    const auto res = dst_channel->tls_connect();
-
-    trace(Tracer::Event().stage("tls::connect"));
-
-    if (!res) {
-      if (res.error() == TlsErrc::kWantRead) {
-        {
-          const auto flush_res = dst_channel->flush_to_send_buf();
-          if (!flush_res &&
-              (flush_res.error() !=
-               make_error_condition(std::errc::operation_would_block))) {
-            auto ec = flush_res.error();
-            log_fatal_error_code("flushing failed", ec);
-
-            return send_server_failed(ec);
-          }
-        }
-
-        if (!dst_channel->send_buffer().empty()) {
-          return Result::SendToServer;
-        }
-
-        return Result::RecvFromServer;
-      } else {
-        // connect may fail fatally if
-        //
-        // - cert-verification failed.
-        // - no shared cipher
-
-        const auto send_res = send_ssl_connection_error_msg(
-            src_channel, src_protocol,
-            "connecting to destination failed with TLS error: " +
-                res.error().message());
-        if (!send_res) {
-          auto ec = send_res.error();
-          log_fatal_error_code("sending error failed", ec);
-
-          return send_client_failed(ec);
-        }
-
-        trace(Tracer::Event().stage("server::greeting::error"));
-
-        stage(Stage::Error);
-        return Result::SendToClient;
-      }
-    }
-  }
-
-  stage(Stage::ClientGreetingAfterTls);
-  // tls is established to the server, send the client::greeting
-  return Result::Again;
-}
-
-/**
- * a TLS client greeting.
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::client_greeting_after_tls() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-  auto *dst_protocol = connection()->server_protocol();
-
-  auto client_greeting_msg = *src_protocol->client_greeting();
-
-  const auto attrs_res = classic_proto_decode_and_add_connection_attributes(
-      src_protocol->attributes(),
-      vector_splice(
-          socket_splicer->client_conn().initial_connection_attributes(),
-          client_ssl_connection_attributes(src_channel->ssl())));
-  if (!attrs_res) {
-    auto ec = attrs_res.error();
-    // if decode/append fails forward the attributes as is. The server should
-    // fail too.
-    //
-    if (src_protocol->client_capabilities().test(
-            classic_protocol::capabilities::pos::connect_attributes)) {
-      log_warning("%d: decoding connection attributes failed [ignored]: (%s) ",
-                  __LINE__, ec.message().c_str());
-    }
-  }
-
-  dst_protocol->username(src_protocol->username());
-
-  auto attrs = attrs_res.value_or(src_protocol->attributes());
-  dst_protocol->sent_attributes(attrs);
-  src_protocol->sent_attributes(attrs);
-
-  client_greeting_msg.attributes(attrs);
-
-  client_greeting_msg.username(src_protocol->username());
-  client_greeting_msg.schema(src_protocol->schema());
-  client_greeting_msg.capabilities(dst_protocol->client_capabilities());
-
-  trace(Tracer::Event().stage("client::greeting (tls)"));
-
-  if (src_protocol->password().has_value()) {
-    // scramble with the server's auth-data to trigger a fast-auth.
-
-    auto pwd = *(src_protocol->password());
-
-    // if the password set and not empty, rehash it.
-    if (!pwd.empty()) {
-      if (auto scramble_res = scramble_them_all(
-              client_greeting_msg.auth_method_name(),
-              strip_trailing_null(
-                  dst_protocol->server_greeting()->auth_method_data()),
-              pwd)) {
-        client_greeting_msg.auth_method_data(*scramble_res);
-      }
-    }
-  } else if (src_protocol->auth_method_name() ==
-                 AuthCachingSha2Password::kName &&
-             !src_channel->ssl() && connection()->greeting_from_router()) {
-    // the client tried the fast-auth path and scrambled it with the router's
-    // nonce.
-    //
-    // That will fail on the server side as it used another scramble.
-    //
-    // replace the auth-method-method to force a "auth-method-switch" which
-    // contains the server's nonce.
-    client_greeting_msg.auth_method_name("switch_me_if_you_can");
-  }
-
-  dst_protocol->auth_method_name(src_protocol->auth_method_name());
-
-  return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
-      .and_then(
-          [this](auto /* unused */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::Response);
-
-            return Result::SendToServer;
-          })
-      .or_else([this](auto err) { return send_server_failed(err); });
-}
-
-stdx::expected<Processor::Result, std::error_code> ServerGreetor::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) {
-    auto ec = read_res.error();
-
-    if (ec == TlsErrc::kWantRead) return Result::RecvFromServer;
-
-    return recv_server_failed(ec);
-  }
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    AuthMethodSwitch = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodSwitch>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    AuthMethodData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthMethodSwitch:
-      stage(Stage::AuthMethodSwitch);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::AuthOk);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::AuthError);
-      return Result::Again;
-    case Msg::AuthMethodData:
-      stage(Stage::AuthData);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug(
-      "received unexpected message from server after a client::Greeting:\n%s",
-      hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-/**
- * router<-server: auth error.
- */
-stdx::expected<Processor::Result, std::error_code> ServerGreetor::auth_error() {
-  trace(Tracer::Event().stage("server::auth::error"));
-
-  stage(Stage::Error);
-
-  if (in_handshake_) {
-    return forward_server_to_client();
-  }
-
-  return Result::Again;
-}
-
-/**
- * server-side: auth is ok.
- */
-stdx::expected<Processor::Result, std::error_code> ServerGreetor::auth_ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-  auto *dst_protocol = connection()->client_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("server::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    (void)connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  // if the server accepted the schema, track it.
-  if (src_protocol->shared_capabilities().test(
-          classic_protocol::capabilities::pos::connect_with_schema)) {
-    src_protocol->schema(dst_protocol->schema());
-  } else {
-    src_protocol->schema("");
-  }
-
-  stage(Stage::Ok);
-
-  if (in_handshake_) {
-    return forward_server_to_client();
-  }
-
-  discard_current_msg(src_channel, src_protocol);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::auth_method_switch() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-  auto *dst_protocol = connection()->client_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(src_channel,
-                                                           src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  src_protocol->auth_method_name(msg.auth_method());
-  src_protocol->auth_method_data(msg.auth_method_data());
-  dst_protocol->auth_method_name(msg.auth_method());
-  dst_protocol->auth_method_data(msg.auth_method_data());
-
-  trace(Tracer::Event().stage("server::auth::switch: " + msg.auth_method() +
-                              "\n" + hexify(msg.auth_method_data())));
-
-#if defined(DEBUG_IO)
-  std::cerr << __LINE__ << ": auth_method_name: " << msg.auth_method() << "\n";
-  std::cerr << __LINE__ << ": auth_method_data:\n"
-            << hexify(msg.auth_method_data()) << "\n";
-#endif
-
-  if (dst_protocol->password().has_value()) {
-    auto pwd = *(dst_protocol->password());
-
-    if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
-      using Auth = AuthSha256Password;
-
-      if (!src_channel->ssl()) {
-        discard_current_msg(src_channel, src_protocol);
-
-        if (pwd.empty()) {
-          // send empty passwords directly.
-          trace(Tracer::Event().stage("client::auth::plain"));
-
-          auto send_res =
-              Auth::send_plaintext_password(src_channel, src_protocol, pwd);
-          if (!send_res) return send_server_failed(send_res.error());
-
-          stage(Stage::Response);
-          return Result::SendToServer;
-        } else {
-          // the server is NOT encrypted: ask for the server's publickey
-          trace(Tracer::Event().stage("client::auth::request_public_key"));
-
-          auto send_res =
-              Auth::send_public_key_request(src_channel, src_protocol);
-          if (!send_res) return send_server_failed(send_res.error());
-
-          stage(Stage::Response);
-          return Result::SendToServer;
-        }
-      }
-    }
-
-    // if the password set and not empty, rehash it.
-    if (auto scramble_res = scramble_them_all(
-            msg.auth_method(), strip_trailing_null(msg.auth_method_data()),
-            pwd)) {
-      discard_current_msg(src_channel, src_protocol);
-
-      auto send_res = ClassicFrame::send_msg<classic_protocol::wire::String>(
-          src_channel, src_protocol, {*scramble_res});
-      if (!send_res) return stdx::make_unexpected(send_res.error());
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    } else {
-      return send_server_failed(make_error_code(std::errc::bad_message));
-    }
-  } else {
-    stage(Stage::ClientAuth);
-    return forward_server_to_client();
-  }
-}
-
-static bool connection_has_public_key(
-    MysqlRoutingClassicConnection *connection) {
-#if OPENSSL_VERSION_NUMBER >= ROUTER_OPENSSL_VERSION(1, 0, 2)
-  if (!connection->context().source_ssl_ctx()) return false;
-
-  SSL_CTX *ssl_ctx = connection->context().source_ssl_ctx()->get();
-
-  return SSL_CTX_get0_certificate(ssl_ctx) != nullptr;
-#else
-  (void)connection;
-  return false;
-#endif
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerGreetor::client_auth() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-  auto *dst_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("client::auth"));
-
-  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
-    using Auth = AuthCachingSha2Password;
-
-    if (Auth::is_public_key_request(msg_res->auth_method_data())) {
-      if (connection_has_public_key(connection())) {
-        discard_current_msg(src_channel, src_protocol);
-
-        trace(Tracer::Event().stage("server::auth::public_key"));
-
-        auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-            connection()->context().source_ssl_ctx()->get());
-        if (!pubkey_res) {
-          auto ec = pubkey_res.error();
-
-          if (ec != std::errc::function_not_supported) {
-            return send_client_failed(ec);
-          }
-
-          // couldn't get the public key, fail the auth.
-          auto send_res =
-              ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-                  src_channel, src_protocol,
-                  {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
-          if (!send_res) return send_client_failed(send_res.error());
-        } else {
-          auto send_res =
-              Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-          if (!send_res) return send_client_failed(send_res.error());
-        }
-
-        return Result::SendToClient;
-      } else {
-        // client requested a public key, but router has no ssl-ctx
-        // (client-ssl-mode is DISABLED|PASSTHROUGH)
-        stage(Stage::Response);
-        return forward_client_to_server();
-      }
-    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
-               connection_has_public_key(connection())) {
-      trace(Tracer::Event().stage("client::auth::encrypted"));
-
-      auto recv_res = Auth::rsa_decrypt_password(
-          connection()->context().source_ssl_ctx()->get(),
-          msg_res->auth_method_data(), src_protocol->auth_method_data());
-      if (!recv_res) return recv_client_failed(recv_res.error());
-
-      src_protocol->password(*recv_res);
-
-      discard_current_msg(src_channel, src_protocol);
-
-      if (dst_channel->ssl()) {
-        trace(Tracer::Event().stage("client::auth::plaintext_password"));
-        // the server-side is encrypted: send plaintext password
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-        // the server is NOT encrypted: ask for the server's publickey
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    }
-  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
-    using Auth = AuthSha256Password;
-
-    if (msg_res->auth_method_data() == Auth::kEmptyPassword) {
-      // empty password.
-      src_protocol->password("");
-
-      stage(Stage::Response);
-      return forward_client_to_server();
-    } else if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
-               connection_has_public_key(connection())) {
-      // if the client is not encrypted, it may ask for the server's public-key
-      // via 0x01
-      //
-      // if the server is encrypted, it doesn't expect that 0x01 and will treat
-      // it as plaintext password.
-
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("server::auth::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) {
-        auto ec = pubkey_res.error();
-
-        if (ec != std::errc::function_not_supported) {
-          return send_client_failed(ec);
-        }
-
-        // couldn't get the public key, fail the auth.
-        auto send_res =
-            ClassicFrame::send_msg<classic_protocol::message::server::Error>(
-                src_channel, src_protocol,
-                {ER_ACCESS_DENIED_ERROR, "Access denied", "HY000"});
-        if (!send_res) return send_client_failed(send_res.error());
-      } else {
-        auto send_res =
-            Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-        if (!send_res) return send_client_failed(send_res.error());
-      }
-
-      return Result::SendToClient;
-    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
-               connection_has_public_key(connection())) {
-      auto recv_res = Auth::rsa_decrypt_password(
-          connection()->context().source_ssl_ctx()->get(),
-          msg_res->auth_method_data(), src_protocol->auth_method_data());
-      if (!recv_res) return recv_client_failed(recv_res.error());
-
-      src_protocol->password(*recv_res);
-
-      discard_current_msg(src_channel, src_protocol);
-
-      if (dst_channel->ssl()) {
-        // the server-side is encrypted: send plaintext password
-        trace(Tracer::Event().stage("client::auth::password"));
-
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        // the server is NOT encrypted: ask for the server's public-key
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    }
-  }
-
-#if defined(DEBUG_IO)
-  std::cerr << __LINE__ << ": auth_method_data:\n"
-            << hexify(msg_res->auth_method_data()) << "\n";
-#endif
-
-  stage(Stage::Response);
-  return forward_client_to_server();
-}
-
-/**
- *
- * server->router
- */
-stdx::expected<Processor::Result, std::error_code> ServerGreetor::auth_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-  auto dst_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
-    using Auth = AuthCachingSha2Password;
-
-    if (msg.auth_method_data().size() < 1) {
-      return recv_server_failed(make_error_code(std::errc::bad_message));
-    }
-
-    if (dst_protocol->password().has_value()) {
-      // client's password is known.
-
-      auto opt_pwd = dst_protocol->password();
-
-      switch (msg.auth_method_data()[0]) {
-        case Auth::kFastAuthDone:
-          trace(Tracer::Event().stage("server::auth::fastauthdone"));
-          // 0x03 means the client-greeting provided the right scrambled
-          // password that matches the cached entry.
-
-          // as there is a password provided by the client via
-          // client_recv_plaintext_password() the client side expects either
-          // server::Ok or server::Error now.
-          //
-          // c<-r: server::greeting (from router)
-          // c->r: client::greeting (with tls handshake)
-          // c<-r: 0x01 0x04
-          // c->r: password
-          //    r->s: connect()
-          //    r<-s: server::greeting
-          //    r->s: client::greeting (with tls handshake, rehashed pwd)
-          //    r<-s: 0x01 0x03   // current message
-          //    r<-s: server::Ok
-          // c<-r: server::Ok
-          discard_current_msg(src_channel, src_protocol);
-
-          stage(Stage::Response);
-          return Result::Again;
-        case Auth::kPerformFullAuth: {
-          trace(Tracer::Event().stage("server::auth::request::plain"));
-
-          // as the client already provided a password, provide it to the
-          // server directly.
-          discard_current_msg(src_channel, src_protocol);
-
-          trace(Tracer::Event().stage("client::auth::plain"));
-
-          if (src_channel->ssl()) {
-            auto send_res = Auth::send_plaintext_password(
-                src_channel, src_protocol, *opt_pwd);
-            if (!send_res) return send_server_failed(send_res.error());
-          } else {
-            // the server side isn't encrypted: request public-key
-            auto send_res =
-                Auth::send_public_key_request(src_channel, src_protocol);
-            if (!send_res) return send_server_failed(send_res.error());
-          }
-
-          // send it to the server.
-          stage(Stage::Response);
-          return Result::SendToServer;
-        }
-        case '-': {
-          auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-          if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-          discard_current_msg(src_channel, src_protocol);
-
-          trace(Tracer::Event().stage("client::auth::password"));
-
-          auto encrypted_res = Auth::rsa_encrypt_password(
-              *pubkey_res, *(dst_protocol->password()),
-              src_protocol->auth_method_data());
-          if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-          auto send_res = Auth::send_encrypted_password(
-              src_channel, src_protocol, *encrypted_res);
-          if (!send_res) return send_server_failed(send_res.error());
-
-          stage(Stage::Response);
-          return Result::SendToServer;
-        }
-      }
-    } else {
-      // client's password is NOT known.
-      switch (msg.auth_method_data()[0]) {
-        case Auth::kFastAuthDone:
-          trace(Tracer::Event().stage("server::auth::fastauthdone"));
-
-          stage(Stage::Response);
-          return forward_server_to_client(true);  // followed by "Ok"
-        case Auth::kPerformFullAuth:
-          trace(Tracer::Event().stage("server::auth::request::plain"));
-
-          stage(Stage::ClientAuth);
-          return forward_server_to_client();
-        case '-': {
-          trace(Tracer::Event().stage("server::auth::public_key"));
-
-          stage(Stage::ClientAuth);
-          return forward_server_to_client();
-        }
-      }
-    }
-  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
-    using Auth = AuthSha256Password;
-
-    trace(Tracer::Event().stage("server::auth::public-key:\n" +
-                                hexify(msg.auth_method_data())));
-
-    if (dst_protocol->password().has_value()) {
-      auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-      if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("client::auth::password"));
-
-      auto encrypted_res =
-          Auth::rsa_encrypt_password(*pubkey_res, *(dst_protocol->password()),
-                                     src_protocol->auth_method_data());
-      if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-      auto send_res = Auth::send_encrypted_password(src_channel, src_protocol,
-                                                    *encrypted_res);
-      if (!send_res) return send_server_failed(send_res.error());
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    }
-
-    // public key.
-    stage(Stage::ClientAuth);
-    return forward_server_to_client();
-  }
-
-  std::cerr << __LINE__ << ":\n"
-            << src_protocol->auth_method_name() << "\n"
-            << hexify(msg.auth_method_data()) << "\n";
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstConnector::process() {
-  switch (stage()) {
-    case Stage::Connect:
-      return connect();
-    case Stage::ServerGreeting:
-      return server_greeting();
-    case Stage::ServerGreeted:
-      return server_greeted();
-
-      // the two exit-stages:
-      // - Error
-      // - Ok
-    case Stage::Error:
-    case Stage::Ok:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstConnector::connect() {
-  stage(Stage::ServerGreeting);
-
-  connection()->push_processor(
-      std::make_unique<ConnectProcessor>(connection()));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstConnector::server_greeting() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  // ConnectProcessor either:
-  //
-  // - closes the connection and sends an error to the client, or
-  // - keeps the connection open.
-  auto &server_conn = socket_splicer->server_conn();
-
-  if (!server_conn.is_open()) {
-    trace(Tracer::Event().stage("connect::error"));
-
-    stage(Stage::Error);
-
-    return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("server::greeting"));
-
-  stage(Stage::ServerGreeted);
-
-  connection()->push_processor(
-      std::make_unique<ServerGreetor>(connection(), false));
-
-  return Result::Again;
-}
-
-/**
- * received an server::greeting or server::error from the server.
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstConnector::server_greeted() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  auto &server_conn = socket_splicer->server_conn();
-
-  if (!server_conn.is_open()) {
-    stage(Stage::Error);
-  } else {
-    stage(Stage::Ok);
-  }
-
-  return Result::Again;
-}
-
-// server-side authentication
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::process() {
-  switch (stage()) {
-    case Stage::ClientGreeting:
-      return client_greeting();
-    case Stage::ClientGreetingStartTls:
-      return client_greeting_start_tls();
-    case Stage::ClientGreetingFull:
-      return client_greeting_full();
-    case Stage::TlsForwardInit:
-      return tls_forward_init();
-    case Stage::TlsForward:
-      return tls_forward();
-    case Stage::TlsConnectInit:
-      return tls_connect_init();
-    case Stage::TlsConnect:
-      return tls_connect();
-    case Stage::ClientGreetingAfterTls:
-      return client_greeting_after_tls();
-    case Stage::Response:
-      return response();
-    case Stage::AuthData:
-      return auth_data();
-    case Stage::AuthMethodSwitch:
-      return auth_method_switch();
-    case Stage::ClientAuth:
-      return client_auth();
-    case Stage::AuthError:
-      return auth_error();
-    case Stage::AuthOk:
-      return auth_ok();
-
-      // the two exit-stages:
-      // - Error
-      // - Ok
-    case Stage::Error:
-      return Result::Done;
-    case Stage::Ok:
-      connection()->authenticated(true);
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-// called after server connection is established.
-void ServerFirstAuthenticator::client_greeting_server_adjust_caps(
-    ClassicProtocolState *src_protocol, ClassicProtocolState *dst_protocol) {
-  auto client_caps = src_protocol->client_capabilities();
-
-  if (!src_protocol->shared_capabilities().test(
-          classic_protocol::capabilities::pos::ssl)) {
-    auto client_greeting_msg = src_protocol->client_greeting().value();
-
-    auto attrs_res = classic_proto_decode_and_add_connection_attributes(
-        src_protocol->attributes(), connection()
-                                        ->socket_splicer()
-                                        ->client_conn()
-                                        .initial_connection_attributes());
-
-    auto attrs = attrs_res.value_or(src_protocol->attributes());
-    dst_protocol->sent_attributes(attrs);
-    src_protocol->sent_attributes(attrs);
-
-    client_greeting_msg.attributes(attrs);
-
-    // client hasn't set the SSL cap, this is the real client greeting
-    dst_protocol->client_greeting(client_greeting_msg);
-  }
-
-  switch (connection()->dest_ssl_mode()) {
-    case SslMode::kDisabled:
-      // config says: communication to server is unencrypted
-      client_caps.reset(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kRequired:
-      // config says: communication to server must be encrypted
-      client_caps.set(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kPreferred:
-      // config says: communication to server should be encrypted if server
-      // supports it.
-      if (dst_protocol->server_capabilities().test(
-              classic_protocol::capabilities::pos::ssl)) {
-        client_caps.set(classic_protocol::capabilities::pos::ssl);
-      }
-      break;
-    case SslMode::kAsClient:
-      break;
-    case SslMode::kPassthrough:
-    case SslMode::kDefault:
-      harness_assert_this_should_not_execute();
-      break;
-  }
-  dst_protocol->client_capabilities(client_caps);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::client_greeting() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_protocol = connection()->server_protocol();
-
-  bool server_supports_tls = dst_protocol->server_capabilities().test(
-      classic_protocol::capabilities::pos::ssl);
-  bool client_uses_tls = src_protocol->shared_capabilities().test(
-      classic_protocol::capabilities::pos::ssl);
-
-  if (connection()->dest_ssl_mode() == SslMode::kAsClient && client_uses_tls &&
-      !server_supports_tls) {
-    // config says: do as the client did, and the client did SSL and server
-    // doesn't support it -> error
-
-    // send back to the client
-    const auto send_res = send_ssl_connection_error_msg(
-        src_channel, src_protocol,
-        "SSL connection error: Requirements can not be satisfied");
-    if (!send_res) return send_client_failed(send_res.error());
-
-    stage(Stage::Error);
-    return Result::SendToClient;
-  }
-
-  client_greeting_server_adjust_caps(src_protocol, dst_protocol);
-
-  // use the client-side's capabilities to make sure the server encodes
-  // the packets according to the client.
-  //
-  // src_protocol->shared_caps must be used here as the ->client_caps may
-  // contain more than what the router advertised.
-  auto client_caps = src_protocol->shared_capabilities();
-
-  switch (connection()->dest_ssl_mode()) {
-    case SslMode::kDisabled:
-      client_caps.reset(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kPreferred:
-      client_caps.set(classic_protocol::capabilities::pos::ssl,
-                      server_supports_tls);
-      break;
-    case SslMode::kRequired:
-      client_caps.set(classic_protocol::capabilities::pos::ssl);
-      break;
-    case SslMode::kAsClient:
-      client_caps.set(classic_protocol::capabilities::pos::ssl,
-                      client_uses_tls);
-      break;
-    case SslMode::kPassthrough:
-      // don't check caps on passthrough.
-      break;
-    case SslMode::kDefault:
-      log_debug("dest_ssl_mode::Default ... should not happen.");
-
-      return recv_client_failed(make_error_code(std::errc::invalid_argument));
-  }
-
-  dst_protocol->client_capabilities(client_caps);
-  dst_protocol->auth_method_name(src_protocol->auth_method_name());
-  dst_protocol->username(src_protocol->username());
-  dst_protocol->attributes(src_protocol->attributes());
-
-  // the client greeting was received and will be forwarded to the server
-  // soon.
-  connection()->client_greeting_sent(true);
-  connection()->on_handshake_received();
-
-  if (dst_protocol->shared_capabilities().test(
-          classic_protocol::capabilities::pos::ssl)) {
-    stage(Stage::ClientGreetingStartTls);
-
-  } else {
-    stage(Stage::ClientGreetingFull);
-  }
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::client_greeting_start_tls() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_protocol = connection()->server_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-
-  if (!src_protocol->client_greeting()) {
-    return send_server_failed(make_error_code(std::errc::invalid_argument));
-  }
-
-  auto initial_client_greeting_msg = src_protocol->client_greeting().value();
-
-  // use the shared capabilities of the client<->router connection as basis
-  auto client_caps = src_protocol->shared_capabilities();
-
-  client_caps.set(classic_protocol::capabilities::pos::ssl);
-
-  dst_protocol->client_capabilities(client_caps);
-
-  // setting username == "" leads to a short, switch-to-ssl
-  // client::Greeting.
-  auto send_res =
-      ClassicFrame::send_msg<classic_protocol::message::client::Greeting>(
-          dst_channel, dst_protocol,
-          {
-              client_caps, initial_client_greeting_msg.max_packet_size(),
-              initial_client_greeting_msg.collation(),
-              "",  // username
-              "",  // auth_method_data
-              "",  // schema
-              "",  // auth_method_name
-              ""   // attributes
-          });
-  if (!send_res) return send_server_failed(send_res.error());
-
-  if (connection()->source_ssl_mode() == SslMode::kPassthrough) {
-    trace(Tracer::Event().stage("client::greeting (forward-tls)"));
-
-    stage(Stage::TlsForwardInit);
-  } else {
-    trace(Tracer::Event().stage("client::greeting (start-tls)"));
-
-    stage(Stage::TlsConnectInit);
-
-    // leave msg in the send buffer as tls_connect() will flush it.
-
-    // Result::SendToServer
-    //       2041 us (      +115 us)      r<-s io::recv
-    //       2044 us (        +2 us)           server::greeting?
-    //       2049 us (        +5 us)           server::greeting::greeting
-    //       2056 us (        +6 us)           client::greeting
-    //       2068 us (       +12 us)      r->s io::send  << this one
-    //       2233 us (      +164 us)           tls::connect
-    //       2249 us (       +16 us)      r->s io::send
-
-    // Result::Again
-    //       2005 us (      +138 us)      r<-s io::recv
-    //       2008 us (        +2 us)           server::greeting?
-    //       2014 us (        +6 us)           server::greeting::greeting
-    //       2021 us (        +6 us)           client::greeting
-    //       2090 us (       +68 us)           tls::connect
-    //       2113 us (       +23 us)      r->s io::send
-  }
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::client_greeting_full() {
-  trace(Tracer::Event().stage("client::greeting (full)"));
-
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-  auto *dst_protocol = connection()->server_protocol();
-
-  auto client_greeting_msg = src_protocol->client_greeting().value();
-
-  const auto attrs_res = classic_proto_decode_and_add_connection_attributes(
-      src_protocol->attributes(),
-      vector_splice(
-          socket_splicer->client_conn().initial_connection_attributes(),
-          client_ssl_connection_attributes(src_channel->ssl())));
-  if (!attrs_res) {
-    auto ec = attrs_res.error();
-    // if decode/append fails forward the attributes as is. The server should
-    // fail too.
-    //
-    if (src_protocol->client_capabilities().test(
-            classic_protocol::capabilities::pos::connect_attributes)) {
-      log_warning("%d: decoding connection attributes failed [ignored]: (%s) ",
-                  __LINE__, ec.message().c_str());
-    }
-  }
-
-  auto attrs = attrs_res.value_or(src_protocol->attributes());
-  dst_protocol->sent_attributes(attrs);
-  src_protocol->sent_attributes(attrs);
-
-  client_greeting_msg.capabilities(dst_protocol->client_capabilities());
-  client_greeting_msg.attributes(attrs);
-
-  if (src_protocol->password().has_value()) {
-    // scramble with the server's auth-data to trigger a fast-auth.
-
-    auto pwd = *(src_protocol->password());
-
-    // if the password set and not empty, rehash it.
-    if (!pwd.empty()) {
-      if (auto scramble_res = scramble_them_all(
-              client_greeting_msg.auth_method_name(),
-              strip_trailing_null(
-                  dst_protocol->server_greeting()->auth_method_data()),
-              pwd)) {
-        client_greeting_msg.auth_method_data(*scramble_res);
-      }
-    }
-  }
-
-  dst_protocol->auth_method_name(src_protocol->auth_method_name());
-
-  return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
-      .and_then(
-          [this](auto /* unused */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::Response);
-
-            return Result::SendToServer;
-          })
-      .or_else([this](auto err) { return send_server_failed(err); });
-}
-
-static TlsErrc forward_tls(Channel *src_channel, Channel *dst_channel) {
-  auto &plain = src_channel->recv_plain_buffer();
-  src_channel->read_to_plain(5);
-
-  auto plain_buf = net::dynamic_buffer(plain);
-  // at least the TLS record header.
-  const size_t tls_header_size{5};
-  while (plain_buf.size() >= tls_header_size) {
-    // plain is TLS traffic.
-    const uint8_t tls_content_type = plain[0];
-    const uint16_t tls_payload_size = (plain[3] << 8) | plain[4];
-
-#if defined(DEBUG_SSL)
-    const uint16_t tls_legacy_version = (plain[1] << 8) | plain[2];
-
-    log_debug("-- ssl: ver=%04x, len=%d, %s", tls_legacy_version,
-              tls_payload_size,
-              tls_content_type_to_string(
-                  static_cast<TlsContentType>(tls_content_type))
-                  .c_str());
-#endif
-    if (plain_buf.size() < tls_header_size + tls_payload_size) {
-      src_channel->read_to_plain(tls_header_size + tls_payload_size -
-                                 plain_buf.size());
-    }
-
-    if (plain_buf.size() < tls_header_size + tls_payload_size) {
-      // there isn't the full frame yet.
-      return TlsErrc::kWantRead;
-    }
-
-    const auto write_res = dst_channel->write(
-        plain_buf.data(0, tls_header_size + tls_payload_size));
-    if (!write_res) {
-      return TlsErrc::kWantWrite;
-    }
-
-    // if TlsAlert in handshake, the connection goes back to plain
-    if (static_cast<TlsContentType>(tls_content_type) ==
-            TlsContentType::kAlert &&
-        plain.size() >= 6 && plain[5] == 0x02) {
-      src_channel->is_tls(false);
-      dst_channel->is_tls(false);
-    }
-    plain_buf.consume(write_res.value());
-  }
-
-  // want more
-  return TlsErrc::kWantRead;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::tls_forward() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  auto client_channel = socket_splicer->client_channel();
-  auto server_channel = socket_splicer->server_channel();
-
-  bool client_recv_buf_changed =
-      client_last_recv_buf_size_ != client_channel->recv_buffer().size();
-  bool server_recv_buf_changed =
-      server_last_recv_buf_size_ != server_channel->recv_buffer().size();
-  bool client_send_buf_changed =
-      client_last_send_buf_size_ != client_channel->send_buffer().size();
-  bool server_send_buf_changed =
-      server_last_send_buf_size_ != server_channel->send_buffer().size();
-
-  if (client_recv_buf_changed || server_send_buf_changed) {
-    forward_tls(client_channel, server_channel);
-
-    client_last_recv_buf_size_ = client_channel->recv_buffer().size();
-    server_last_send_buf_size_ = server_channel->send_buffer().size();
-
-    if (!server_channel->send_buffer().empty()) {
-      return Result::SendToServer;
-    }
-
-    return Result::RecvFromClient;
-
-  } else if (server_recv_buf_changed || client_send_buf_changed) {
-    forward_tls(server_channel, client_channel);
-
-    server_last_recv_buf_size_ = server_channel->recv_buffer().size();
-    client_last_send_buf_size_ = client_channel->send_buffer().size();
-
-    if (!client_channel->send_buffer().empty()) {
-      return Result::SendToClient;
-    }
-
-    return Result::RecvFromServer;
-  }
-
-  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::tls_forward_init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *dst_channel = socket_splicer->server_channel();
-
-  dst_channel->is_tls(true);
-  src_channel->is_tls(true);
-
-  // if there is already data in the recv-buffer, forward that.
-  forward_tls(src_channel, dst_channel);
-  if (!dst_channel->send_buffer().empty()) {
-    return Result::SendToServer;
-  }
-
-  stage(Stage::TlsForward);
-  return Result::RecvFromBoth;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::tls_connect_init() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *dst_channel = socket_splicer->server_channel();
-
-  auto ssl_ctx_res = get_dest_ssl_ctx(connection()->context(),
-                                      connection()->get_destination_id());
-  if (!ssl_ctx_res || ssl_ctx_res.value() == nullptr) {
-    // shouldn't happen. But if it does, close the connection.
-    log_warning("failed to create SSL_CTX");
-
-    return send_server_failed(make_error_code(std::errc::invalid_argument));
-  }
-  dst_channel->init_ssl(*ssl_ctx_res);
-
-  connection()->requires_tls(true);
-
-  stage(Stage::TlsConnect);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::tls_connect() {
-  auto *socket_splicer = connection()->socket_splicer();
-
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-
-  {
-    const auto flush_res = dst_channel->flush_from_recv_buf();
-    if (!flush_res) {
-      auto ec = flush_res.error();
-      log_fatal_error_code("tls_connect::recv::flush() failed", ec);
-
-      return recv_server_failed(ec);
-    }
-  }
-
-  if (!dst_channel->tls_init_is_finished()) {
-    const auto res = dst_channel->tls_connect();
-
-    trace(Tracer::Event().stage("tls::connect"));
-
-    if (!res) {
-      if (res.error() == TlsErrc::kWantRead) {
-        {
-          const auto flush_res = dst_channel->flush_to_send_buf();
-          if (!flush_res &&
-              (flush_res.error() !=
-               make_error_condition(std::errc::operation_would_block))) {
-            auto ec = flush_res.error();
-            log_fatal_error_code("flushing failed", ec);
-
-            return send_server_failed(ec);
-          }
-        }
-
-        if (!dst_channel->send_buffer().empty()) {
-          return Result::SendToServer;
-        }
-        return Result::RecvFromServer;
-      } else {
-        // connect may fail fatally if
-        //
-        // - cert-verification failed.
-        // - no shared cipher
-
-        const auto send_res = send_ssl_connection_error_msg(
-            src_channel, src_protocol,
-            "connecting to destination failed with TLS error: " +
-                res.error().message());
-        if (!send_res) {
-          auto ec = send_res.error();
-          log_fatal_error_code("sending error failed", ec);
-
-          return send_client_failed(ec);
-        }
-
-        trace(Tracer::Event().stage("server::greeting::error"));
-
-        stage(Stage::Error);
-        return Result::SendToClient;
-      }
-    }
-  }
-
-  stage(Stage::ClientGreetingAfterTls);
-  // tls is established to the server, send the client::greeting
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::client_greeting_after_tls() {
-  trace(Tracer::Event().stage("client::greeting(first)"));
-
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-  auto *dst_protocol = connection()->server_protocol();
-
-  auto client_greeting_msg = *src_protocol->client_greeting();
-
-  const auto attrs_res = classic_proto_decode_and_add_connection_attributes(
-      src_protocol->attributes(),
-      vector_splice(
-          socket_splicer->client_conn().initial_connection_attributes(),
-          client_ssl_connection_attributes(src_channel->ssl())));
-  if (!attrs_res) {
-    auto ec = attrs_res.error();
-    // if decode/append fails forward the attributes as is. The server should
-    // fail too.
-    //
-    if (src_protocol->client_capabilities().test(
-            classic_protocol::capabilities::pos::connect_attributes)) {
-      log_warning("%d: decoding connection attributes failed [ignored]: (%s) ",
-                  __LINE__, ec.message().c_str());
-    }
-  }
-
-  dst_protocol->username(client_greeting_msg.username());
-
-  auto attrs = attrs_res.value_or(src_protocol->attributes());
-  dst_protocol->sent_attributes(attrs);
-  src_protocol->sent_attributes(attrs);
-
-  // the client's attributes, as they are sent to the server.
-
-  client_greeting_msg.capabilities(dst_protocol->client_capabilities());
-  client_greeting_msg.attributes(attrs);
-
-  if (src_protocol->password().has_value()) {
-    // scramble with the server's auth-data to trigger a fast-auth.
-
-    auto pwd = *(src_protocol->password());
-
-    // if the password set and not empty, rehash it.
-    if (!pwd.empty()) {
-      if (auto scramble_res = scramble_them_all(
-              client_greeting_msg.auth_method_name(),
-              strip_trailing_null(
-                  dst_protocol->server_greeting()->auth_method_data()),
-              pwd)) {
-        client_greeting_msg.auth_method_data(*scramble_res);
-      }
-    }
-  }
-
-  return ClassicFrame::send_msg(dst_channel, dst_protocol, client_greeting_msg)
-      .and_then(
-          [this](auto /* unused */) -> stdx::expected<Result, std::error_code> {
-            stage(Stage::Response);
-
-            return Result::SendToServer;
-          })
-      .or_else([this](auto err) { return send_server_failed(err); });
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::response() {
-  // ERR|OK|EOF|other
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // ensure the recv_buf has at last frame-header (+ msg-byte)
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) {
-    auto ec = read_res.error();
-
-    if (ec == TlsErrc::kWantRead) return Result::RecvFromServer;
-
-    return recv_server_failed(ec);
-  }
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    AuthMethodSwitch = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodSwitch>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    AuthMethodData = ClassicFrame::cmd_byte<
-        classic_protocol::message::server::AuthMethodData>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::AuthMethodSwitch:
-      stage(Stage::AuthMethodSwitch);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::AuthOk);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::AuthError);
-      return Result::Again;
-    case Msg::AuthMethodData:
-      stage(Stage::AuthData);
-      return Result::Again;
-  }
-
-  // if there is another packet, dump its payload for now.
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  // get as much data of the current frame from the recv-buffers to log it.
-  (void)ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-
-  log_debug(
-      "received unexpected message from server after a client::Greeting: %s",
-      hexify(recv_buf).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-/**
- * router<-server: auth error.
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::auth_error() {
-  trace(Tracer::Event().stage("server::auth::error"));
-
-  stage(Stage::Error);  // close the server connection after the Error msg was
-                        // sent.
-
-  return forward_server_to_client();
-}
-
-/**
- * server-side: auth is ok.
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::auth_ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("server::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    (void)connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  stage(Stage::Ok);
-
-  return forward_server_to_client();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::auth_method_switch() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-  auto *dst_protocol = connection()->client_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<
-      classic_protocol::message::server::AuthMethodSwitch>(src_channel,
-                                                           src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(
-      Tracer::Event().stage("server::auth::switch: " + msg_res->auth_method()));
-
-  auto msg = std::move(*msg_res);
-
-  src_protocol->auth_method_name(msg.auth_method());
-  src_protocol->auth_method_data(msg.auth_method_data());
-
-#if defined(DEBUG_IO)
-  std::cerr << __LINE__ << ": auth_method_name: " << msg.auth_method() << "\n";
-  std::cerr << __LINE__ << ": auth_method_data:\n"
-            << hexify(msg.auth_method_data()) << "\n";
-#endif
-
-  if (dst_protocol->password().has_value()) {
-    auto pwd = *(dst_protocol->password());
-
-    if (msg.auth_method() == AuthSha256Password::kName && !src_channel->ssl()) {
-      using Auth = AuthSha256Password;
-
-      discard_current_msg(src_channel, src_protocol);
-      if (pwd.empty()) {
-        trace(Tracer::Event().stage("client::auth::plain"));
-
-        auto send_res =
-            Auth::send_plaintext_password(src_channel, src_protocol, pwd);
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        // the server is NOT encrypted: ask for the server's publickey
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-
-        auto send_res =
-            Auth::send_public_key_request(src_channel, src_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    }
-
-    // if the password set and not empty, rehash it.
-    if (auto scramble_res = scramble_them_all(
-            msg.auth_method(), strip_trailing_null(msg.auth_method_data()),
-            pwd)) {
-      discard_current_msg(src_channel, src_protocol);
-
-      auto send_res = ClassicFrame::send_msg<classic_protocol::wire::String>(
-          src_channel, src_protocol, {*scramble_res});
-      if (!send_res) return stdx::make_unexpected(send_res.error());
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    } else {
-      return send_server_failed(make_error_code(std::errc::bad_message));
-    }
-  } else {
-    dst_protocol->auth_method_name(msg.auth_method());
-    dst_protocol->auth_method_data(msg.auth_method_data());
-
-    stage(Stage::ClientAuth);
-    return forward_server_to_client();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::client_auth() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->client_channel();
-  auto *src_protocol = connection()->client_protocol();
-  auto *dst_channel = socket_splicer->server_channel();
-  auto *dst_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("client::auth:\n" +
-                              src_protocol->auth_method_name()));
-
-  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
-    using Auth = AuthCachingSha2Password;
-
-    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
-        connection_has_public_key(connection())) {
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("server::auth::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) return send_client_failed(pubkey_res.error());
-
-      auto send_res =
-          Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-      if (!send_res) return send_client_failed(send_res.error());
-
-      return Result::SendToClient;
-    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
-               connection_has_public_key(connection())) {
-      trace(Tracer::Event().stage("client::auth::encrypted:\n" +
-                                  hexify(src_protocol->auth_method_data())));
-
-      auto recv_res = Auth::rsa_decrypt_password(
-          connection()->context().source_ssl_ctx()->get(),
-          msg_res->auth_method_data(), src_protocol->auth_method_data());
-      if (!recv_res) return recv_client_failed(recv_res.error());
-
-      src_protocol->password(*recv_res);
-
-      trace(Tracer::Event().stage("client::auth::password\n" +
-                                  hexify(*src_protocol->password())));
-
-      discard_current_msg(src_channel, src_protocol);
-
-      if (dst_channel->ssl()) {
-        // the server-side is encrypted: send plaintext password
-        trace(Tracer::Event().stage("client::auth::plaintext_password"));
-
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        // the server is NOT encrypted: ask for the server's publickey
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    }
-  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
-    using Auth = AuthSha256Password;
-
-    if (Auth::is_public_key_request(msg_res->auth_method_data()) &&
-        connection_has_public_key(connection())) {
-      // if the client is not encrypted, it may ask for the server's public-key
-      // via 0x01
-      //
-      // if the server is encrypted, it doesn't expect that 0x01 and will treat
-      // it as plaintext password.
-
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("server::auth::public_key"));
-
-      auto pubkey_res = Auth::public_key_from_ssl_ctx_as_pem(
-          connection()->context().source_ssl_ctx()->get());
-      if (!pubkey_res) return send_client_failed(pubkey_res.error());
-
-      auto send_res =
-          Auth::send_public_key(src_channel, src_protocol, *pubkey_res);
-      if (!send_res) return send_client_failed(send_res.error());
-
-      return Result::SendToClient;
-    } else if (Auth::is_public_key(msg_res->auth_method_data()) &&
-               connection_has_public_key(connection())) {
-      auto recv_res = Auth::rsa_decrypt_password(
-          connection()->context().source_ssl_ctx()->get(),
-          msg_res->auth_method_data(), src_protocol->auth_method_data());
-      if (!recv_res) return recv_client_failed(recv_res.error());
-
-      src_protocol->password(*recv_res);
-
-      discard_current_msg(src_channel, src_protocol);
-
-      if (dst_channel->ssl()) {
-        trace(Tracer::Event().stage("client::auth::password"));
-        // the server-side is encrypted: send plaintext password
-        auto send_res = Auth::send_plaintext_password(
-            dst_channel, dst_protocol, *src_protocol->password());
-        if (!send_res) return send_server_failed(send_res.error());
-      } else {
-        // the server is NOT encrypted: ask for the server's public-key
-        trace(Tracer::Event().stage("client::auth::request_public_key"));
-        auto send_res =
-            Auth::send_public_key_request(dst_channel, dst_protocol);
-        if (!send_res) return send_server_failed(send_res.error());
-      }
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    }
-  }
-
-  stage(Stage::Response);
-  return forward_client_to_server();
-}
-
-/**
- *
- * server->router
- */
-stdx::expected<Processor::Result, std::error_code>
-ServerFirstAuthenticator::auth_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-  auto dst_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::AuthMethodData>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto msg = std::move(*msg_res);
-
-  if (src_protocol->auth_method_name() == AuthCachingSha2Password::kName) {
-    using Auth = AuthCachingSha2Password;
-
-    if (msg.auth_method_data().size() < 1) {
-      log_debug("%d", __LINE__);
-      return recv_server_failed(make_error_code(std::errc::bad_message));
-    }
-
-    if (dst_protocol->password().has_value()) {
-      // client's password is known.
-
-      auto opt_pwd = dst_protocol->password();
-
-      switch (msg.auth_method_data()[0]) {
-        case Auth::kFastAuthDone:
-          trace(Tracer::Event().stage("server::auth::fastauthdone"));
-          // 0x03 means the client-greeting provided the right scrambled
-          // password that matches the cached entry.
-
-          // as there is a password provided by the client via
-          // client_recv_plaintext_password() the client side expects either
-          // server::Ok or server::Error now.
-          //
-          // c<-r: server::greeting (from router)
-          // c->r: client::greeting (with tls handshake)
-          // c<-r: 0x01 0x04
-          // c->r: password
-          //    r->s: connect()
-          //    r<-s: server::greeting
-          //    r->s: client::greeting (with tls handshake, rehashed pwd)
-          //    r<-s: 0x01 0x03   // current message
-          //    r<-s: server::Ok
-          // c<-r: server::Ok
-          discard_current_msg(src_channel, src_protocol);
-
-          stage(Stage::Response);
-          return Result::Again;
-        case Auth::kPerformFullAuth: {
-          trace(Tracer::Event().stage("server::auth::request::plain"));
-
-          // as the client already provided a password, provide it to the
-          // server directly.
-          discard_current_msg(src_channel, src_protocol);
-
-          trace(Tracer::Event().stage("client::auth::plain"));
-
-          auto send_res = ClassicFrame::send_msg<
-              classic_protocol::message::client::AuthMethodData>(
-              src_channel, src_protocol, {*opt_pwd + "\0"s});
-          if (!send_res) return send_server_failed(send_res.error());
-
-          // send it to the server.
-          stage(Stage::Response);
-          return Result::SendToServer;
-        }
-        case '-': {
-          auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-          if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-          discard_current_msg(src_channel, src_protocol);
-
-          trace(Tracer::Event().stage("client::auth::password"));
-
-          auto encrypted_res = Auth::rsa_encrypt_password(
-              *pubkey_res, *(dst_protocol->password()),
-              src_protocol->auth_method_data());
-          if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-          auto send_res = Auth::send_encrypted_password(
-              src_channel, src_protocol, *encrypted_res);
-          if (!send_res) return send_server_failed(send_res.error());
-
-          stage(Stage::Response);
-          return Result::SendToServer;
-        }
-      }
-    } else {
-      // client's password is NOT known.
-      switch (msg.auth_method_data()[0]) {
-        case Auth::kFastAuthDone:
-          trace(Tracer::Event().stage("server::auth::fastauthdone"));
-
-          stage(Stage::Response);
-          return forward_server_to_client(true);  // followed by "Ok"
-        case Auth::kPerformFullAuth:
-          trace(Tracer::Event().stage("server::auth::request::plain"));
-
-          stage(Stage::ClientAuth);
-          return forward_server_to_client();
-        case '-':
-          trace(Tracer::Event().stage("server::auth::public_key"));
-
-          stage(Stage::ClientAuth);
-          return forward_server_to_client();
-      }
-    }
-  } else if (src_protocol->auth_method_name() == AuthSha256Password::kName) {
-    using Auth = AuthSha256Password;
-
-    if (dst_protocol->password().has_value()) {
-      auto pubkey_res = Auth::public_key_from_pem(msg.auth_method_data());
-      if (!pubkey_res) return recv_server_failed(pubkey_res.error());
-
-      discard_current_msg(src_channel, src_protocol);
-
-      trace(Tracer::Event().stage("client::auth::password"));
-
-      auto encrypted_res =
-          Auth::rsa_encrypt_password(*pubkey_res, *(dst_protocol->password()),
-                                     src_protocol->auth_method_data());
-      if (!encrypted_res) return send_server_failed(encrypted_res.error());
-
-      auto send_res = Auth::send_encrypted_password(src_channel, src_protocol,
-                                                    *encrypted_res);
-      if (!send_res) return send_server_failed(send_res.error());
-
-      stage(Stage::Response);
-      return Result::SendToServer;
-    }
-
-    stage(Stage::ClientAuth);
-    return forward_server_to_client();
-  }
-
-  log_debug("unexpected message from server at client::auth in %s\n%s",
-            src_protocol->auth_method_name().c_str(),
-            hexify(msg.auth_method_data()).c_str());
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
diff --git a/router/src/routing/src/classic_greeting.h b/router/src/routing/src/classic_greeting.h
deleted file mode 100644
index 88d9a2005d8..00000000000
--- a/router/src/routing/src/classic_greeting.h
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_GREETING_INCLUDED
-#define ROUTING_CLASSIC_GREETING_INCLUDED
-
-#include "processor.h"
-
-/**
- * classic protocol handshake between client<->router (and router<->server).
- *
- *
- */
-class ClientGreetor : public Processor {
- public:
-  using Processor::Processor;
-
-  /**
-   * stages of the handshake flow.
-   */
-  enum class Stage {
-    Init,
-    ServerGreeting,
-    ServerFirstGreeting,
-    ClientGreeting,
-    TlsAcceptInit,
-    TlsAccept,
-    ClientGreetingAfterTls,
-    RequestPlaintextPassword,
-    PlaintextPassword,
-    Accepted,
-    Authenticated,
-
-    Error,
-    Ok,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> init();
-  stdx::expected<Result, std::error_code> server_greeting();
-  stdx::expected<Result, std::error_code> server_first_greeting();
-  stdx::expected<Result, std::error_code> client_greeting();
-  stdx::expected<Result, std::error_code> tls_accept_init();
-  stdx::expected<Result, std::error_code> tls_accept();
-  stdx::expected<Result, std::error_code> client_greeting_after_tls();
-  stdx::expected<Result, std::error_code> request_plaintext_password();
-  stdx::expected<Result, std::error_code> plaintext_password();
-  stdx::expected<Result, std::error_code> accepted();
-  stdx::expected<Result, std::error_code> authenticated();
-  stdx::expected<Result, std::error_code> error();
-
-  Stage stage_{Stage::Init};
-};
-
-/**
- * classic protocol handshake between client<->router and router<->server.
- */
-class ServerGreetor : public Processor {
- public:
-  /**
-   * construct a server::greeting processor.
-   *
-   *     c->r   : ...
-   *        r->s: connect()
-   *        r<-s: server::greeting
-   *
-   * a server greeting may be sent as part of the initial connection
-   * setup between client<->router<->server (in_handshake=true) or
-   * when router starts a connection on its own.
-   *
-   * If `in_handshake` is true, a auth-method switch request by the
-   * server can be sent to the client.
-   *
-   * The ServerGreetor expects it can send
-   *
-   * - server::Error
-   * - server::AuthMethodSwitch and server::Ok (if in_handshake==true)
-   *
-   * to the client connection.
-   *
-   * @param conn the connection the greeting will be transferred on.
-   * @param in_handshake true if the greeting is part of the initial
-   * handshake.
-   */
-  ServerGreetor(MysqlRoutingClassicConnection *conn, bool in_handshake)
-      : Processor(conn), in_handshake_{in_handshake} {}
-
-  /**
-   * stages of the handshake flow.
-   *
-   * - Client stages are on the client<->router side.
-   * - Server stages are on the router<->server side.
-   */
-  enum class Stage {
-    ServerGreeting,
-    ServerGreetingError,
-    ServerGreetingGreeting,
-    ClientGreeting,
-    ClientGreetingStartTls,
-    ClientGreetingFull,
-    TlsConnectInit,
-    TlsConnect,
-    ClientGreetingAfterTls,
-    Response,
-    AuthMethodSwitch,
-    ClientAuth,
-    AuthOk,
-    AuthError,
-    AuthData,
-
-    ServerGreetingSent,
-    Error,
-    Ok,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> server_greeting();
-  stdx::expected<Result, std::error_code> server_greeting_greeting();
-  stdx::expected<Result, std::error_code> server_greeting_error();
-  stdx::expected<Result, std::error_code> client_greeting();
-  stdx::expected<Result, std::error_code> client_greeting_start_tls();
-  stdx::expected<Result, std::error_code> client_greeting_full();
-  stdx::expected<Result, std::error_code> tls_connect_init();
-  stdx::expected<Result, std::error_code> tls_connect();
-  stdx::expected<Result, std::error_code> client_greeting_after_tls();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> client_auth();
-  stdx::expected<Result, std::error_code> auth_error();
-  stdx::expected<Result, std::error_code> auth_ok();
-  stdx::expected<Result, std::error_code> auth_data();
-  stdx::expected<Result, std::error_code> auth_method_switch();
-  stdx::expected<Result, std::error_code> error();
-
-  void client_greeting_server_adjust_caps(ClassicProtocolState *src_protocol,
-                                          ClassicProtocolState *dst_protocol);
-
-  bool in_handshake_;
-
-  Stage stage_{Stage::ServerGreeting};
-};
-
-/**
- * classic protocol handshake between router<->server and client<->router.
- */
-class ServerFirstConnector : public Processor {
- public:
-  /**
-   * construct a server::greeting processor fetches a server::greeting
-   * to send it to the client.
-   *
-   *     c->r   : accept()
-   *        r->s: connect()
-   *        r<-s: server::greeting
-   *     c<-r   : ...
-   *
-   * @param conn the connection the greeting will be transferred on.
-   */
-  ServerFirstConnector(MysqlRoutingClassicConnection *conn) : Processor(conn) {}
-
-  /**
-   * stages of the handshake flow.
-   */
-  enum class Stage {
-    Connect,
-    ServerGreeting,
-    ServerGreeted,
-
-    Error,
-    Ok,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> connect();
-  stdx::expected<Result, std::error_code> server_greeting();
-  stdx::expected<Result, std::error_code> server_greeted();
-
-  Stage stage_{Stage::Connect};
-};
-
-/**
- * authenticates a server connection.
- *
- * Assumes the server
- *
- * 1. sent a server::greeting already
- * 2. expects to receive a client::greeting
- */
-class ServerFirstAuthenticator : public Processor {
- public:
-  ServerFirstAuthenticator(MysqlRoutingClassicConnection *conn)
-      : Processor(conn) {}
-
-  /**
-   * stages of the handshake flow.
-   */
-  enum class Stage {
-    ClientGreeting,
-    ClientGreetingStartTls,
-    ClientGreetingFull,
-    TlsForwardInit,
-    TlsForward,
-    TlsConnectInit,
-    TlsConnect,
-    ClientGreetingAfterTls,
-    Response,
-    AuthMethodSwitch,
-    ClientAuth,
-    AuthOk,
-    AuthError,
-    AuthData,
-
-    Error,
-    Ok,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> client_greeting();
-  stdx::expected<Result, std::error_code> client_greeting_start_tls();
-  stdx::expected<Result, std::error_code> client_greeting_full();
-  stdx::expected<Result, std::error_code> tls_forward_init();
-  stdx::expected<Result, std::error_code> tls_forward();
-  stdx::expected<Result, std::error_code> tls_connect_init();
-  stdx::expected<Result, std::error_code> tls_connect();
-  stdx::expected<Result, std::error_code> client_greeting_after_tls();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> client_auth();
-  stdx::expected<Result, std::error_code> auth_error();
-  stdx::expected<Result, std::error_code> auth_ok();
-  stdx::expected<Result, std::error_code> auth_data();
-  stdx::expected<Result, std::error_code> auth_method_switch();
-
-  void client_greeting_server_adjust_caps(ClassicProtocolState *src_protocol,
-                                          ClassicProtocolState *dst_protocol);
-
-  size_t client_last_recv_buf_size_{};
-  size_t client_last_send_buf_size_{};
-  size_t server_last_recv_buf_size_{};
-  size_t server_last_send_buf_size_{};
-
-  Stage stage_{Stage::ClientGreeting};
-};
-
-#endif
diff --git a/router/src/routing/src/classic_init_schema.cc b/router/src/routing/src/classic_init_schema.cc
deleted file mode 100644
index d62c55f8575..00000000000
--- a/router/src/routing/src/classic_init_schema.cc
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_init_schema.h"
-
-#include "classic_connection.h"
-#include "classic_forwarder.h"
-#include "classic_frame.h"
-#include "classic_lazy_connect.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysql/harness/tls_error.h"
-#include "tracer.h"
-
-// init-schema
-
-stdx::expected<Processor::Result, std::error_code>
-InitSchemaForwarder::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Connect:
-      return connect();
-    case Stage::Connected:
-      return connected();
-    case Stage::Response:
-      return response();
-    case Stage::Ok:
-      return ok();
-    case Stage::Error:
-      return error();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-InitSchemaForwarder::command() {
-  trace(Tracer::Event().stage("init_schema::command"));
-
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  if (!server_conn.is_open()) {
-    stage(Stage::Connect);
-    return Result::Again;
-  } else {
-    stage(Stage::Response);
-    return forward_client_to_server();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-InitSchemaForwarder::connect() {
-  trace(Tracer::Event().stage("init_schema::connect"));
-
-  stage(Stage::Connected);
-
-  connection()->push_processor(
-      std::make_unique<LazyConnector>(connection(), false /* in-handshake */));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-InitSchemaForwarder::connected() {
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  if (!server_conn.is_open()) {
-    // Connector sent an server::Error already.
-    auto *socket_splicer = connection()->socket_splicer();
-    auto src_channel = socket_splicer->client_channel();
-    auto src_protocol = connection()->client_protocol();
-
-    // take the client::command from the connection.
-    auto recv_res =
-        ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-    if (!recv_res) return recv_client_failed(recv_res.error());
-
-    discard_current_msg(src_channel, src_protocol);
-
-    trace(Tracer::Event().stage("init_schema::error"));
-
-    stage(Stage::Done);
-    return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("init_schema::connected"));
-
-  stage(Stage::Response);
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-InitSchemaForwarder::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("init_schema::response"));
-
-  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> InitSchemaForwarder::ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  // Ok packet may have session trackers.
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("init_schema::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    // ignore the "some_state_changed" which would make the connection not
-    // sharable even though we can nicely recover.
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()), src_protocol->shared_capabilities(),
-        true /* ignore some_state_changed */);
-  }
-
-  stage(Stage::Done);
-
-  return forward_server_to_client();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-InitSchemaForwarder::error() {
-  trace(Tracer::Event().stage("init_schema::error"));
-
-  stage(Stage::Done);
-
-  return forward_server_to_client();
-}
-
-stdx::expected<Processor::Result, std::error_code> InitSchemaSender::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Response:
-      return response();
-    case Stage::Ok:
-      return ok();
-    case Stage::Error:
-      return error();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> InitSchemaSender::command() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  trace(Tracer::Event().stage("init_schema::command"));
-  trace(Tracer::Event().stage(">> " + schema_));
-
-  dst_protocol->seq_id(0xff);
-
-  auto send_res =
-      ClassicFrame::send_msg<classic_protocol::message::client::InitSchema>(
-          dst_channel, dst_protocol, schema_);
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-InitSchemaSender::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("init_schema::response"));
-
-  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> InitSchemaSender::ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("init_schema::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()), src_protocol->shared_capabilities(),
-        true /* ignore some-stage-changed. */
-    );
-  }
-
-  discard_current_msg(src_channel, src_protocol);
-
-  stage(Stage::Done);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> InitSchemaSender::error() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::Error>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("init_schema::error"));
-
-  discard_current_msg(src_channel, src_protocol);
-
-  stage(Stage::Done);
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_init_schema.h b/router/src/routing/src/classic_init_schema.h
deleted file mode 100644
index 0a0284421a0..00000000000
--- a/router/src/routing/src/classic_init_schema.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_INIT_SCHEMA_INCLUDED
-#define ROUTING_CLASSIC_INIT_SCHEMA_INCLUDED
-
-#include "processor.h"
-
-class InitSchemaForwarder : public Processor {
- public:
-  using Processor::Processor;
-
-  enum class Stage {
-    Command,
-    Connect,
-    Connected,
-    Response,
-    Ok,
-    Error,
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> connect();
-  stdx::expected<Result, std::error_code> connected();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> ok();
-  stdx::expected<Result, std::error_code> error();
-
-  Stage stage_{Stage::Command};
-};
-
-class InitSchemaSender : public Processor {
- public:
-  InitSchemaSender(MysqlRoutingClassicConnection *conn, std::string schema)
-      : Processor(conn), schema_{std::move(schema)} {}
-
-  enum class Stage {
-    Command,
-    Response,
-    Ok,
-    Error,
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> ok();
-  stdx::expected<Result, std::error_code> error();
-
-  Stage stage_{Stage::Command};
-
-  std::string schema_;
-};
-
-#endif
diff --git a/router/src/routing/src/classic_lazy_connect.cc b/router/src/routing/src/classic_lazy_connect.cc
deleted file mode 100644
index c1e7874fa68..00000000000
--- a/router/src/routing/src/classic_lazy_connect.cc
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_lazy_connect.h"
-
-#include "classic_change_user.h"
-#include "classic_connect.h"
-#include "classic_connection.h"
-#include "classic_greeting.h"
-#include "classic_init_schema.h"
-#include "classic_query.h"
-#include "classic_reset_connection.h"
-#include "hexify.h"
-
-using mysql_harness::hexify;
-
-stdx::expected<Processor::Result, std::error_code> LazyConnector::process() {
-  switch (stage()) {
-    case Stage::Connect:
-      return connect();
-    case Stage::Connected:
-      return connected();
-    case Stage::Authenticated:
-      return authenticated();
-    case Stage::SetSchema:
-      return set_schema();
-    case Stage::SetVars:
-      return set_vars();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> LazyConnector::connect() {
-  trace(Tracer::Event().stage("connect::connect"));
-
-  auto *socket_splicer = connection()->socket_splicer();
-  auto &server_conn = socket_splicer->server_conn();
-
-  if (!server_conn.is_open()) {
-    stage(Stage::Connected);
-
-    // creates a fresh connection or takes one from the pool.
-    connection()->push_processor(
-        std::make_unique<ConnectProcessor>(connection()));
-  } else {
-    stage(Stage::Done);  // there still is a connection open, nothing to do.
-  }
-
-  return Result::Again;
-}
-
-/**
- * the handshake part.
- */
-stdx::expected<Processor::Result, std::error_code> LazyConnector::connected() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto &server_conn = socket_splicer->server_conn();
-  auto client_protocol = connection()->client_protocol();
-  auto server_protocol = connection()->server_protocol();
-
-  if (!server_conn.is_open()) {
-    trace(Tracer::Event().stage("connect::not_connected"));
-    // looks like connection failed, leave.
-    stage(Stage::Done);
-    return Result::Again;
-  }
-
-  /*
-   * if the connection is from the pool, we need a change user.
-   */
-  if (server_protocol->server_greeting()) {
-    connection()->client_greeting_sent(true);
-
-    if (!in_handshake_ &&
-        ((client_protocol->username() == server_protocol->username()) &&
-         (client_protocol->sent_attributes() ==
-          server_protocol->sent_attributes()))) {
-      // it is ok if the schema differs, it will be handled later set_schema()
-      connection()->push_processor(
-          std::make_unique<ResetConnectionSender>(connection()));
-    } else {
-      connection()->push_processor(
-          std::make_unique<ChangeUserSender>(connection(), in_handshake_));
-    }
-  } else {
-    connection()->push_processor(
-        std::make_unique<ServerGreetor>(connection(), in_handshake_));
-  }
-
-  stage(Stage::Authenticated);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-LazyConnector::authenticated() {
-  trace(Tracer::Event().stage("connect::authenticated"));
-
-  if (!connection()->authenticated()) {
-    stage(Stage::Done);
-  } else {
-    stage(Stage::SetVars);
-  }
-  return Result::Again;
-}
-
-void set_session_var(std::string &q, const std::string &key, const Value &val) {
-  if (q.empty()) {
-    q = "SET ";
-  } else {
-    q += ",\n    ";
-  }
-
-  q += "@@SESSION." + key + " = " + val.to_string();
-}
-
-void set_session_var_if_not_set(
-    std::string &q, const ExecutionContext::SystemVariables &sysvars,
-    const std::string &key, const Value &value) {
-  if (sysvars.get(key) == Value(std::nullopt)) {
-    set_session_var(q, key, value);
-  }
-}
-
-void set_session_var_or_value(std::string &q,
-                              const ExecutionContext::SystemVariables &sysvars,
-                              const std::string &key,
-                              const Value &default_value) {
-  auto value = sysvars.get(key);
-  if (value == Value(std::nullopt)) {
-    set_session_var(q, key, default_value);
-  } else {
-    set_session_var(q, key, value);
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> LazyConnector::set_vars() {
-  auto &sysvars = connection()->execution_context().system_variables();
-
-  std::string q;
-
-  const auto need_session_trackers =
-      connection()->context().connection_sharing() &&
-      connection()->greeting_from_router();
-
-  // must be first, to track all variables that are set.
-  if (need_session_trackers) {
-    set_session_var_or_value(q, sysvars, "session_track_system_variables",
-                             Value("*"));
-  } else {
-    auto var = sysvars.get("session_track_system_variables");
-    if (var != Value(std::nullopt)) {
-      set_session_var(q, "session_track_system_variables", var);
-    }
-  }
-
-  for (auto var : sysvars) {
-    if (var.first == "session_track_system_variables") continue;
-
-    set_session_var(q, var.first, var.second);
-  }
-
-  if (need_session_trackers) {
-    set_session_var_if_not_set(q, sysvars, "session_track_gtids",
-                               Value("OWN_GTID"));
-    set_session_var_if_not_set(q, sysvars, "session_track_transaction_info",
-                               Value("CHARACTERISTICS"));
-    set_session_var_if_not_set(q, sysvars, "session_track_state_change",
-                               Value("ON"));
-  }
-
-  if (!q.empty()) {
-    connection()->push_processor(
-        std::make_unique<QuerySender>(connection(), q));
-  }
-
-  stage(Stage::SetSchema);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> LazyConnector::set_schema() {
-  auto client_schema = connection()->client_protocol()->schema();
-  auto server_schema = connection()->server_protocol()->schema();
-
-  if (!client_schema.empty() && (client_schema != server_schema)) {
-    connection()->push_processor(
-        std::make_unique<InitSchemaSender>(connection(), client_schema));
-  }
-
-  stage(Stage::Done);
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_lazy_connect.h b/router/src/routing/src/classic_lazy_connect.h
deleted file mode 100644
index 0c31875aa0a..00000000000
--- a/router/src/routing/src/classic_lazy_connect.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_LAZY_CONNECT_INCLUDED
-#define ROUTING_CLASSIC_LAZY_CONNECT_INCLUDED
-
-#include <system_error>
-
-#include "processor.h"
-
-/**
- * attach a server connection and initialize it.
- *
- * - if a server-connection is attached to the client connection, leave.
- * - otherwise,
- *   - if a connection can be taken from the pool, take it.
- *   - otherwise, connect to the server and authenticate.
- * - set tracking session-vars
- * - set the client's schema, if it differs from the server-connection's.
- *
- * Precondition:
- *
- * - the client's cleartext password must be known.
- */
-class LazyConnector : public Processor {
- public:
-  /**
-   * create a lazy-connector.
-   *
-   * @param conn a connection handle
-   * @param in_handshake if true, the client connection is in Greeting or
-   * ChangeUser right now.
-   *
-   * If "in_handshake" the LazyConnector may ask the client for a
-   * "auth-method-switch" or a "plaintext-password".
-   */
-  LazyConnector(MysqlRoutingClassicConnection *conn, bool in_handshake)
-      : Processor(conn), in_handshake_{in_handshake} {}
-
-  enum class Stage {
-    Connect,
-    Connected,
-    Authenticated,
-    SetVars,
-    SetSchema,
-
-    Done,
-  };
-
-  stdx::expected<Processor::Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Processor::Result, std::error_code> connect();
-  stdx::expected<Processor::Result, std::error_code> connected();
-  stdx::expected<Processor::Result, std::error_code> authenticated();
-  stdx::expected<Processor::Result, std::error_code> set_vars();
-  stdx::expected<Processor::Result, std::error_code> set_schema();
-
-  Stage stage_{Stage::Connect};
-
-  bool in_handshake_;
-};
-
-#endif
diff --git a/router/src/routing/src/classic_query.cc b/router/src/routing/src/classic_query.cc
deleted file mode 100644
index bff774b917f..00000000000
--- a/router/src/routing/src/classic_query.cc
+++ /dev/null
@@ -1,720 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_query.h"
-
-#include <memory>
-#include <system_error>
-
-#include "classic_connection.h"
-#include "classic_forwarder.h"
-#include "classic_frame.h"
-#include "classic_lazy_connect.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysql/harness/tls_error.h"
-#include "processor.h"
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Connect:
-      return connect();
-    case Stage::Connected:
-      return connected();
-    case Stage::Response:
-      return response();
-    case Stage::ColumnCount:
-      return column_count();
-    case Stage::LoadData:
-      return load_data();
-    case Stage::Data:
-      return data();
-    case Stage::Column:
-      return column();
-    case Stage::ColumnEnd:
-      return column_end();
-    case Stage::RowOrEnd:
-      return row_or_end();
-    case Stage::Row:
-      return row();
-    case Stage::RowEnd:
-      return row_end();
-    case Stage::Ok:
-      return ok();
-    case Stage::Error:
-      return error();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::command() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::client::Query>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_client_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::command: " +
-                              msg_res->statement().substr(0, 1024)));
-
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  if (!server_conn.is_open()) {
-    stage(Stage::Connect);
-    return Result::Again;
-  } else {
-    stage(Stage::Response);
-    return forward_client_to_server();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::connect() {
-  trace(Tracer::Event().stage("query::connect"));
-
-  stage(Stage::Connected);
-
-  connection()->push_processor(std::make_unique<LazyConnector>(
-      connection(), false /* not in handshake */));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::connected() {
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  if (!server_conn.is_open()) {
-    // Connector sent an server::Error already.
-    auto *socket_splicer = connection()->socket_splicer();
-    auto src_channel = socket_splicer->client_channel();
-    auto src_protocol = connection()->client_protocol();
-
-    // take the client::command from the connection.
-    auto msg_res = ClassicFrame::recv_msg<classic_protocol::wire::String>(
-        src_channel, src_protocol);
-    if (!msg_res) return recv_client_failed(msg_res.error());
-
-    discard_current_msg(src_channel, src_protocol);
-
-    trace(Tracer::Event().stage("query::error"));
-
-    stage(Stage::Done);
-    return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("query::connected"));
-  stage(Stage::Response);
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    LoadData = 0xfb,
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::LoadData:
-      stage(Stage::LoadData);
-      return Result::Again;
-  }
-
-  stage(Stage::ColumnCount);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::load_data() {
-  trace(Tracer::Event().stage("query::load_data"));
-
-  stage(Stage::Data);
-  return forward_server_to_client();
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-
-  auto read_res = ClassicFrame::ensure_frame_header(src_channel, src_protocol);
-  if (!read_res) return recv_client_failed(read_res.error());
-
-  trace(Tracer::Event().stage("query::data"));
-
-  // local-data is finished with an empty packet.
-  if (src_protocol->current_frame()->frame_size_ == 4) {
-    stage(Stage::Response);
-  }
-
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-QueryForwarder::column_count() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::wire::VarInt>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::column_count"));
-
-  columns_left_ = msg_res->value();
-
-  stage(Stage::Column);
-
-  return forward_server_to_client(true);
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::column() {
-  const auto trace_event = Tracer::Event().stage("query::column");
-
-  trace(trace_event);
-
-  if (--columns_left_ == 0) {
-    stage(Stage::ColumnEnd);
-  }
-
-  return forward_server_to_client(true);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-QueryForwarder::column_end() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  auto skips_eof_pos =
-      classic_protocol::capabilities::pos::text_result_with_session_tracking;
-
-  bool server_skips_end_of_columns{
-      src_protocol->shared_capabilities().test(skips_eof_pos)};
-
-  bool router_skips_end_of_columns{
-      dst_protocol->shared_capabilities().test(skips_eof_pos)};
-
-  if (server_skips_end_of_columns && router_skips_end_of_columns) {
-    // this is a Row, not a EOF packet.
-    stage(Stage::RowOrEnd);
-    return Result::Again;
-  } else if (!server_skips_end_of_columns && !router_skips_end_of_columns) {
-    trace(Tracer::Event().stage("query::column_end::eof"));
-    stage(Stage::RowOrEnd);
-    return forward_server_to_client(true);
-  } else if (!server_skips_end_of_columns && router_skips_end_of_columns) {
-    // client is new, server is old: drop the server's EOF.
-    trace(Tracer::Event().stage("query::column_end::skip_eof"));
-
-    auto msg_res =
-        ClassicFrame::recv_msg<classic_protocol::message::server::Eof>(
-            src_channel, src_protocol);
-    if (!msg_res) return recv_server_failed(msg_res.error());
-
-    discard_current_msg(src_channel, src_protocol);
-
-    stage(Stage::RowOrEnd);
-    return Result::Again;
-  } else {
-    // client is old, server is new: inject an EOF between column-meta and rows.
-    trace(Tracer::Event().stage("query::column_end::add_eof"));
-
-    auto msg_res =
-        ClassicFrame::send_msg<classic_protocol::message::server::Eof>(
-            dst_channel, dst_protocol, {});
-    if (!msg_res) return recv_server_failed(msg_res.error());
-
-    stage(Stage::RowOrEnd);
-    return Result::SendToServer;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-QueryForwarder::row_or_end() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    EndOfResult =
-        ClassicFrame::cmd_byte<classic_protocol::message::server::Eof>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-    case Msg::EndOfResult:
-      // 0xfe is used for:
-      //
-      // - end-of-rows packet
-      // - fields in a row > 16MByte.
-      if (src_protocol->current_frame()->frame_size_ < 1024) {
-        stage(Stage::RowEnd);
-        return Result::Again;
-      }
-      [[fallthrough]];
-    default:
-      stage(Stage::Row);
-      return Result::Again;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::row() {
-  trace(Tracer::Event().stage("query::row"));
-
-  stage(Stage::RowOrEnd);
-  return forward_server_to_client(true /* noflush */);
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::row_end() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Eof>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::row_end"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  if (msg.status_flags().test(
-          classic_protocol::status::pos::more_results_exist)) {
-    stage(Stage::Response);  // another resultset is coming
-
-    trace(Tracer::Event().stage("query::more_resultsets"));
-    return forward_server_to_client(true);
-  } else {
-    stage(Stage::Done);  // once the message is forwarded, we are done.
-    return forward_server_to_client();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  if (msg.status_flags().test(
-          classic_protocol::status::pos::more_results_exist)) {
-    stage(Stage::Response);  // another resultset is coming
-
-    trace(Tracer::Event().stage("query::more_resultsets"));
-    return forward_server_to_client(true);
-  } else {
-    stage(Stage::Done);  // once the message is forwarded, we are done.
-    return forward_server_to_client();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> QueryForwarder::error() {
-  trace(Tracer::Event().stage("query::error"));
-
-  stage(Stage::Done);
-  return forward_server_to_client();
-}
-
-// Sender
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Response:
-      return response();
-    case Stage::ColumnCount:
-      return column_count();
-    case Stage::LoadData:
-      return load_data();
-    case Stage::Data:
-      return data();
-    case Stage::Column:
-      return column();
-    case Stage::ColumnEnd:
-      return column_end();
-    case Stage::RowOrEnd:
-      return row_or_end();
-    case Stage::Row:
-      return row();
-    case Stage::RowEnd:
-      return row_end();
-    case Stage::Ok:
-      return ok();
-    case Stage::Error:
-      return error();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::command() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  trace(Tracer::Event().stage("query::command"));
-  trace(Tracer::Event().stage(">> " + stmt_));
-
-  dst_protocol->seq_id(0xff);
-
-  auto send_res =
-      ClassicFrame::send_msg<classic_protocol::message::client::Query>(
-          dst_channel, dst_protocol, stmt_);
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-    LoadData = 0xfb,
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-    case Msg::LoadData:
-      stage(Stage::LoadData);
-      return Result::Again;
-  }
-
-  stage(Stage::ColumnCount);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::load_data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::wire::String>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::load_data"));
-
-  // we could decode the filename here.
-
-  discard_current_msg(src_channel, src_protocol);
-
-  stage(Stage::Data);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::data() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  trace(Tracer::Event().stage("query::data"));
-
-  // an empty packet.
-  auto send_res = ClassicFrame::send_msg<classic_protocol::wire::String>(
-      dst_channel, dst_protocol, {});
-  if (!send_res) return send_server_failed(send_res.error());
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::column_count() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::ColumnCount>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::column_count"));
-
-  if (handler_) handler_->on_column_count(msg_res->count());
-
-  columns_left_ = msg_res->count();
-
-  discard_current_msg(src_channel, src_protocol);
-
-  stage(Stage::Column);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::column() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::ColumnMeta>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::column"));
-
-  discard_current_msg(src_channel, src_protocol);
-
-  if (handler_) handler_->on_column(*msg_res);
-
-  if (--columns_left_ == 0) {
-    const auto skips_eof_pos =
-        classic_protocol::capabilities::pos::text_result_with_session_tracking;
-
-    const bool server_skips_end_of_columns{
-        src_protocol->shared_capabilities().test(skips_eof_pos)};
-
-    if (server_skips_end_of_columns) {
-      // next is a Row, not a EOF packet.
-      stage(Stage::RowOrEnd);
-    } else {
-      stage(Stage::ColumnEnd);
-    }
-  }
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::column_end() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Eof>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::column_end"));
-
-  discard_current_msg(src_channel, src_protocol);
-
-  stage(Stage::RowOrEnd);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::row_or_end() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Error = ClassicFrame::cmd_byte<classic_protocol::message::server::Error>(),
-    EndOfResult =
-        ClassicFrame::cmd_byte<classic_protocol::message::server::Eof>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::EndOfResult:
-      stage(Stage::RowEnd);
-      return Result::Again;
-    case Msg::Error:
-      stage(Stage::Error);
-      return Result::Again;
-  }
-
-  stage(Stage::Row);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::row() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Row>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::row"));
-
-  discard_current_msg(src_channel, src_protocol);
-
-  if (handler_) handler_->on_row(*msg_res);
-
-  stage(Stage::RowOrEnd);
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::row_end() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  trace(Tracer::Event().stage("query::row_end"));
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Eof>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  auto eof_msg = std::move(*msg_res);
-
-  if (handler_) handler_->on_row_end(eof_msg);
-
-  if (!eof_msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(eof_msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  discard_current_msg(src_channel, src_protocol);
-
-  if (eof_msg.status_flags().test(
-          classic_protocol::status::pos::more_results_exist)) {
-    trace(Tracer::Event().stage("query::more_resultsets"));
-    stage(Stage::Response);
-
-    return Result::Again;
-  } else {
-    trace(Tracer::Event().stage("query::row_end"));
-    stage(Stage::Done);
-    return Result::Again;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  discard_current_msg(src_channel, src_protocol);
-
-  auto msg = std::move(*msg_res);
-
-  if (handler_) handler_->on_ok(msg);
-
-  if (!msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  if (msg.status_flags().test(
-          classic_protocol::status::pos::more_results_exist)) {
-    trace(Tracer::Event().stage("query::ok::more"));
-    stage(Stage::Response);
-  } else {
-    trace(Tracer::Event().stage("query::ok::done"));
-    stage(Stage::Done);
-  }
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code> QuerySender::error() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto msg_res =
-      ClassicFrame::recv_msg<classic_protocol::message::server::Error>(
-          src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("query::error"));
-
-  discard_current_msg(src_channel, src_protocol);
-
-  if (handler_) handler_->on_error(*msg_res);
-
-  stage(Stage::Done);
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_query.h b/router/src/routing/src/classic_query.h
deleted file mode 100644
index 9f1d4221d36..00000000000
--- a/router/src/routing/src/classic_query.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_QUERY_INCLUDED
-#define ROUTING_CLASSIC_QUERY_INCLUDED
-
-#include <system_error>
-
-#include "processor.h"
-
-class QueryForwarder : public Processor {
- public:
-  using Processor::Processor;
-
-  enum class Stage {
-    Command,
-
-    Connect,
-    Connected,
-
-    Response,
-    ColumnCount,
-    Column,
-    ColumnEnd,
-    RowOrEnd,
-    Row,
-    RowEnd,
-
-    LoadData,
-    Data,
-
-    Ok,
-    Error,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  [[nodiscard]] Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> connect();
-  stdx::expected<Result, std::error_code> connected();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> load_data();
-  stdx::expected<Result, std::error_code> data();
-
-  stdx::expected<Result, std::error_code> column_count();
-  stdx::expected<Result, std::error_code> column();
-  stdx::expected<Result, std::error_code> column_end();
-  stdx::expected<Result, std::error_code> row_or_end();
-  stdx::expected<Result, std::error_code> row();
-  stdx::expected<Result, std::error_code> row_end();
-
-  stdx::expected<Result, std::error_code> ok();
-  stdx::expected<Result, std::error_code> error();
-
-  stdx::expected<void, std::error_code> track_session_changes(
-      net::const_buffer session_trackers,
-      classic_protocol::capabilities::value_type caps);
-
-  Stage stage_{Stage::Command};
-
-  uint64_t columns_left_{0};
-};
-
-class QuerySender : public Processor {
- public:
-  using Processor::Processor;
-
-  class Handler {
-   public:
-    virtual ~Handler() = default;
-
-    virtual void on_column_count(uint64_t count) { (void)count; }
-
-    virtual void on_column(
-        const classic_protocol::message::server::ColumnMeta &column) {
-      (void)column;
-    }
-    virtual void on_row(const classic_protocol::message::server::Row &row) {
-      (void)row;
-    }
-    virtual void on_row_end(const classic_protocol::message::server::Eof &eof) {
-      (void)eof;
-    }
-    virtual void on_ok(const classic_protocol::message::server::Ok &ok) {
-      (void)ok;
-    }
-    virtual void on_error(const classic_protocol::message::server::Error &err) {
-      (void)err;
-    }
-  };
-
-  QuerySender(MysqlRoutingClassicConnection *conn, std::string stmt)
-      : Processor(conn), stmt_{std::move(stmt)} {}
-
-  QuerySender(MysqlRoutingClassicConnection *conn, std::string stmt,
-              std::unique_ptr<Handler> handler)
-      : Processor(conn), stmt_{std::move(stmt)}, handler_(std::move(handler)) {}
-
-  enum class Stage {
-    Command,
-
-    Response,
-    ColumnCount,
-    Column,
-    ColumnEnd,
-    RowOrEnd,
-    Row,
-    RowEnd,
-
-    LoadData,
-    Data,
-
-    Ok,
-    Error,
-
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> load_data();
-  stdx::expected<Result, std::error_code> data();
-
-  stdx::expected<Result, std::error_code> column_count();
-  stdx::expected<Result, std::error_code> column();
-  stdx::expected<Result, std::error_code> column_end();
-  stdx::expected<Result, std::error_code> row_or_end();
-  stdx::expected<Result, std::error_code> row();
-  stdx::expected<Result, std::error_code> row_end();
-
-  stdx::expected<Result, std::error_code> ok();
-  stdx::expected<Result, std::error_code> error();
-
-  stdx::expected<void, std::error_code> track_session_changes(
-      net::const_buffer session_trackers,
-      classic_protocol::capabilities::value_type caps);
-
-  Stage stage_{Stage::Command};
-
-  std::string stmt_;
-  uint64_t columns_left_{0};
-
-  std::unique_ptr<Handler> handler_;
-};
-
-#endif
diff --git a/router/src/routing/src/classic_reset_connection.cc b/router/src/routing/src/classic_reset_connection.cc
deleted file mode 100644
index 1c22cac831e..00000000000
--- a/router/src/routing/src/classic_reset_connection.cc
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_reset_connection.h"
-
-#include "classic_connection.h"
-#include "classic_forwarder.h"
-#include "classic_frame.h"
-#include "classic_lazy_connect.h"
-#include "classic_query.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysql/harness/tls_error.h"
-#include "tracer.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-/**
- * forward the reset-connection message flow.
- *
- * Expected overall flow:
- *
- * @code
- * c->s: COM_RESET_CONNECTION
- * c<-s: Ok
- * @endcode
- *
- * If there is no server connection, it is created on demand.
- */
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionForwarder::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Connect:
-      return connect();
-    case Stage::Connected:
-      return connected();
-    case Stage::Response:
-      return response();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionForwarder::command() {
-  trace(Tracer::Event().stage("reset_connection::command"));
-
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  if (!server_conn.is_open()) {
-    stage(Stage::Connect);
-    return Result::Again;
-  } else {
-    stage(Stage::Response);
-    return forward_client_to_server();
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionForwarder::connect() {
-  trace(Tracer::Event().stage("reset_connection::connect"));
-
-  stage(Stage::Connected);
-
-  connection()->push_processor(std::make_unique<LazyConnector>(
-      connection(), false /* not in handshake */));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionForwarder::connected() {
-  auto &server_conn = connection()->socket_splicer()->server_conn();
-  if (!server_conn.is_open()) {
-    // Connector sent an server::Error already.
-    auto *socket_splicer = connection()->socket_splicer();
-    auto src_channel = socket_splicer->client_channel();
-    auto src_protocol = connection()->client_protocol();
-
-    // take the client::command from the connection.
-    auto recv_res =
-        ClassicFrame::ensure_has_full_frame(src_channel, src_protocol);
-    if (!recv_res) return recv_client_failed(recv_res.error());
-
-    discard_current_msg(src_channel, src_protocol);
-
-    trace(Tracer::Event().stage("reset_connection::error"));
-
-    stage(Stage::Done);
-    return Result::Again;
-  }
-
-  trace(Tracer::Event().stage("reset_connection::connected"));
-
-  stage(Stage::Response);
-  return forward_client_to_server();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionForwarder::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-  };
-
-  // reset-connection is not expected to fail.
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-  }
-
-  log_debug("reset_connection::response: unexpected msg-type '%02x'", msg_type);
-
-  return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionForwarder::ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("reset_connection::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  // allow connection sharing again.
-  connection()->connection_sharing_allowed_reset();
-
-  // clear the warnings
-  connection()->execution_context().diagnostics_area().warnings().clear();
-
-  if (connection()->context().connection_sharing() &&
-      connection()->greeting_from_router()) {
-    // if connection sharing is enabled in the config, enable the
-    // session-tracker.
-    connection()->push_processor(std::make_unique<QuerySender>(connection(), R"(
-SET @@SESSION.session_track_schema           = 'ON',
-    @@SESSION.session_track_system_variables = '*',
-    @@SESSION.session_track_transaction_info = 'CHARACTERISTICS',
-    @@SESSION.session_track_gtids            = 'OWN_GTID',
-    @@SESSION.session_track_state_change     = 'ON')"));
-
-    stage(Stage::Done);
-  } else {
-    stage(Stage::Done);
-  }
-
-  return forward_server_to_client();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionSender::process() {
-  switch (stage()) {
-    case Stage::Command:
-      return command();
-    case Stage::Response:
-      return response();
-    case Stage::Ok:
-      return ok();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionSender::command() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  trace(Tracer::Event().stage("reset_connection::command"));
-
-  const auto send_res = ClassicFrame::send_msg<
-      classic_protocol::message::client::ResetConnection>(dst_channel,
-                                                          dst_protocol, {});
-  if (!send_res) return send_server_failed(send_res.error());
-
-  stage(Stage::Response);
-
-  return Result::SendToServer;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ResetConnectionSender::response() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-
-  auto read_res =
-      ClassicFrame::ensure_has_msg_prefix(src_channel, src_protocol);
-  if (!read_res) return recv_server_failed(read_res.error());
-
-  const uint8_t msg_type = src_protocol->current_msg_type().value();
-
-  enum class Msg {
-    Ok = ClassicFrame::cmd_byte<classic_protocol::message::server::Ok>(),
-  };
-
-  switch (Msg{msg_type}) {
-    case Msg::Ok:
-      stage(Stage::Ok);
-      return Result::Again;
-  }
-
-  log_debug("reset_connection::response: unexpected msg-type '%02x'", msg_type);
-
-  return recv_server_failed(make_error_code(std::errc::bad_message));
-}
-
-stdx::expected<Processor::Result, std::error_code> ResetConnectionSender::ok() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto *src_channel = socket_splicer->server_channel();
-  auto *src_protocol = connection()->server_protocol();
-
-  auto msg_res = ClassicFrame::recv_msg<classic_protocol::message::server::Ok>(
-      src_channel, src_protocol);
-  if (!msg_res) return recv_server_failed(msg_res.error());
-
-  trace(Tracer::Event().stage("reset_connection::ok"));
-
-  auto msg = std::move(*msg_res);
-
-  if (!msg.session_changes().empty()) {
-    auto track_res = connection()->track_session_changes(
-        net::buffer(msg.session_changes()),
-        src_protocol->shared_capabilities());
-  }
-
-  discard_current_msg(src_channel, src_protocol);
-
-  connection()->connection_sharing_allowed_reset();
-
-  stage(Stage::Done);
-  return Result::Again;
-}
diff --git a/router/src/routing/src/classic_reset_connection.h b/router/src/routing/src/classic_reset_connection.h
deleted file mode 100644
index 542a79dbb9b..00000000000
--- a/router/src/routing/src/classic_reset_connection.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_RESET_CONNECTION_INCLUDED
-#define ROUTING_CLASSIC_RESET_CONNECTION_INCLUDED
-
-#include "processor.h"
-
-class ResetConnectionForwarder : public Processor {
- public:
-  using Processor::Processor;
-
-  enum class Stage {
-    Command,
-    Connect,
-    Connected,
-    Response,
-    Ok,
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> connect();
-  stdx::expected<Result, std::error_code> connected();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> ok();
-
-  Stage stage_{Stage::Command};
-};
-
-class ResetConnectionSender : public Processor {
- public:
-  using Processor::Processor;
-
-  enum class Stage {
-    Command,
-    Response,
-    Ok,
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<Result, std::error_code> command();
-  stdx::expected<Result, std::error_code> response();
-  stdx::expected<Result, std::error_code> ok();
-
-  Stage stage_{Stage::Command};
-};
-
-#endif
-- 
2.37.2

