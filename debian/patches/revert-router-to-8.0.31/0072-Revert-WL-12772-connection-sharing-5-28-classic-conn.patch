From 9d56dd70305bd437fe5fec7232b0c016c2a4c157 Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:20:56 -0500
Subject: [PATCH 72/86] Revert "WL#12772 connection-sharing [5/28] -
 classic-connection"

This reverts commit 93e58adc4a94a79e68c4b6a72b9fa80504c63eb1.
---
 .../include/mysqlrouter/connection_pool.h     |  43 +-
 .../connection_pool/src/connection_pool.cc    |  16 -
 .../src/routing/src/basic_protocol_splicer.h  |  33 +-
 router/src/routing/src/classic_connection.cc  | 394 +++---------------
 router/src/routing/src/classic_connection.h   | 230 ++--------
 router/src/routing/src/connection.h           |  21 +-
 router/src/routing/src/context.h              |  14 +-
 router/src/routing/src/mysql_routing.cc       |   4 +-
 router/src/routing/src/mysql_routing.h        |   5 +-
 .../routing/src/shared_quarantine_handler.h   |   2 +-
 router/src/routing/src/x_connection.cc        |  86 ++--
 router/src/routing/src/x_connection.h         |  48 ++-
 12 files changed, 191 insertions(+), 705 deletions(-)

diff --git a/router/src/connection_pool/include/mysqlrouter/connection_pool.h b/router/src/connection_pool/include/mysqlrouter/connection_pool.h
index a56043bdb2c..5b675570ccd 100644
--- a/router/src/connection_pool/include/mysqlrouter/connection_pool.h
+++ b/router/src/connection_pool/include/mysqlrouter/connection_pool.h
@@ -39,11 +39,8 @@
 #include "mysql/harness/stdx/monitor.h"
 #include "mysql/harness/tls_types.h"  // Ssl
 #include "mysqlrouter/classic_protocol_constants.h"
-#include "mysqlrouter/classic_protocol_message.h"
 #include "mysqlrouter/connection_base.h"
 
-#include "../../routing/src/ssl_mode.h"  // TODO(jkneschk)
-
 /**
  * pooled connection.
  */
@@ -149,21 +146,11 @@ class CONNECTION_POOL_EXPORT PooledClassicConnection : public PooledConnection {
   PooledClassicConnection(std::unique_ptr<ConnectionBase> conn)
       : PooledConnection{std::move(conn)} {}
 
-  PooledClassicConnection(
-      std::unique_ptr<ConnectionBase> conn, Ssl ssl, caps_type server_caps,
-      caps_type client_caps,
-      std::optional<classic_protocol::message::server::Greeting>
-          server_greeting,
-      SslMode ssl_mode, std::string username, std::string schema,
-      std::string attributes)
+  PooledClassicConnection(std::unique_ptr<ConnectionBase> conn, Ssl ssl,
+                          caps_type server_caps, caps_type client_caps)
       : PooledConnection{std::move(conn), std::move(ssl)},
         server_caps_{server_caps},
-        client_caps_{client_caps},
-        server_greeting_{std::move(server_greeting)},
-        ssl_mode_{ssl_mode},
-        username_{std::move(username)},
-        schema_{std::move(schema)},
-        attributes_{std::move(attributes)} {}
+        client_caps_{client_caps} {}
 
   [[nodiscard]] caps_type client_capabilities() const { return client_caps_; }
 
@@ -173,28 +160,9 @@ class CONNECTION_POOL_EXPORT PooledClassicConnection : public PooledConnection {
     return server_caps_ & client_caps_;
   }
 
-  std::optional<classic_protocol::message::server::Greeting> server_greeting()
-      const {
-    return server_greeting_;
-  }
-
-  SslMode ssl_mode() const { return ssl_mode_; }
-
-  std::string username() const { return username_; }
-  std::string schema() const { return schema_; }
-  std::string attributes() const { return attributes_; }
-
  private:
   caps_type server_caps_{};
   caps_type client_caps_{};
-
-  std::optional<classic_protocol::message::server::Greeting> server_greeting_;
-
-  SslMode ssl_mode_;
-
-  std::string username_;
-  std::string schema_;
-  std::string attributes_;
 };
 
 /**
@@ -227,11 +195,6 @@ class CONNECTION_POOL_EXPORT ConnectionPool {
 
   void add(connection_type conn);
 
-  /**
-   * add connection to the pool if the poll isn't full.
-   */
-  std::optional<connection_type> add_if_not_full(connection_type conn);
-
   /**
    * get a connection from the pool that matches a predicate.
    *
diff --git a/router/src/connection_pool/src/connection_pool.cc b/router/src/connection_pool/src/connection_pool.cc
index 1763c2680c7..6b868d4a5a0 100644
--- a/router/src/connection_pool/src/connection_pool.cc
+++ b/router/src/connection_pool/src/connection_pool.cc
@@ -100,22 +100,6 @@ void ConnectionPool::add(ConnectionPool::connection_type conn) {
   });
 }
 
-std::optional<ConnectionPool::connection_type> ConnectionPool::add_if_not_full(
-    ConnectionPool::connection_type conn) {
-  return pool_(
-      [&](auto &pool) -> std::optional<ConnectionPool::connection_type> {
-        if (pool.size() >= max_pooled_connections_) return std::move(conn);
-
-        pool.push_back(std::move(conn));
-
-        auto &last = pool.back();
-        last.remover([this, it = std::prev(pool.end())]() { erase(it); });
-        last.async_idle(idle_timeout_);
-
-        return std::nullopt;
-      });
-}
-
 uint32_t ConnectionPool::current_pooled_connections() const {
   return pool_([](const auto &pool) { return pool.size(); });
 }
diff --git a/router/src/routing/src/basic_protocol_splicer.h b/router/src/routing/src/basic_protocol_splicer.h
index 0a788fb2804..9d25a55c88f 100644
--- a/router/src/routing/src/basic_protocol_splicer.h
+++ b/router/src/routing/src/basic_protocol_splicer.h
@@ -81,14 +81,19 @@ inline std::string tls_content_type_to_string(TlsContentType v) {
 
 class TlsSwitchable {
  public:
-  using ssl_ctx_gettor_type = std::function<SSL_CTX *(const std::string &id)>;
+  using ssl_ctx_gettor_type = std::function<SSL_CTX *()>;
 
-  TlsSwitchable(SslMode ssl_mode) : ssl_mode_{ssl_mode} {}
+  TlsSwitchable(SslMode ssl_mode, ssl_ctx_gettor_type ssl_ctx_gettor)
+      : ssl_mode_{ssl_mode}, ssl_ctx_gettor_{std::move(ssl_ctx_gettor)} {}
 
   [[nodiscard]] SslMode ssl_mode() const { return ssl_mode_; }
 
+  [[nodiscard]] SSL_CTX *get_ssl_ctx() const { return ssl_ctx_gettor_(); }
+
  private:
   SslMode ssl_mode_;
+
+  ssl_ctx_gettor_type ssl_ctx_gettor_;
 };
 
 class RoutingConnectionBase {
@@ -297,21 +302,22 @@ class TlsSwitchableConnection {
  public:
   TlsSwitchableConnection(std::unique_ptr<ConnectionBase> conn,
                           std::unique_ptr<RoutingConnectionBase> routing_conn,
-                          SslMode ssl_mode,
+                          TlsSwitchable tls_switchable,
                           std::unique_ptr<ProtocolStateBase> state)
       : conn_{std::move(conn)},
         routing_conn_{std::move(routing_conn)},
-        ssl_mode_{std::move(ssl_mode)},
+        tls_switchable_{std::move(tls_switchable)},
         channel_{std::make_unique<Channel>()},
         protocol_{std::move(state)} {}
 
   TlsSwitchableConnection(std::unique_ptr<ConnectionBase> conn,
                           std::unique_ptr<RoutingConnectionBase> routing_conn,
-                          SslMode ssl_mode, std::unique_ptr<Channel> channel,
+                          TlsSwitchable tls_switchable,
+                          std::unique_ptr<Channel> channel,
                           std::unique_ptr<ProtocolStateBase> state)
       : conn_{std::move(conn)},
         routing_conn_{std::move(routing_conn)},
-        ssl_mode_{std::move(ssl_mode)},
+        tls_switchable_{std::move(tls_switchable)},
         channel_{std::move(channel)},
         protocol_{std::move(state)} {}
 
@@ -364,7 +370,9 @@ class TlsSwitchableConnection {
 
   [[nodiscard]] const Channel *channel() const { return channel_.get(); }
 
-  [[nodiscard]] SslMode ssl_mode() const { return ssl_mode_; }
+  [[nodiscard]] const TlsSwitchable &tls_switchable() const {
+    return tls_switchable_;
+  }
 
   [[nodiscard]] bool is_open() const { return conn_ && conn_->is_open(); }
 
@@ -393,6 +401,10 @@ class TlsSwitchableConnection {
     return conn_->endpoint();
   }
 
+  [[nodiscard]] SSL_CTX *get_ssl_ctx() const {
+    return tls_switchable_.get_ssl_ctx();
+  }
+
   [[nodiscard]] uint64_t reset_error_count(
       BlockedEndpoints &blocked_endpoints) {
     return routing_conn_->reset_error_count(blocked_endpoints);
@@ -422,7 +434,8 @@ class TlsSwitchableConnection {
   std::unique_ptr<ConnectionBase> conn_;
   std::unique_ptr<RoutingConnectionBase> routing_conn_;
 
-  SslMode ssl_mode_;
+  // tls-state
+  TlsSwitchable tls_switchable_;
 
   // socket buffers
   std::unique_ptr<Channel> channel_;
@@ -479,11 +492,11 @@ class ProtocolSplicerBase {
   }
 
   [[nodiscard]] SslMode source_ssl_mode() const {
-    return client_conn().ssl_mode();
+    return client_conn().tls_switchable().ssl_mode();
   }
 
   [[nodiscard]] SslMode dest_ssl_mode() const {
-    return server_conn().ssl_mode();
+    return server_conn().tls_switchable().ssl_mode();
   }
 
   [[nodiscard]] Channel *client_channel() { return client_conn().channel(); }
diff --git a/router/src/routing/src/classic_connection.cc b/router/src/routing/src/classic_connection.cc
index db079d041aa..eaf2f1f0cbb 100644
--- a/router/src/routing/src/classic_connection.cc
+++ b/router/src/routing/src/classic_connection.cc
@@ -50,7 +50,6 @@
 #include "mysqlrouter/classic_protocol_constants.h"
 #include "mysqlrouter/classic_protocol_frame.h"
 #include "mysqlrouter/classic_protocol_message.h"
-#include "mysqlrouter/classic_protocol_session_track.h"
 #include "mysqlrouter/connection_pool.h"
 #include "mysqlrouter/connection_pool_component.h"
 #include "mysqlrouter/routing_component.h"
@@ -92,11 +91,6 @@ static constexpr uint8_t cmd_byte() {
   return classic_protocol::Codec<T>::cmd_byte();
 }
 
-template <class T>
-static constexpr uint8_t type_byte() {
-  return classic_protocol::Codec<T>::type_byte();
-}
-
 /*
  * discard the current message.
  *
@@ -423,9 +417,7 @@ ensure_has_full_frame(Channel *src_channel,
   auto read_res = src_channel->read_to_plain(min_size - cur_size);
   if (!read_res) return read_res.get_unexpected();
 
-  if (recv_buf.size() >= min_size) return {};
-
-  return stdx::make_unexpected(make_error_code(TlsErrc::kWantRead));
+  return {};
 }
 
 /**
@@ -918,7 +910,15 @@ void MysqlRoutingClassicConnection::async_run() {
         return true;
       });
 
-  if (greeting_from_router()) {
+  // the server's greeting if:
+  //
+  // passthrough + as_client
+  // preferred   + as_client
+  greeting_from_router_ = !((source_ssl_mode() == SslMode::kPassthrough) ||
+                            (source_ssl_mode() == SslMode::kPreferred &&
+                             dest_ssl_mode() == SslMode::kAsClient));
+
+  if (greeting_from_router_) {
     client_send_server_greeting_from_router();
   } else {
     server_recv_server_greeting_from_server();
@@ -1344,255 +1344,6 @@ void MysqlRoutingClassicConnection::server_recv_change_user_response() {
   return recv_server_failed(make_error_code(std::errc::bad_message));
 }
 
-stdx::expected<void, std::error_code>
-MysqlRoutingClassicConnection::track_session_changes(
-    net::const_buffer session_trackers,
-    classic_protocol::capabilities::value_type caps,
-    bool ignore_some_state_changed) {
-  do {
-    auto decode_session_res =
-        classic_protocol::decode<classic_protocol::session_track::Field>(
-            session_trackers, caps);
-    if (!decode_session_res) {
-      return decode_session_res.get_unexpected();
-    }
-
-    const auto decoded_size = decode_session_res->first;
-
-    if (decoded_size == 0) {
-      return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-    }
-
-    enum class Type {
-      SystemVariable =
-          type_byte<classic_protocol::session_track::SystemVariable>(),
-      Schema = type_byte<classic_protocol::session_track::Schema>(),
-      State = type_byte<classic_protocol::session_track::State>(),
-      Gtid = type_byte<classic_protocol::session_track::Gtid>(),
-      TransactionState =
-          type_byte<classic_protocol::session_track::TransactionState>(),
-      TransactionCharacteristics = type_byte<
-          classic_protocol::session_track::TransactionCharacteristics>(),
-    };
-
-    switch (Type{decode_session_res->second.type()}) {
-      case Type::SystemVariable: {
-        auto decode_value_res = classic_protocol::decode<
-            classic_protocol::session_track::SystemVariable>(
-            net::buffer(decode_session_res->second.data()), caps);
-        if (!decode_value_res) {
-          // ignore errors?
-        } else {
-          const auto kv = decode_value_res->second;
-
-          std::ostringstream oss;
-
-          oss << "<< "
-              << "SET @@SESSION." << kv.key() << " = " << quoted(kv.value())
-              << ";";
-
-          exec_ctx_.system_variables().set(kv.key(), Value(kv.value()));
-
-          trace(Tracer::Event().stage(oss.str()));
-        }
-      } break;
-      case Type::Schema: {
-        auto decode_value_res =
-            classic_protocol::decode<classic_protocol::session_track::Schema>(
-                net::buffer(decode_session_res->second.data()), caps);
-        if (!decode_value_res) {
-          // ignore errors?
-        } else {
-          std::string schema = decode_value_res->second.schema();
-
-          std::ostringstream oss;
-
-          oss << "<< "
-              << "USE " << schema;
-          trace(Tracer::Event().stage(oss.str()));
-
-          server_protocol()->schema(schema);
-          client_protocol()->schema(schema);
-        }
-      } break;
-      case Type::State: {
-        auto decode_value_res =
-            classic_protocol::decode<classic_protocol::session_track::State>(
-                net::buffer(decode_session_res->second.data()), caps);
-        if (!decode_value_res) {
-          // ignore errors?
-        } else {
-          // .state() is always '1'
-
-          if (!ignore_some_state_changed) {
-            some_state_changed_ = true;
-          }
-
-          std::ostringstream oss;
-
-          oss << "<< "
-              << "some session state changed.";
-
-          trace(Tracer::Event().stage(oss.str()));
-        }
-      } break;
-      case Type::Gtid: {
-        auto decode_value_res =
-            classic_protocol::decode<classic_protocol::session_track::Gtid>(
-                net::buffer(decode_session_res->second.data()), caps);
-        if (!decode_value_res) {
-          // ignore errors?
-        } else {
-          auto gtid = decode_value_res->second;
-
-          std::ostringstream oss;
-
-          oss << "<< "
-              << "gtid: (spec: " << static_cast<int>(gtid.spec()) << ") "
-              << gtid.gtid();
-
-          trace(Tracer::Event().stage(oss.str()));
-        }
-      } break;
-      case Type::TransactionState: {
-        auto decode_value_res = classic_protocol::decode<
-            classic_protocol::session_track::TransactionState>(
-            net::buffer(decode_session_res->second.data()), caps);
-        if (!decode_value_res) {
-          // ignore errors?
-        } else {
-          auto trx_state = decode_value_res->second;
-
-          // remember the last transaction-state
-          trx_state_ = trx_state;
-
-          std::ostringstream oss;
-
-          oss << "<< "
-              << "trx-state: ";
-
-          switch (trx_state.trx_type()) {
-            case '_':
-              oss << "no trx";
-              break;
-            case 'T':
-              oss << "explicit trx";
-              break;
-            case 'I':
-              oss << "implicit trx";
-              break;
-            default:
-              oss << "(unknown trx-type)";
-              break;
-          }
-
-          switch (trx_state.read_trx()) {
-            case '_':
-              break;
-            case 'R':
-              oss << ", read trx";
-              break;
-            default:
-              oss << ", (unknown read-trx-type)";
-              break;
-          }
-
-          switch (trx_state.read_unsafe()) {
-            case '_':
-              break;
-            case 'r':
-              oss << ", read trx (non-transactional)";
-              break;
-            default:
-              oss << ", (unknown read-unsafe-type)";
-              break;
-          }
-
-          switch (trx_state.write_trx()) {
-            case '_':
-              break;
-            case 'W':
-              oss << ", write trx";
-              break;
-            default:
-              oss << ", (unknown write-trx-type)";
-              break;
-          }
-
-          switch (trx_state.write_unsafe()) {
-            case '_':
-              break;
-            case 'w':
-              oss << ", write trx (non-transactional)";
-              break;
-            default:
-              oss << ", (unknown write-unsafe-type)";
-              break;
-          }
-
-          switch (trx_state.stmt_unsafe()) {
-            case '_':
-              break;
-            case 's':
-              oss << ", stmt unsafe (UUID(), RAND(), ...)";
-              break;
-            default:
-              oss << ", (unknown stmt-unsafe-type)";
-              break;
-          }
-
-          switch (trx_state.resultset()) {
-            case '_':
-              break;
-            case 'S':
-              oss << ", resultset sent";
-              break;
-            default:
-              oss << ", (unknown resultset-type)";
-              break;
-          }
-
-          switch (trx_state.locked_tables()) {
-            case '_':
-              break;
-            case 'L':
-              oss << ", LOCK TABLES";
-              break;
-            default:
-              oss << ", (unknown locked-tables-type)";
-              break;
-          }
-
-          trace(Tracer::Event().stage(oss.str()));
-        }
-      } break;
-      case Type::TransactionCharacteristics: {
-        auto decode_value_res = classic_protocol::decode<
-            classic_protocol::session_track::TransactionCharacteristics>(
-            net::buffer(decode_session_res->second.data()), caps);
-        if (!decode_value_res) {
-          // ignore errors?
-        } else {
-          auto trx_characteristics = decode_value_res->second;
-
-          trx_characteristics_ = trx_characteristics;
-
-          std::ostringstream oss;
-
-          oss << "<< trx-stmt: " << trx_characteristics.characteristics();
-
-          trace(Tracer::Event().stage(oss.str()));
-        }
-      } break;
-    }
-
-    // go to the next field.
-    session_trackers += decoded_size;
-  } while (session_trackers.size() > 0);
-
-  return {};
-}
-
 void MysqlRoutingClassicConnection::
     server_recv_change_user_response_auth_method_switch() {
   auto *socket_splicer = this->socket_splicer();
@@ -1748,18 +1499,16 @@ static TlsSwitchableConnection make_connection_from_pooled(
     PooledClassicConnection &&other) {
   return {std::move(other.connection()),
           nullptr,  // routing_conn
-          {other.ssl_mode(), other.ssl_ctx_gettor()},
+          {SslMode::kPreferred, {}},
           std::make_unique<Channel>(std::move(other.ssl())),
-          std::make_unique<ClassicProtocolState>(
-              other.server_capabilities(), other.client_capabilities(),
-              other.server_greeting(), other.username(), other.schema(),
-              other.attributes())};
+          std::make_unique<ClassicProtocolState>(other.server_capabilities(),
+                                                 other.client_capabilities())};
 }
 
 std::optional<PooledClassicConnection>
 MysqlRoutingClassicConnection::try_pop_pooled_connection(
     const net::ip::tcp::endpoint &ep) {
-  if (!greeting_from_router()) return {};
+  if (!greeting_from_router_) return {};
 
   auto &pools = ConnectionPoolComponent::get_instance();
 
@@ -1799,49 +1548,44 @@ void MysqlRoutingClassicConnection::connect() {
   if (!connect_res) {
     const auto ec = connect_res.error();
 
-    // We need to keep the disconnect_request's mtx while the async handlers are
-    // being set up in order not to miss the disconnect request. Otherwise we
-    // could end up blocking for the whole 'destination_connect_timeout'
-    // duration before giving up the connection.
-    auto handled = disconnect_request([this, &connector, ec](auto requested) {
-      if ((!requested) &&
-          (ec == make_error_condition(std::errc::operation_in_progress) ||
-           ec == make_error_condition(std::errc::operation_would_block))) {
-        auto &t = connector.timer();
-
-        t.expires_after(context().get_destination_connect_timeout());
-
-        t.async_wait([this](std::error_code ec) {
-          if (ec) {
-            return;
-          }
-
-          this->connector().connect_timed_out(true);
-          this->connector().socket().cancel();
-        });
-
-        connector.socket().async_wait(
-            net::socket_base::wait_write, [this](std::error_code ec) {
-              if (ec) {
-                if (this->connector().connect_timed_out()) {
-                  // the connector will handle this.
-                  return call_next_function(Function::kConnect);
-                } else {
-                  return call_next_function(Function::kFinish);
-                }
-              }
-              this->connector().timer().cancel();
+    // We need to keep the disconnect_mtx_ while the async handlers are being
+    // set up in order not to miss the disconnect request. Otherwise we could
+    // end up blocking for the whole 'destination_connect_timeout' duration
+    // before giving up the connection.
+    std::lock_guard<std::mutex> lk(disconnect_mtx_);
+    if ((!disconnect_) &&
+        (ec == make_error_condition(std::errc::operation_in_progress) ||
+         ec == make_error_condition(std::errc::operation_would_block))) {
+      auto &t = connector.timer();
+
+      t.expires_after(context().get_destination_connect_timeout());
+
+      t.async_wait([this](std::error_code ec) {
+        if (ec) {
+          return;
+        }
 
-              return call_next_function(Function::kConnect);
-            });
+        this->connector().connect_timed_out(true);
+        this->connector().socket().cancel();
+      });
 
-        return true;
-      }
+      connector.socket().async_wait(
+          net::socket_base::wait_write, [this](std::error_code ec) {
+            if (ec) {
+              if (this->connector().connect_timed_out()) {
+                // the connector will handle this.
+                return call_next_function(Function::kConnect);
+              } else {
+                return call_next_function(Function::kFinish);
+              }
+            }
+            this->connector().timer().cancel();
 
-      return false;
-    });
+            return call_next_function(Function::kConnect);
+          });
 
-    if (handled) return;
+      return;
+    }
 
     // close the server side.
     this->connector().socket().close();
@@ -3365,16 +3109,11 @@ PooledClassicConnection make_pooled_connection(
     TlsSwitchableConnection &&other) {
   auto *classic_protocol_state =
       dynamic_cast<ClassicProtocolState *>(other.protocol());
-  return {std::move(other.connection()),
-          other.channel()->release_ssl(),
+  return {std::move(other.connection()), other.channel()->release_ssl(),
           classic_protocol_state->server_capabilities(),
-          classic_protocol_state->client_capabilities(),
-          classic_protocol_state->server_greeting(),
-          other.tls_switchable().ssl_mode(),
-          other.tls_switchable().ssl_ctx_gettor(),
-          classic_protocol_state->username(),
-          classic_protocol_state->schema(),
-          classic_protocol_state->attributes()};
+          classic_protocol_state->client_capabilities()
+
+  };
 }
 
 void MysqlRoutingClassicConnection::cmd_quit() {
@@ -4520,32 +4259,3 @@ void MysqlRoutingClassicConnection::client_recv_cmd() {
     return async_send_client(Function::kClientRecvCmd);
   }
 }
-
-bool MysqlRoutingClassicConnection::connection_sharing_possible() const {
-  const auto &sysvars = exec_ctx_.system_variables();
-
-  return context_.connection_sharing() &&              // config must allow it.
-         client_protocol()->password().has_value() &&  // a password is required
-         sysvars.get("session_track_gtids") == Value("OWN_GTID") &&
-         sysvars.get("session_track_state_change") == Value("ON") &&
-         sysvars.get("session_track_system_variables") == Value("*") &&
-         sysvars.get("session_track_transaction_info") ==
-             Value("CHARACTERISTICS");
-}
-
-bool MysqlRoutingClassicConnection::connection_sharing_allowed() const {
-  return connection_sharing_possible() &&
-         (!trx_state_.has_value() ||  // at the start trx_state is not set.c
-          *trx_state_ ==
-              classic_protocol::session_track::TransactionState{
-                  '_', '_', '_', '_', '_', '_', '_', '_'}) &&
-         (trx_characteristics_.has_value() &&
-          trx_characteristics_->characteristics() == "") &&
-         !some_state_changed_;
-}
-
-void MysqlRoutingClassicConnection::connection_sharing_allowed_reset() {
-  trx_state_.reset();
-  trx_characteristics_.reset();
-  some_state_changed_ = false;
-}
diff --git a/router/src/routing/src/classic_connection.h b/router/src/routing/src/classic_connection.h
index 684408d457c..f8c3264ec29 100644
--- a/router/src/routing/src/classic_connection.h
+++ b/router/src/routing/src/classic_connection.h
@@ -26,19 +26,12 @@
 #define ROUTING_CLASSIC_CONNECTION_INCLUDED
 
 #include <functional>
-#include <memory>
-#include <optional>
 #include <string>
 #include <vector>
 
 #include "channel.h"
 #include "connection.h"  // MySQLRoutingConnectionBase
-#include "mysql/harness/net_ts/timer.h"
-#include "mysqlrouter/classic_protocol_message.h"
-#include "mysqlrouter/classic_protocol_session_track.h"
 #include "mysqlrouter/connection_pool.h"
-#include "sql_exec_context.h"
-#include "tracer.h"
 
 /**
  * protocol state of a classic protocol connection.
@@ -47,20 +40,9 @@ class ClassicProtocolState : public ProtocolStateBase {
  public:
   ClassicProtocolState() = default;
 
-  ClassicProtocolState(
-      classic_protocol::capabilities::value_type server_caps,
-      classic_protocol::capabilities::value_type client_caps,
-      std::optional<classic_protocol::message::server::Greeting>
-          server_greeting,
-      std::string username,  //
-      std::string schema,    //
-      std::string attributes)
-      : server_caps_{server_caps},
-        client_caps_{client_caps},
-        server_greeting_{std::move(server_greeting)},
-        username_{std::move(username)},
-        schema_{std::move(schema)},
-        sent_attributes_{std::move(attributes)} {}
+  ClassicProtocolState(classic_protocol::capabilities::value_type server_caps,
+                       classic_protocol::capabilities::value_type client_caps)
+      : server_caps_{server_caps}, client_caps_{client_caps} {}
 
   void server_capabilities(classic_protocol::capabilities::value_type caps) {
     server_caps_ = caps;
@@ -128,33 +110,6 @@ class ClassicProtocolState : public ProtocolStateBase {
     auth_method_name_ = std::move(name);
   }
 
-  [[nodiscard]] std::string auth_method_data() const {
-    return auth_method_data_;
-  }
-
-  void auth_method_data(std::string data) {
-    auth_method_data_ = std::move(data);
-  }
-
-  std::string username() { return username_; }
-  void username(std::string user) { username_ = std::move(user); }
-
-  void password(std::optional<std::string> pw) { password_ = std::move(pw); }
-  std::optional<std::string> password() const { return password_; }
-
-  std::string schema() { return schema_; }
-  void schema(std::string s) { schema_ = std::move(s); }
-
-  // connection attributes there were received.
-  std::string attributes() { return recv_attributes_; }
-  void attributes(std::string attrs) { recv_attributes_ = std::move(attrs); }
-
-  // connection attributes that were sent.
-  std::string sent_attributes() { return sent_attributes_; }
-  void sent_attributes(std::string attrs) {
-    sent_attributes_ = std::move(attrs);
-  }
-
  private:
   classic_protocol::capabilities::value_type server_caps_{};
   classic_protocol::capabilities::value_type client_caps_{};
@@ -167,14 +122,7 @@ class ClassicProtocolState : public ProtocolStateBase {
 
   uint8_t seq_id_{255};  // next use will increment to 0
 
-  std::string username_;
-  std::optional<std::string> password_;
-  std::string schema_;
-  std::string recv_attributes_;
-  std::string sent_attributes_;
-
   std::string auth_method_name_;
-  std::string auth_method_data_;
 };
 
 class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
@@ -200,23 +148,35 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
       std::unique_ptr<RoutingConnectionBase> client_routing_connection,
       std::function<void(MySQLRoutingConnectionBase *)> remove_callback)
       : MySQLRoutingConnectionBase{context, std::move(remove_callback)},
-        route_destination_{route_destination},
-        destinations_{route_destination_->destinations()},
         connector_{client_connection->io_ctx(), route_destination,
-                   destinations_,
                    [this](const net::ip::tcp::endpoint &ep) {
                      return try_pop_pooled_connection(ep);
                    }},
         socket_splicer_{std::make_unique<ProtocolSplicerBase>(
-            TlsSwitchableConnection{std::move(client_connection),
-                                    std::move(client_routing_connection),
-                                    context.source_ssl_mode(),
-                                    std::make_unique<ClassicProtocolState>()},
-            TlsSwitchableConnection{nullptr, nullptr, context.dest_ssl_mode(),
-                                    std::make_unique<ClassicProtocolState>()})},
-        read_timer_{socket_splicer()->client_conn().connection()->io_ctx()},
-        connect_timer_{socket_splicer()->client_conn().connection()->io_ctx()} {
-  }
+            TlsSwitchableConnection{
+                std::move(client_connection),
+                std::move(client_routing_connection),
+                {context.source_ssl_mode(),
+                 [this]() -> SSL_CTX * {
+                   return this->context().source_ssl_ctx()->get();
+                 }},
+                std::make_unique<ClassicProtocolState>()},
+            TlsSwitchableConnection{
+                nullptr,
+                nullptr,
+                {context.dest_ssl_mode(),
+                 [this]() -> SSL_CTX * {
+                   auto make_res = mysql_harness::make_tcp_address(
+                       this->get_destination_id());
+                   if (!make_res) {
+                     return nullptr;
+                   }
+
+                   return this->context()
+                       .dest_ssl_ctx(make_res->address())
+                       ->get();
+                 }},
+                std::make_unique<ClassicProtocolState>()})} {}
 
   enum class ForwardResult {
     kWantRecvSource,
@@ -252,18 +212,16 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
   }
 
   void disconnect() override {
-    disconnect_request([this](auto &req) {
-      (void)socket_splicer()->client_conn().cancel();
-      (void)socket_splicer()->server_conn().cancel();
-
-      connector().socket().cancel();
-
-      req = true;
-    });
+    std::lock_guard<std::mutex> lk(disconnect_mtx_);
+    (void)socket_splicer()->client_conn().cancel();
+    (void)socket_splicer()->server_conn().cancel();
+    connector().socket().cancel();
+    disconnect_ = true;
   }
 
   void async_run();
 
+ private:
   void send_server_failed(std::error_code ec);
 
   void recv_server_failed(std::error_code ec);
@@ -276,7 +234,6 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
 
   void client_socket_failed(std::error_code ec);
 
- private:
   enum class Function {
     kServerGreetingFromServer,
     kClientRecvClientGreeting,
@@ -691,13 +648,6 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
     }
   }
 
- public:
-  stdx::expected<void, std::error_code> track_session_changes(
-      net::const_buffer session_trackers,
-      classic_protocol::capabilities::value_type caps,
-      bool ignore_some_state_changed = false);
-
- private:
   void async_send_client(Function next);
 
   void async_recv_client(Function next);
@@ -1034,21 +984,11 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
         socket_splicer()->client_conn().protocol());
   }
 
-  const ClassicProtocolState *client_protocol() const {
-    return dynamic_cast<const ClassicProtocolState *>(
-        socket_splicer()->client_conn().protocol());
-  }
-
   ClassicProtocolState *server_protocol() {
     return dynamic_cast<ClassicProtocolState *>(
         socket_splicer()->server_conn().protocol());
   }
 
-  const ClassicProtocolState *server_protocol() const {
-    return dynamic_cast<const ClassicProtocolState *>(
-        socket_splicer()->server_conn().protocol());
-  }
-
   const ProtocolSplicerBase *socket_splicer() const {
     return socket_splicer_.get();
   }
@@ -1059,55 +999,10 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
     return connector().destination_id();
   }
 
-  void destination_id(const std::string &id) { connector().destination_id(id); }
-
-  /**
-   * check if the connection is authenticated.
-   *
-   * 'true' after the initial handshake and change-user finished with "ok".
-   * 'false' at connection start and after change-user is started.
-   *
-   * @retval true if the connection is authenticated.
-   * @return false otherwise
-   */
-  bool authenticated() const { return authenticated_; }
-  void authenticated(bool v) { authenticated_ = v; }
-
-  /**
-   * check if connection sharing is possible.
-   *
-   * - the configuration enabled it
-   */
-  bool connection_sharing_possible() const;
-
-  /**
-   * check if connection sharing is allowed.
-   *
-   * - connection sharing is possible.
-   * - no active transaction
-   * - no SET TRANSACTION
-   */
-  bool connection_sharing_allowed() const;
-
-  /**
-   * reset the connection-sharing state.
-   *
-   * - after COM_RESET_CONNECTION::ok
-   * - after COM_CHANGE_USER::ok
-   */
-  void connection_sharing_allowed_reset();
-
- private:
   int active_work_{0};
 
-  bool authenticated_{false};
-
   bool client_greeting_sent_{false};
 
- public:
-  bool client_greeting_sent() const { return client_greeting_sent_; }
-  void client_greeting_sent(bool sent) { client_greeting_sent_ = sent; }
-
   /**
    * if the router is sending the initial server-greeting.
    *
@@ -1115,71 +1010,14 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
    * if false, the server is sending the initial greeting and router is forward
    * it.
    */
+  bool greeting_from_router_{false};
 
   connector_type &connector() { return connector_; }
   const connector_type &connector() const { return connector_; }
-  bool greeting_from_router() const {
-    return !((source_ssl_mode() == SslMode::kPassthrough) ||
-             (source_ssl_mode() == SslMode::kPreferred &&
-              dest_ssl_mode() == SslMode::kAsClient));
-  }
-
- public:
-  void requires_tls(bool v) { requires_tls_ = v; }
-
-  bool requires_tls() const { return requires_tls_; }
-
-  void some_state_changed(bool v) { some_state_changed_ = v; }
 
-  RouteDestination *destinations() { return route_destination_; }
-  Destinations &current_destinations() { return destinations_; }
-
- private:
-  RouteDestination *route_destination_;
-  Destinations destinations_;
   connector_type connector_;
 
   std::unique_ptr<ProtocolSplicerBase> socket_splicer_;
-
-  std::string destination_id_;
-
-  /**
-   * client side handshake isn't finished yet.
-   */
-  bool in_handshake_{true};
-
-  std::optional<classic_protocol::session_track::TransactionState> trx_state_;
-  std::optional<classic_protocol::session_track::TransactionCharacteristics>
-      trx_characteristics_;
-  bool some_state_changed_{false};
-
-  bool requires_tls_{true};
-
- public:
-  ExecutionContext &execution_context() { return exec_ctx_; }
-  const ExecutionContext &execution_context() const { return exec_ctx_; }
-
- private:
-  ExecutionContext exec_ctx_;
-
- public:
-  void trace(Tracer::Event e) { tracer_.trace(e); }
-
- private:
-  Tracer tracer_{false};
-
- public:
-  net::steady_timer &read_timer() { return read_timer_; }
-  net::steady_timer &connect_timer() { return connect_timer_; }
-
-  void connect_error_code(const std::error_code &ec) { connect_ec_ = ec; }
-  std::error_code connect_error_code() const { return connect_ec_; }
-
- private:
-  net::steady_timer read_timer_;
-  net::steady_timer connect_timer_;
-
-  std::error_code connect_ec_{};
 };
 
 #endif
diff --git a/router/src/routing/src/connection.h b/router/src/routing/src/connection.h
index 70a98174298..cc32067937b 100644
--- a/router/src/routing/src/connection.h
+++ b/router/src/routing/src/connection.h
@@ -48,7 +48,6 @@ class MySQLRoutingConnectionBase {
   virtual ~MySQLRoutingConnectionBase() = default;
 
   MySQLRoutingContext &context() { return context_; }
-  const MySQLRoutingContext &context() const { return context_; }
 
   virtual std::string get_destination_id() const = 0;
 
@@ -132,11 +131,6 @@ class MySQLRoutingConnectionBase {
 
   void connected();
 
-  template <class F>
-  auto disconnect_request(F &&f) {
-    return disconnect_(std::forward<F>(f));
-  }
-
  protected:
   /** @brief wrapper for common data used by all routing threads */
   MySQLRoutingContext &context_;
@@ -145,18 +139,18 @@ class MySQLRoutingConnectionBase {
 
   Monitor<Stats> stats_{{}};
 
-  Monitor<bool> disconnect_{{}};
+  bool disconnect_{false};
+  std::mutex disconnect_mtx_;
 };
 
 class ConnectorBase {
  public:
   using server_protocol_type = net::ip::tcp;
 
-  ConnectorBase(net::io_context &io_ctx, RouteDestination *route_destination,
-                Destinations &destinations)
+  ConnectorBase(net::io_context &io_ctx, RouteDestination *route_destination)
       : io_ctx_{io_ctx},
         route_destination_{route_destination},
-        destinations_{destinations},
+        destinations_{route_destination_->destinations()},
         destinations_it_{destinations_.begin()} {}
 
   enum class Function {
@@ -173,7 +167,6 @@ class ConnectorBase {
 
   bool connect_timed_out() const { return connect_timed_out_; }
 
-  void destination_id(std::string id) { destination_id_ = id; }
   std::string destination_id() const { return destination_id_; }
 
   void on_connect_failure(
@@ -214,7 +207,7 @@ class ConnectorBase {
   server_protocol_type::endpoint server_endpoint_;
 
   RouteDestination *route_destination_;
-  Destinations &destinations_;
+  Destinations destinations_;
   Destinations::iterator destinations_it_;
   net::ip::tcp::resolver::results_type endpoints_;
   net::ip::tcp::resolver::results_type::iterator endpoints_it_;
@@ -274,8 +267,8 @@ class PooledConnector : public ConnectorBase {
       const server_protocol_type::endpoint &ep)>;
 
   PooledConnector(net::io_context &io_ctx, RouteDestination *route_destination,
-                  Destinations &destinations, pool_lookup_cb pool_lookup)
-      : ConnectorBase{io_ctx, route_destination, destinations},
+                  pool_lookup_cb pool_lookup)
+      : ConnectorBase{io_ctx, route_destination},
         pool_lookup_{std::move(pool_lookup)} {}
 
   stdx::expected<ConnectionType, std::error_code> connect() {
diff --git a/router/src/routing/src/context.h b/router/src/routing/src/context.h
index 94dfd642916..c1058c8bee5 100644
--- a/router/src/routing/src/context.h
+++ b/router/src/routing/src/context.h
@@ -65,8 +65,7 @@ class MySQLRoutingContext {
                       unsigned long long max_connect_errors,
                       SslMode client_ssl_mode, TlsServerContext *client_ssl_ctx,
                       SslMode server_ssl_mode,
-                      DestinationTlsContext *dest_tls_context,
-                      bool connection_sharing)
+                      DestinationTlsContext *dest_tls_context)
       : protocol_(protocol),
         name_(std::move(name)),
         net_buffer_length_(net_buffer_length),
@@ -78,8 +77,7 @@ class MySQLRoutingContext {
         client_ssl_ctx_{client_ssl_ctx},
         server_ssl_mode_{server_ssl_mode},
         destination_tls_context_{dest_tls_context},
-        blocked_endpoints_{max_connect_errors},
-        connection_sharing_{connection_sharing} {}
+        blocked_endpoints_{max_connect_errors} {}
 
   BlockedEndpoints &blocked_endpoints() { return blocked_endpoints_; }
   const BlockedEndpoints &blocked_endpoints() const {
@@ -157,12 +155,6 @@ class MySQLRoutingContext {
     return shared_quarantine_handler_;
   }
 
-  const SharedQuarantineHandler &shared_quarantine() const {
-    return shared_quarantine_handler_;
-  }
-
-  bool connection_sharing() const { return connection_sharing_; }
-
  private:
   /** protocol type. */
   BaseProtocol::Type protocol_;
@@ -210,8 +202,6 @@ class MySQLRoutingContext {
 
   BlockedEndpoints blocked_endpoints_;
 
-  bool connection_sharing_;
-
  public:
   /** @brief Number of active routes */
   std::atomic<uint16_t> info_active_routes_{0};
diff --git a/router/src/routing/src/mysql_routing.cc b/router/src/routing/src/mysql_routing.cc
index ea588c4d2bb..dadaeb4c5d5 100644
--- a/router/src/routing/src/mysql_routing.cc
+++ b/router/src/routing/src/mysql_routing.cc
@@ -120,12 +120,12 @@ MySQLRouting::MySQLRouting(
     std::chrono::milliseconds client_connect_timeout,
     unsigned int net_buffer_length, SslMode client_ssl_mode,
     TlsServerContext *client_ssl_ctx, SslMode server_ssl_mode,
-    DestinationTlsContext *dest_ssl_ctx, bool connection_sharing)
+    DestinationTlsContext *dest_ssl_ctx)
     : context_(protocol, route_name, net_buffer_length,
                destination_connect_timeout, client_connect_timeout,
                mysql_harness::TCPAddress(bind_address, port), named_socket,
                max_connect_errors, client_ssl_mode, client_ssl_ctx,
-               server_ssl_mode, dest_ssl_ctx, connection_sharing),
+               server_ssl_mode, dest_ssl_ctx),
       io_ctx_{io_ctx},
       routing_strategy_(routing_strategy),
       access_mode_(access_mode),
diff --git a/router/src/routing/src/mysql_routing.h b/router/src/routing/src/mysql_routing.h
index accbf18bfe5..a957ceb4f0c 100644
--- a/router/src/routing/src/mysql_routing.h
+++ b/router/src/routing/src/mysql_routing.h
@@ -139,8 +139,6 @@ class ROUTING_EXPORT MySQLRouting : public MySQLRoutingBase {
    * @param client_ssl_ctx SSL context of the client side
    * @param server_ssl_mode SSL mode of the serer side
    * @param dest_ssl_ctx SSL contexts of the destinations
-   * @param connection_sharing if connection sharing is allowed by the
-   * configuration
    */
   MySQLRouting(
       net::io_context &io_ctx, routing::RoutingStrategy routing_strategy,
@@ -159,8 +157,7 @@ class ROUTING_EXPORT MySQLRouting : public MySQLRoutingBase {
       SslMode client_ssl_mode = SslMode::kDisabled,
       TlsServerContext *client_ssl_ctx = nullptr,
       SslMode server_ssl_mode = SslMode::kDisabled,
-      DestinationTlsContext *dest_ssl_ctx = nullptr,
-      bool connection_sharing = false);
+      DestinationTlsContext *dest_ssl_ctx = nullptr);
 
   /** @brief Starts the service and accept incoming connections
    *
diff --git a/router/src/routing/src/shared_quarantine_handler.h b/router/src/routing/src/shared_quarantine_handler.h
index 7cbf8c0185d..32a6d810be6 100644
--- a/router/src/routing/src/shared_quarantine_handler.h
+++ b/router/src/routing/src/shared_quarantine_handler.h
@@ -66,7 +66,7 @@ class SharedQuarantineHandler {
     on_is_quarantined_ = std::move(clb);
   }
 
-  bool is_quarantined(const mysql_harness::TCPAddress &addr) const {
+  bool is_quarantined(const mysql_harness::TCPAddress &addr) {
     return on_is_quarantined_ ? on_is_quarantined_(addr) : false;
   }
 
diff --git a/router/src/routing/src/x_connection.cc b/router/src/routing/src/x_connection.cc
index dd18eb50c01..7a6b9d83b1f 100644
--- a/router/src/routing/src/x_connection.cc
+++ b/router/src/routing/src/x_connection.cc
@@ -737,47 +737,43 @@ void MysqlRoutingXConnection::connect() {
   if (!connect_res) {
     const auto ec = connect_res.error();
 
-    // We need to keep the disconnect_request's mtx while the async handlers are
-    // being set up in order not to miss the disconnect request. Otherwise we
-    // could end up blocking for the whole 'destination_connect_timeout'
-    // duration before giving up the connection.
-    auto handled = disconnect_request([this, &connector, ec](auto requested) {
-      if ((!requested) &&
-          (ec == make_error_condition(std::errc::operation_in_progress) ||
-           ec == make_error_condition(std::errc::operation_would_block))) {
-        auto &t = connector.timer();
-        t.expires_after(context().get_destination_connect_timeout());
-
-        t.async_wait([this](std::error_code ec) {
-          if (ec) {
-            return;
-          }
+    // We need to keep the disconnect_mtx_ while the async handlers are being
+    // set up in order not to miss the disconnect request. Otherwise we could
+    // end up blocking for the whole 'destination_connect_timeout' duration
+    // before giving up the connection.
+    std::lock_guard<std::mutex> lk(disconnect_mtx_);
+    if ((!disconnect_) &&
+        (ec == make_error_condition(std::errc::operation_in_progress) ||
+         ec == make_error_condition(std::errc::operation_would_block))) {
+      auto &t = connector.timer();
+      t.expires_after(context().get_destination_connect_timeout());
+
+      t.async_wait([this](std::error_code ec) {
+        if (ec) {
+          return;
+        }
 
-          this->connector().connect_timed_out(true);
-          this->connector().socket().cancel();
-        });
-
-        connector.socket().async_wait(
-            net::socket_base::wait_write, [this](std::error_code ec) {
-              if (ec) {
-                if (this->connector().connect_timed_out()) {
-                  // the connector will handle this.
-                  return call_next_function(Function::kConnect);
-                } else {
-                  return call_next_function(Function::kFinish);
-                }
-              }
-              this->connector().timer().cancel();
+        this->connector().connect_timed_out(true);
+        this->connector().socket().cancel();
+      });
 
-              return call_next_function(Function::kConnect);
-            });
+      connector.socket().async_wait(
+          net::socket_base::wait_write, [this](std::error_code ec) {
+            if (ec) {
+              if (this->connector().connect_timed_out()) {
+                // the connector will handle this.
+                return call_next_function(Function::kConnect);
+              } else {
+                return call_next_function(Function::kFinish);
+              }
+            }
+            this->connector().timer().cancel();
 
-        return true;
-      }
-      return false;
-    });
+            return call_next_function(Function::kConnect);
+          });
 
-    if (handled) return;
+      return;
+    }
 
     // close the server side.
     this->connector().socket().close();
@@ -1181,26 +1177,18 @@ void MysqlRoutingXConnection::forward_tls_init() {
   forward_tls_server_to_client();
 }
 
-static stdx::expected<SSL_CTX *, std::error_code> get_dest_ssl_ctx(
-    MySQLRoutingContext &ctx, const std::string &id) {
-  return mysql_harness::make_tcp_address(id).and_then(
-      [&ctx](const auto &addr) -> stdx::expected<SSL_CTX *, std::error_code> {
-        return ctx.dest_ssl_ctx(addr.address())->get();
-      });
-}
-
 void MysqlRoutingXConnection::tls_connect_init() {
   auto *socket_splicer = this->socket_splicer();
   auto *dst_channel = socket_splicer->server_channel();
 
-  auto ssl_ctx_res = get_dest_ssl_ctx(context(), get_destination_id());
-  if (!ssl_ctx_res || ssl_ctx_res.value() == nullptr) {
+  auto *ssl_ctx = socket_splicer->server_conn().get_ssl_ctx();
+  if (ssl_ctx == nullptr) {
     // shouldn't happen. But if it does, close the connection.
     log_warning("failed to create SSL_CTX");
 
     return send_server_failed(make_error_code(std::errc::invalid_argument));
   }
-  dst_channel->init_ssl(*ssl_ctx_res);
+  dst_channel->init_ssl(ssl_ctx);
 
   return tls_connect();
 }
@@ -1539,7 +1527,7 @@ void MysqlRoutingXConnection::tls_accept_init() {
 
   src_channel->is_tls(true);
 
-  auto *ssl_ctx = context().source_ssl_ctx()->get();
+  auto *ssl_ctx = socket_splicer->client_conn().get_ssl_ctx();
   // tls <-> (any)
   if (ssl_ctx == nullptr) {
     // shouldn't happen. But if it does, close the connection.
diff --git a/router/src/routing/src/x_connection.h b/router/src/routing/src/x_connection.h
index c1c65137281..c0f631a72a6 100644
--- a/router/src/routing/src/x_connection.h
+++ b/router/src/routing/src/x_connection.h
@@ -66,16 +66,31 @@ class MysqlRoutingXConnection : public MySQLRoutingConnectionBase {
       std::unique_ptr<RoutingConnectionBase> client_routing_connection,
       std::function<void(MySQLRoutingConnectionBase *)> remove_callback)
       : MySQLRoutingConnectionBase{context, std::move(remove_callback)},
-        route_destination_{route_destination},
-        destinations_{route_destination_->destinations()},
-        connector_{client_connection->io_ctx(), route_destination,
-                   destinations_},
+        connector_{client_connection->io_ctx(), route_destination},
         socket_splicer_{std::make_unique<ProtocolSplicerBase>(
-            TlsSwitchableConnection{std::move(client_connection),
-                                    std::move(client_routing_connection),
-                                    context.source_ssl_mode(),
-                                    std::make_unique<XProtocolState>()},
-            TlsSwitchableConnection{nullptr, nullptr, context.dest_ssl_mode(),
+            TlsSwitchableConnection{
+                std::move(client_connection),
+                std::move(client_routing_connection),
+                {context.source_ssl_mode(),
+                 [this]() -> SSL_CTX * {
+                   return this->context().source_ssl_ctx()->get();
+                 }},
+                std::make_unique<XProtocolState>()},
+            TlsSwitchableConnection{nullptr,
+                                    nullptr,
+                                    {context.dest_ssl_mode(),
+                                     [this]() -> SSL_CTX * {
+                                       auto make_res =
+                                           mysql_harness::make_tcp_address(
+                                               this->get_destination_id());
+                                       if (!make_res) {
+                                         return nullptr;
+                                       }
+
+                                       return this->context()
+                                           .dest_ssl_ctx(make_res->address())
+                                           ->get();
+                                     }},
                                     std::make_unique<XProtocolState>()})} {}
 
   static stdx::expected<size_t, std::error_code> encode_error_packet(
@@ -100,14 +115,11 @@ class MysqlRoutingXConnection : public MySQLRoutingConnectionBase {
   }
 
   void disconnect() override {
-    disconnect_request([this](auto &req) {
-      (void)socket_splicer()->client_conn().cancel();
-      (void)socket_splicer()->server_conn().cancel();
-
-      connector().socket().cancel();
-
-      req = true;
-    });
+    std::lock_guard<std::mutex> lk(disconnect_mtx_);
+    (void)socket_splicer()->client_conn().cancel();
+    (void)socket_splicer()->server_conn().cancel();
+    connector().socket().cancel();
+    disconnect_ = true;
   }
 
   enum class Function {
@@ -734,8 +746,6 @@ class MysqlRoutingXConnection : public MySQLRoutingConnectionBase {
   connector_type &connector() { return connector_; }
   const connector_type &connector() const { return connector_; }
 
-  RouteDestination *route_destination_;
-  Destinations destinations_;
   connector_type connector_;
 
   std::unique_ptr<ProtocolSplicerBase> socket_splicer_;
-- 
2.37.2

