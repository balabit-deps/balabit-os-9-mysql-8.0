From 2149cc6f3ddd85a68a73570943d82a4e7250b12f Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:02:17 -0500
Subject: [PATCH 03/86] Revert "Bug#33674644 EPOLLHUP|EPOLLERR leads to high
 CPU usage [2/3]"

This reverts commit 071715346c12ca88cf1d969fd64d51d14084ba16.
---
 .../harness/net_ts/impl/poll_io_service.h     | 266 +++-----
 .../include/mysql/harness/net_ts/io_context.h |   2 +-
 router/src/harness/tests/CMakeLists.txt       |   1 -
 .../tests/test_net_ts_impl_poll_io_service.cc | 575 ------------------
 4 files changed, 69 insertions(+), 775 deletions(-)
 delete mode 100644 router/src/harness/tests/test_net_ts_impl_poll_io_service.cc

diff --git a/router/src/harness/include/mysql/harness/net_ts/impl/poll_io_service.h b/router/src/harness/include/mysql/harness/net_ts/impl/poll_io_service.h
index d5f05b9f1ce..e66333d8f29 100644
--- a/router/src/harness/include/mysql/harness/net_ts/impl/poll_io_service.h
+++ b/router/src/harness/include/mysql/harness/net_ts/impl/poll_io_service.h
@@ -28,10 +28,11 @@
 #include <array>
 #include <list>
 #include <mutex>
-#include <optional>
 #include <system_error>
 #include <vector>
 
+#include <iostream>
+
 #include "mysql/harness/net_ts/impl/io_service_base.h"
 #include "mysql/harness/net_ts/impl/poll.h"
 #include "mysql/harness/net_ts/impl/socket_error.h"
@@ -50,12 +51,12 @@ namespace net {
 // http://www.greenend.org.uk/rjk/tech/poll.html
 class poll_io_service : public IoServiceBase {
  public:
-  ~poll_io_service() override { close(); }
-
-  static constexpr const short kSettableEvents = POLLIN | POLLOUT;
-  static constexpr const short kAlwaysEnabledEvents = POLLHUP | POLLERR;
-  static constexpr const short kAllEvents =
-      kSettableEvents | kAlwaysEnabledEvents;
+  ~poll_io_service() override {
+    if (wakeup_fds_.first != impl::socket::kInvalidSocket)
+      impl::socket::close(wakeup_fds_.first);
+    if (wakeup_fds_.second != impl::socket::kInvalidSocket)
+      impl::socket::close(wakeup_fds_.second);
+  }
 
   bool is_open() const noexcept {
     return wakeup_fds_.first != impl::socket::kInvalidSocket &&
@@ -95,21 +96,7 @@ class poll_io_service : public IoServiceBase {
     return {};
   }
 
-  stdx::expected<void, std::error_code> close() {
-    if (wakeup_fds_.first != impl::socket::kInvalidSocket) {
-      impl::socket::close(wakeup_fds_.first);
-      wakeup_fds_.first = impl::socket::kInvalidSocket;
-    }
-    if (wakeup_fds_.second != impl::socket::kInvalidSocket) {
-      impl::socket::close(wakeup_fds_.second);
-
-      wakeup_fds_.second = impl::socket::kInvalidSocket;
-    }
-
-    return {};
-  }
-
-  static stdx::expected<short, std::error_code> poll_event_from_wait_type(
+  stdx::expected<short, std::error_code> poll_event_from_wait_type(
       impl::socket::wait_type event) {
     switch (event) {
       case impl::socket::wait_type::wait_read:
@@ -117,7 +104,7 @@ class poll_io_service : public IoServiceBase {
       case impl::socket::wait_type::wait_write:
         return POLLOUT;
       case impl::socket::wait_type::wait_error:
-        return POLLERR | POLLHUP;
+        return POLLERR;
       default:
         return stdx::make_unexpected(
             make_error_code(std::errc::invalid_argument));
@@ -144,18 +131,10 @@ class poll_io_service : public IoServiceBase {
       auto &b = bucket(t.fd);
 
       std::lock_guard<std::mutex> lk(mtx_);
-
-      auto it = std::find_if(b.begin(), b.end(), [fd = t.fd](auto fd_ev) {
-        return fd_ev.fd == fd;
-      });
-      if (it == b.end()) {
-        b.push_back(std::move(t));
-      } else {
-        it->event |= t.event;
-      }
+      b.push_back(std::move(t));
     }
 
-    stdx::expected<void, std::error_code> erase_all(native_handle_type fd) {
+    element_type erase_all(native_handle_type fd) {
       auto &b = bucket(fd);
 
       std::lock_guard<std::mutex> lk(mtx_);
@@ -163,17 +142,17 @@ class poll_io_service : public IoServiceBase {
 
       for (auto cur = b.begin(); cur != end;) {
         if (cur->fd == fd) {
+          auto op = std::move(*cur);
           cur = b.erase(cur);
 
-          return {};
+          return op;
         } else {
           ++cur;
         }
       }
 
       // not found
-      return stdx::make_unexpected(
-          make_error_code(std::errc::no_such_file_or_directory));
+      return {};
     }
 
     std::vector<pollfd> poll_fds() const {
@@ -186,17 +165,11 @@ class poll_io_service : public IoServiceBase {
           count += b.size();
         }
 
-        // reserve a few more than needed.
         fds.reserve(count);
 
         for (const auto &b : buckets_) {
           for (auto const &fd_int : b) {
-            if (fd_int.event != 0) {
-              fds.push_back(
-                  {fd_int.fd,
-                   static_cast<short>(fd_int.event & ~kAlwaysEnabledEvents),
-                   0});
-            }
+            fds.push_back({fd_int.fd, fd_int.event, 0});
           }
         }
       }
@@ -204,33 +177,14 @@ class poll_io_service : public IoServiceBase {
       return fds;
     }
 
-    stdx::expected<void, std::error_code> erase_fd_event(native_handle_type fd,
-                                                         short event) {
-      auto &b = bucket(fd);
-
-      std::lock_guard<std::mutex> lk(mtx_);
-      auto it = std::find_if(b.begin(), b.end(),
-                             [fd](auto fd_ev) { return fd_ev.fd == fd; });
-      if (it == b.end()) {
-        return stdx::make_unexpected(
-            make_error_code(std::errc::no_such_file_or_directory));
-      }
-
-      it->event &= ~event;
-
-      return {};
-    }
-
-    std::optional<int32_t> interest(native_handle_type fd) const {
+    void erase_fd_event(native_handle_type fd, short event) {
       auto &b = bucket(fd);
 
       std::lock_guard<std::mutex> lk(mtx_);
-
-      for (auto const &fd_ev : b) {
-        if (fd_ev.fd == fd) return fd_ev.event;
-      }
-
-      return std::nullopt;
+      b.erase(std::remove_if(
+                  b.begin(), b.end(),
+                  [=](fd_event v) { return v.fd == fd && (v.event & event); }),
+              b.end());
     }
 
    private:
@@ -240,12 +194,6 @@ class poll_io_service : public IoServiceBase {
       return buckets_[ndx];
     }
 
-    const container_type &bucket(native_handle_type fd) const {
-      size_t ndx = fd % buckets_.size();
-
-      return buckets_[ndx];
-    }
-
     // tps @8000 client connections
     //
     // cnt : tps
@@ -289,118 +237,9 @@ class poll_io_service : public IoServiceBase {
           make_error_code(std::errc::invalid_argument));
     }
 
-    std::lock_guard<std::mutex> lk(mtx_);
+    fd_interests_.erase_all(fd);
 
-    auto res = fd_interests_.erase_all(fd);
-    if (res) {
-      // remove all events which are already fetched by poll_one()
-
-      auto end = triggered_events_.end();
-      for (auto cur = triggered_events_.begin(); cur != end;) {
-        if (cur->fd == fd) {
-          cur = triggered_events_.erase(cur);
-        } else {
-          ++cur;
-        }
-      }
-    }
-
-    return res;
-  }
-
-  /**
-   * get current fd-interest.
-   *
-   * @returns fd-interest as bitmask of raw POLL* flags
-   */
-  std::optional<int32_t> interest(native_handle_type fd) const {
-    return fd_interests_.interest(fd);
-  }
-
-  stdx::expected<fd_event, std::error_code> pop_event() {
-    fd_event ev;
-
-    auto &head = triggered_events_.front();
-
-    ev.fd = head.fd;
-
-    // if there are multiple events: get OUT before IN.
-    if (head.event & POLLOUT) {
-      head.event &= ~POLLOUT;
-      ev.event = POLLOUT;
-    } else if (head.event & POLLIN) {
-      // disable HUP if it is sent together with IN
-      if (head.event & POLLHUP) head.event &= ~POLLHUP;
-
-      head.event &= ~POLLIN;
-      ev.event = POLLIN;
-    } else if (head.event & POLLERR) {
-      head.event &= ~POLLERR;
-      ev.event = POLLERR;
-    } else if (head.event & POLLHUP) {
-      head.event &= ~POLLHUP;
-      ev.event = POLLHUP;
-    }
-
-    if ((head.event & (POLLIN | POLLOUT | POLLERR | POLLHUP)) == 0) {
-      triggered_events_.pop_front();
-    }
-
-    return ev;
-  }
-
-  stdx::expected<fd_event, std::error_code> update_fd_events(
-      std::chrono::milliseconds timeout) {
-    // build fds for poll() from fd-interest
-
-    auto poll_fds = fd_interests_.poll_fds();
-    auto res = impl::poll::poll(poll_fds.data(), poll_fds.size(), timeout);
-    if (!res) return stdx::make_unexpected(res.error());
-
-    size_t num_revents = res.value();  // number of pollfds with revents
-
-    // translate poll()'s revents into triggered events.
-    std::lock_guard lk(mtx_);
-
-    for (auto ev : poll_fds) {
-      if (ev.revents != 0) {
-        --num_revents;
-
-        // If the caller wants (ev.events) only:
-        //
-        // - POLLIN
-        //
-        // but poll() returns:
-        //
-        // - POLLHUP
-        //
-        // then return POLLIN.
-        //
-        // This handles the connection close cases which is signaled as:
-        //
-        // - POLLIN|POLLHUP on the Unixes
-        // - POLLHUP on Windows.
-        //
-        // As the caller is only interested in POLLIN, the POLLHUP would be
-        // unhandled and be reported on the next call of poll() again.
-        const auto revents = ((ev.events & POLLIN) &&  //
-                              (ev.revents & POLLHUP) && !(ev.revents & POLLIN))
-                                 ? ev.events
-                                 : ev.revents;
-
-        triggered_events_.emplace_back(ev.fd, revents);
-        if (ev.fd != wakeup_fds_.first) {
-          // mimik one-shot events.
-          //
-          // but don't remove interest in the wakeup file-descriptors
-          remove_fd_interest(ev.fd, revents);
-        }
-      }
-
-      if (0 == num_revents) break;
-    }
-
-    return pop_event();
+    return {};
   }
 
   stdx::expected<fd_event, std::error_code> poll_one(
@@ -410,27 +249,56 @@ class poll_io_service : public IoServiceBase {
           make_error_code(std::errc::invalid_argument));
     }
 
-    auto ev_res = [this]() -> stdx::expected<fd_event, std::error_code> {
+    fd_event ev;
+    {
       std::lock_guard<std::mutex> lk(mtx_);
 
       if (triggered_events_.empty()) {
-        // no event.
-        return stdx::make_unexpected(
-            make_error_code(std::errc::no_such_file_or_directory));
-      }
+        // build fds for poll() from fd-interest
+
+        auto poll_fds = fd_interests_.poll_fds();
+        auto res = impl::poll::poll(poll_fds.data(), poll_fds.size(), timeout);
+        if (!res) return stdx::make_unexpected(res.error());
+
+        size_t num_revents = res.value();
+
+        // translate poll()'s revents into triggered events.
+        for (auto ev : poll_fds) {
+          if (ev.revents != 0) {
+            --num_revents;
+            // in case of connection close at "wait_read" without any data
+            //
+            // windows: POLLERR|POLLHUP
+            // linux:   POLLIN|POLLHUP
+            //
+            // as the uppoer layers expect that the waited-for event appears
+            // in the output, we have to merge it in.
+            if (ev.events & POLLIN) {
+              ev.revents |= POLLIN;
+            }
+            if (ev.events & POLLOUT) {
+              ev.revents |= POLLOUT;
+            }
+            triggered_events_.push_back({ev.fd, ev.revents});
+            if (ev.fd != wakeup_fds_.first) {
+              // don't remove interest in the wakeup file-descriptors
+              remove_fd_interest(ev.fd, ev.revents);
+            }
+          }
 
-      return pop_event();
-    }();
+          if (0 == num_revents) break;
+        }
+      }
 
-    if (!ev_res) {
-      if (ev_res.error() == std::errc::no_such_file_or_directory) {
-        ev_res = update_fd_events(timeout);
+      if (triggered_events_.empty()) {
+        return stdx::make_unexpected(std::error_code{});
       }
 
-      if (!ev_res) return stdx::make_unexpected(ev_res.error());
+      ev = triggered_events_.front();
+      triggered_events_.pop_front();
     }
 
-    auto ev = *ev_res;
+    // we could drop mutex here, right?
 
     if (ev.fd == wakeup_fds_.first) {
       on_notify();
@@ -464,6 +332,7 @@ class poll_io_service : public IoServiceBase {
              stdx::make_unexpected(make_error_code(std::errc::interrupted)));
   }
 
+ private:
   /**
    * remove interest of event from fd.
    *
@@ -476,10 +345,11 @@ class poll_io_service : public IoServiceBase {
           make_error_code(std::errc::invalid_argument));
     }
 
-    return fd_interests_.erase_fd_event(fd, event);
+    fd_interests_.erase_fd_event(fd, event);
+
+    return {};
   }
 
- private:
   std::pair<impl::socket::native_handle_type, impl::socket::native_handle_type>
       wakeup_fds_{impl::socket::kInvalidSocket, impl::socket::kInvalidSocket};
 
diff --git a/router/src/harness/include/mysql/harness/net_ts/io_context.h b/router/src/harness/include/mysql/harness/net_ts/io_context.h
index 1d85f310d21..833bdc7dcd9 100644
--- a/router/src/harness/include/mysql/harness/net_ts/io_context.h
+++ b/router/src/harness/include/mysql/harness/net_ts/io_context.h
@@ -487,7 +487,7 @@ class io_context : public execution_context {
     {
       auto res = io_service_->add_fd_interest(fd, wt);
       if (!res) {
-#if 0
+#if !defined(NDEBUG)
         // fd may be -1 or so
         std::cerr << "!! add_fd_interest(" << fd << ", ..."
                   << ") " << res.error() << " " << res.error().message()
diff --git a/router/src/harness/tests/CMakeLists.txt b/router/src/harness/tests/CMakeLists.txt
index 4fc5c8a2805..5659bf478b7 100644
--- a/router/src/harness/tests/CMakeLists.txt
+++ b/router/src/harness/tests/CMakeLists.txt
@@ -109,7 +109,6 @@ SET(TESTS
   test_net_ts_impl_kqueue_io_service.cc
   test_net_ts_impl_linux_epoll_io_service.cc
   test_net_ts_impl_netif.cc
-  test_net_ts_impl_poll_io_service.cc
   test_net_ts_impl_resolver.cc
   test_net_ts_impl_socket.cc
   test_net_ts_internet.cc
diff --git a/router/src/harness/tests/test_net_ts_impl_poll_io_service.cc b/router/src/harness/tests/test_net_ts_impl_poll_io_service.cc
deleted file mode 100644
index d0ed3be16d3..00000000000
--- a/router/src/harness/tests/test_net_ts_impl_poll_io_service.cc
+++ /dev/null
@@ -1,575 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "mysql/harness/net_ts/impl/poll_io_service.h"
-
-#include <chrono>
-#include <system_error>
-
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
-#include "mysql/harness/net_ts/impl/socket.h"
-#include "mysql/harness/net_ts/impl/socket_error.h"
-#include "mysql/harness/net_ts/socket.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysql/harness/stdx/expected_ostream.h"
-#include "scope_guard.h"
-
-#if defined(_WIN32)
-#define AF_SOCKETPAIR AF_INET
-#else
-#define AF_SOCKETPAIR AF_UNIX
-#endif
-
-namespace net {
-std::ostream &operator<<(std::ostream &os, net::fd_event e) {
-  os << "(fd=" << e.fd << ", events=" << std::bitset<32>(e.event) << ")";
-
-  return os;
-}
-}  // namespace net
-
-// check state after constructor.
-//
-// construct doesn't call open()
-TEST(PollIoService, init) {
-  net::poll_io_service io_svc;
-
-  EXPECT_FALSE(io_svc.is_open());
-}
-
-// calling open again should fail.
-TEST(PollIoService, open_already_open) {
-  net::poll_io_service io_svc;
-
-  // after .open() succeeds, .is_open() must return true.
-  //
-  // pre-condition: construct calls open()
-  ASSERT_TRUE(io_svc.open());
-
-  ASSERT_TRUE(io_svc.is_open());
-
-  // calling open again, should fail.
-  EXPECT_EQ(
-      io_svc.open(),
-      stdx::make_unexpected(make_error_code(net::socket_errc::already_open)));
-}
-
-// calling open again should fail.
-TEST(PollIoService, close) {
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-  ASSERT_TRUE(io_svc.is_open());
-
-  EXPECT_TRUE(io_svc.close());
-
-  EXPECT_FALSE(io_svc.is_open());
-}
-
-// check add and remove
-TEST(PollIoService, add_interest) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// check fd-interest is not found before adding interest");
-  auto interest_res = io_svc.interest(fds.first);
-  ASSERT_FALSE(interest_res);  // not registered yet
-
-  SCOPED_TRACE("// adding interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_read));
-
-  SCOPED_TRACE("// check fd-interest after add");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), POLLIN);
-
-  SCOPED_TRACE("// remove interest again");
-  EXPECT_TRUE(io_svc.remove_fd_interest(fds.first, POLLIN));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), 0);
-
-  SCOPED_TRACE("// remove fd completely");
-  EXPECT_TRUE(io_svc.remove_fd(fds.first));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_FALSE(interest_res);
-}
-
-// check add twice
-TEST(PollIoService, add_interest_read_and_write) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// check fd-interest is not found before adding interest");
-  auto interest_res = io_svc.interest(fds.first);
-  ASSERT_FALSE(interest_res);  // not registered yet
-
-  SCOPED_TRACE("// adding interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_read));
-
-  SCOPED_TRACE("// check fd-interest after add-read");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), POLLIN);
-
-  SCOPED_TRACE("// adding interest again");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_write));
-
-  SCOPED_TRACE("// check fd-interest after add-write");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), POLLIN | POLLOUT);
-
-  SCOPED_TRACE("// remove read-interest again");
-  EXPECT_TRUE(io_svc.remove_fd_interest(fds.first, POLLIN));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), POLLOUT);
-
-  SCOPED_TRACE("// remove write-interest again");
-  EXPECT_TRUE(io_svc.remove_fd_interest(fds.first, POLLOUT));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), 0);
-
-  SCOPED_TRACE("// remove fd completely");
-  EXPECT_TRUE(io_svc.remove_fd(fds.first));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_FALSE(interest_res);
-}
-
-TEST(PollIoService, add_interest_read_and_read) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// check fd-interest is not found before adding interest");
-  auto interest_res = io_svc.interest(fds.first);
-  ASSERT_FALSE(interest_res);  // not registered yet
-
-  SCOPED_TRACE("// adding interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_read));
-
-  SCOPED_TRACE("// check fd-interest after add-read");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), POLLIN);
-
-  SCOPED_TRACE("// adding interest again");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_write));
-
-  SCOPED_TRACE("// check fd-interest after 2nd add-read");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(std::bitset<32>(interest_res.value()),
-            std::bitset<32>(POLLIN | POLLOUT));
-
-  SCOPED_TRACE("// remove read-interest again");
-  EXPECT_TRUE(io_svc.remove_fd_interest(fds.first, POLLIN));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(std::bitset<32>(interest_res.value()), std::bitset<32>(POLLOUT));
-
-  SCOPED_TRACE("// remove write-interest again");
-  EXPECT_TRUE(io_svc.remove_fd_interest(fds.first, POLLOUT));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(std::bitset<32>(interest_res.value()), std::bitset<32>());
-
-  SCOPED_TRACE("// remove fd completely");
-  EXPECT_TRUE(io_svc.remove_fd(fds.first));
-
-  SCOPED_TRACE("// check fd-interest after remove");
-  interest_res = io_svc.interest(fds.first);
-  ASSERT_FALSE(interest_res);
-}
-
-// check remove_fd_interest fails if fd isn't registered yet.
-TEST(PollIoService, remove_fd_interest_from_empty) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-  EXPECT_EQ(io_svc.remove_fd_interest(fds.first, POLLIN),
-            stdx::make_unexpected(
-                make_error_code(std::errc::no_such_file_or_directory)));
-}
-
-// check poll_one properly tracks the oneshot events.
-TEST(PollIoService, poll_one) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// add write interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_write));
-
-  using namespace std::chrono_literals;
-
-  SCOPED_TRACE(
-      "// poll once which should fire, and remove the oneshot interest");
-  auto poll_res = io_svc.poll_one(100ms);
-  ASSERT_TRUE(poll_res) << poll_res.error();
-
-  SCOPED_TRACE("// poll again which should block");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_EQ(poll_res,
-            stdx::make_unexpected(make_error_code(std::errc::timed_out)));
-
-  SCOPED_TRACE("// add write interest again");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_write));
-
-  SCOPED_TRACE("// poll again which should fire");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_TRUE(poll_res);
-}
-
-// check remove_fd fails if it isn't registered yet.
-TEST(PollIoService, remove_fd_from_empty) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-  EXPECT_EQ(io_svc.remove_fd(fds.first),
-            stdx::make_unexpected(
-                make_error_code(std::errc::no_such_file_or_directory)));
-
-  net::impl::socket::close(fds.first);
-  net::impl::socket::close(fds.second);
-}
-
-/**
- * one FD with multiple events ready at the same time.
- */
-TEST(PollIoService, one_fd_many_events) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// add write interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_write));
-  SCOPED_TRACE("// add read interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_read));
-
-  SCOPED_TRACE("// check fd-interest after add-write");
-  auto interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), POLLIN | POLLOUT);
-
-  // make sure the 'wait_read' fires too.
-  auto write_res = net::impl::socket::write(fds.second, ".", 1);
-  ASSERT_TRUE(write_res) << write_res.error();
-  EXPECT_EQ(*write_res, 1);
-
-  using namespace std::chrono_literals;
-
-  SCOPED_TRACE("// poll_one() should fire for the 1st event.");
-  auto poll_res = io_svc.poll_one(100ms);
-  ASSERT_TRUE(poll_res) << poll_res.error();
-  EXPECT_EQ(poll_res->fd, fds.first);
-
-  SCOPED_TRACE("// remove interest on fd.");
-  auto remove_res = io_svc.remove_fd(fds.first);
-  ASSERT_TRUE(remove_res) << remove_res.error();
-
-  SCOPED_TRACE(
-      "// poll_one() should not fire the 2nd time as the fd is removed.");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_EQ(poll_res,
-            stdx::make_unexpected(make_error_code(std::errc::timed_out)));
-}
-
-/**
- * one FD with multiple events ready at the same time.
- *
- * but remove interest along the way.
- */
-TEST(PollIoService, one_fd_many_events_removed) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// add write interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_write));
-  SCOPED_TRACE("// add read interest");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_read));
-
-  SCOPED_TRACE("// check fd-interest after add-write");
-  auto interest_res = io_svc.interest(fds.first);
-  ASSERT_TRUE(interest_res);
-  EXPECT_EQ(interest_res.value(), POLLIN | POLLOUT);
-
-  // make sure the 'wait_read' fires too.
-  auto write_res = net::impl::socket::write(fds.second, ".", 1);
-  ASSERT_TRUE(write_res) << write_res.error();
-  EXPECT_EQ(*write_res, 1);
-
-  using namespace std::chrono_literals;
-
-  SCOPED_TRACE("// poll_one() should fire for the 1st event.");
-  auto poll_res = io_svc.poll_one(100ms);
-  ASSERT_TRUE(poll_res) << poll_res.error();
-  EXPECT_EQ(poll_res->fd, fds.first);
-
-  SCOPED_TRACE("// poll_one() should fire a 2nd time for the other event.");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_TRUE(poll_res) << poll_res.error();
-  EXPECT_EQ(poll_res->fd, fds.first);
-
-  SCOPED_TRACE("// all events fired.");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_EQ(poll_res,
-            stdx::make_unexpected(make_error_code(std::errc::timed_out)));
-}
-
-/**
- * POLLHUP is sent on 'socket-close' even if no event is waited for.
- */
-TEST(PollIoService, hup_without_event_wanted) {
-#if defined(__APPLE__) || defined(__sun)
-  GTEST_SKIP() << "This platorm does not generate POLLHUP on closed sockets";
-#endif
-
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// add write interest");
-  {
-    auto add_res =
-        io_svc.add_fd_interest(fds.first, net::socket_base::wait_write);
-    EXPECT_TRUE(add_res) << add_res.error();
-  }
-
-  SCOPED_TRACE("// check fd-interest after add-write");
-  {
-    auto interest_res = io_svc.interest(fds.first);
-    ASSERT_TRUE(interest_res);
-    EXPECT_EQ(std::bitset<32>(*interest_res), std::bitset<32>(POLLOUT));
-  }
-
-  using namespace std::chrono_literals;
-
-  SCOPED_TRACE("// poll_one() should fire for the 1st event.");
-  auto poll_res = io_svc.poll_one(100ms);
-  ASSERT_TRUE(poll_res) << poll_res.error();
-
-  SCOPED_TRACE("// fd is still watched, but has no handler");
-  {
-    auto interest_res = io_svc.interest(fds.first);
-    ASSERT_TRUE(interest_res);
-    EXPECT_EQ(std::bitset<32>(*interest_res), std::bitset<32>(0));
-  }
-
-  SCOPED_TRACE("// shutdown both sides of the socket, but keep it open.");
-  {
-    auto shutdown_res = net::impl::socket::shutdown(
-        fds.first, static_cast<int>(net::socket_base::shutdown_send));
-    ASSERT_TRUE(shutdown_res) << shutdown_res.error();
-  }
-
-  {
-    auto shutdown_res = net::impl::socket::shutdown(
-        fds.second, static_cast<int>(net::socket_base::shutdown_send));
-    ASSERT_TRUE(shutdown_res) << shutdown_res.error();
-  }
-
-  SCOPED_TRACE("// poll_one() should NOT fire with a HUP event (yet).");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_FALSE(poll_res) << poll_res.value();
-
-  {
-    auto add_res =
-        io_svc.add_fd_interest(fds.first, net::socket_base::wait_error);
-    EXPECT_TRUE(add_res) << add_res.error();
-  }
-
-  SCOPED_TRACE("// check fd-interest after add-write");
-  {
-    auto interest_res = io_svc.interest(fds.first);
-    ASSERT_TRUE(interest_res);
-    EXPECT_EQ(std::bitset<32>(*interest_res),
-              std::bitset<32>(POLLHUP | POLLERR));
-  }
-
-  SCOPED_TRACE("// poll_one() should fire with a HUP event.");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_TRUE(poll_res) << poll_res.error();
-
-  net::fd_event expected_event{fds.first, POLLHUP};
-  ASSERT_EQ(*poll_res, expected_event);
-
-  // close the socket as it would trigger a POLLHUP on the next poll_one.
-  EXPECT_TRUE(io_svc.remove_fd(fds.first));
-  EXPECT_TRUE(net::impl::socket::close(fds.first));
-
-  SCOPED_TRACE("// all events fired.");
-  poll_res = io_svc.poll_one(100ms);
-  ASSERT_EQ(poll_res,
-            stdx::make_unexpected(make_error_code(std::errc::timed_out)));
-}
-
-/**
- * HUP, add/remove
- */
-TEST(PollIoService, hup_add_remove) {
-  auto res = net::impl::socket::socketpair(AF_SOCKETPAIR, SOCK_STREAM, 0);
-  ASSERT_TRUE(res) << res.error();
-  auto fds = *res;
-
-  Scope_guard guard([&]() {
-    net::impl::socket::close(fds.first);
-    net::impl::socket::close(fds.second);
-  });
-
-  net::poll_io_service io_svc;
-
-  ASSERT_TRUE(io_svc.open());
-
-  SCOPED_TRACE("// add interest for HUP/ERR");
-  EXPECT_TRUE(io_svc.add_fd_interest(fds.first, net::socket_base::wait_error));
-
-  SCOPED_TRACE("// check fd-interest after add interest");
-  {
-    auto interest_res = io_svc.interest(fds.first);
-    ASSERT_TRUE(interest_res);
-    EXPECT_EQ(std::bitset<32>(*interest_res),
-              std::bitset<32>(POLLHUP | POLLERR));
-  }
-
-  // ok, and noop
-  EXPECT_TRUE(io_svc.remove_fd_interest(fds.first, POLLHUP | POLLERR));
-
-  SCOPED_TRACE("// check fd-interest after add interest");
-  {
-    // POLLHUP and POLLERR are always active and not added to the interest.
-    auto interest_res = io_svc.interest(fds.first);
-    ASSERT_TRUE(interest_res);
-    EXPECT_EQ(std::bitset<32>(*interest_res), std::bitset<32>(0));
-  }
-}
-
-int main(int argc, char *argv[]) {
-  net::impl::socket::init();
-
-  ::testing::InitGoogleTest(&argc, argv);
-  return RUN_ALL_TESTS();
-}
-- 
2.37.2

