From afc24e0c8c18775938d21cbf26d952748707b5e9 Mon Sep 17 00:00:00 2001
From: Corey Bryant <corey.bryant@canonical.com>
Date: Fri, 27 Jan 2023 17:20:48 -0500
Subject: [PATCH 71/86] Revert "WL#12772 connection-sharing [6/28] - processor,
 forwarder"

This reverts commit 41012ad443abeced55009a158064b86a3232ce6a.
---
 router/src/routing/src/CMakeLists.txt        |   3 -
 router/src/routing/src/classic_connection.cc |  30 +-
 router/src/routing/src/classic_connection.h  |  41 +-
 router/src/routing/src/classic_forwarder.cc  | 403 -------------------
 router/src/routing/src/classic_forwarder.h   |  99 -----
 router/src/routing/src/processor.cc          | 142 -------
 router/src/routing/src/processor.h           | 150 -------
 7 files changed, 19 insertions(+), 849 deletions(-)
 delete mode 100644 router/src/routing/src/classic_forwarder.cc
 delete mode 100644 router/src/routing/src/classic_forwarder.h
 delete mode 100644 router/src/routing/src/processor.cc
 delete mode 100644 router/src/routing/src/processor.h

diff --git a/router/src/routing/src/CMakeLists.txt b/router/src/routing/src/CMakeLists.txt
index 87ac4853102..d4c597efa7e 100644
--- a/router/src/routing/src/CMakeLists.txt
+++ b/router/src/routing/src/CMakeLists.txt
@@ -45,9 +45,6 @@ ADD_LIBRARY(routing SHARED
   connection.cc
   blocked_endpoints.cc
 
-  processor.cc
-  classic_forwarder.cc
-
   sql_value.cc
 )
 TARGET_LINK_LIBRARIES(routing
diff --git a/router/src/routing/src/classic_connection.cc b/router/src/routing/src/classic_connection.cc
index f880c8e4ba8..db079d041aa 100644
--- a/router/src/routing/src/classic_connection.cc
+++ b/router/src/routing/src/classic_connection.cc
@@ -925,44 +925,39 @@ void MysqlRoutingClassicConnection::async_run() {
   }
 }
 
-void MysqlRoutingClassicConnection::send_server_failed(std::error_code ec,
-                                                       bool call_finish) {
+void MysqlRoutingClassicConnection::send_server_failed(std::error_code ec) {
 #if defined(DEBUG_IO)
   std::cerr << __LINE__ << ": r->s: " << ec.message() << ", next: finish\n";
 #endif
 
-  server_socket_failed(ec, call_finish);
+  server_socket_failed(ec);
 }
 
-void MysqlRoutingClassicConnection::recv_server_failed(std::error_code ec,
-                                                       bool call_finish) {
+void MysqlRoutingClassicConnection::recv_server_failed(std::error_code ec) {
 #if defined(DEBUG_IO)
   std::cerr << __LINE__ << ": r<-s: " << ec.message() << ", next: finish\n";
 #endif
 
-  server_socket_failed(ec, call_finish);
+  server_socket_failed(ec);
 }
 
-void MysqlRoutingClassicConnection::send_client_failed(std::error_code ec,
-                                                       bool call_finish) {
+void MysqlRoutingClassicConnection::send_client_failed(std::error_code ec) {
 #if defined(DEBUG_IO)
   std::cerr << __LINE__ << ": c<-r: " << ec.message() << ", next: finish\n";
 #endif
 
-  client_socket_failed(ec, call_finish);
+  client_socket_failed(ec);
 }
 
-void MysqlRoutingClassicConnection::recv_client_failed(std::error_code ec,
-                                                       bool call_finish) {
+void MysqlRoutingClassicConnection::recv_client_failed(std::error_code ec) {
 #if defined(DEBUG_IO)
   std::cerr << __LINE__ << ": c->r: " << ec.message() << ", next: finish\n";
 #endif
 
-  client_socket_failed(ec, call_finish);
+  client_socket_failed(ec);
 }
 
-void MysqlRoutingClassicConnection::server_socket_failed(std::error_code ec,
-                                                         bool call_finish) {
+void MysqlRoutingClassicConnection::server_socket_failed(std::error_code ec) {
   auto &server_conn = this->socket_splicer()->server_conn();
 
   if (server_conn.is_open()) {
@@ -979,11 +974,10 @@ void MysqlRoutingClassicConnection::server_socket_failed(std::error_code ec,
     (void)server_conn.close();
   }
 
-  if (call_finish) finish();
+  finish();
 }
 
-void MysqlRoutingClassicConnection::client_socket_failed(std::error_code ec,
-                                                         bool call_finish) {
+void MysqlRoutingClassicConnection::client_socket_failed(std::error_code ec) {
   auto &client_conn = this->socket_splicer()->client_conn();
 
   if (client_conn.is_open()) {
@@ -1017,7 +1011,7 @@ void MysqlRoutingClassicConnection::client_socket_failed(std::error_code ec,
     (void)client_conn.close();
   }
 
-  if (call_finish) finish();
+  finish();
 }
 
 void MysqlRoutingClassicConnection::async_send_client(Function next) {
diff --git a/router/src/routing/src/classic_connection.h b/router/src/routing/src/classic_connection.h
index e5680d74a74..684408d457c 100644
--- a/router/src/routing/src/classic_connection.h
+++ b/router/src/routing/src/classic_connection.h
@@ -37,7 +37,6 @@
 #include "mysqlrouter/classic_protocol_message.h"
 #include "mysqlrouter/classic_protocol_session_track.h"
 #include "mysqlrouter/connection_pool.h"
-#include "processor.h"
 #include "sql_exec_context.h"
 #include "tracer.h"
 
@@ -265,17 +264,17 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
 
   void async_run();
 
-  void send_server_failed(std::error_code ec, bool call_finish = true);
+  void send_server_failed(std::error_code ec);
 
-  void recv_server_failed(std::error_code ec, bool call_finish = true);
+  void recv_server_failed(std::error_code ec);
 
-  void send_client_failed(std::error_code ec, bool call_finish = true);
+  void send_client_failed(std::error_code ec);
 
-  void recv_client_failed(std::error_code ec, bool call_finish = true);
+  void recv_client_failed(std::error_code ec);
 
-  void server_socket_failed(std::error_code ec, bool call_finish = true);
+  void server_socket_failed(std::error_code ec);
 
-  void client_socket_failed(std::error_code ec, bool call_finish = true);
+  void client_socket_failed(std::error_code ec);
 
  private:
   enum class Function {
@@ -692,32 +691,7 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
     }
   }
 
-  // a stack of processors
-  //
-  // take the last processor until its done.
-  //
-  // Flow -> Greeting | Command
-  //   Greeting -> Connect -> Server::Greeting
-  //     Server::Greeting -> Server::Greeting::Greeting |
-  //     Server::Greeting::Error Server::Greeting::Error -> Error::Fatal
-  //     Server::Greeting::Greeting -> Client::Greeting
-  //     Client::Greeting -> TlsConnect | Server::Greeting::Response
-  //     TlsConnect -> Client::Greeting::Full | Error::Fatal
-  //     Client::Greeting::Full -> Server::Ok | Auth::Switch | Server::Error
-  //     Auth::Switch -> ...
-  //       Auth
-  //     Server::Ok -> Command
-  //   Command ->
-  //
-  std::vector<std::unique_ptr<Processor>> processors_;
-
  public:
-  void push_processor(std::unique_ptr<Processor> processor) {
-    return processors_.push_back(std::move(processor));
-  }
-
-  void pop_processor() { processors_.pop_back(); }
-
   stdx::expected<void, std::error_code> track_session_changes(
       net::const_buffer session_trackers,
       classic_protocol::capabilities::value_type caps,
@@ -1055,7 +1029,6 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
   // something was received on the client channel.
   void client_recv_cmd();
 
- public:
   ClassicProtocolState *client_protocol() {
     return dynamic_cast<ClassicProtocolState *>(
         socket_splicer()->client_conn().protocol());
@@ -1145,13 +1118,13 @@ class MysqlRoutingClassicConnection : public MySQLRoutingConnectionBase {
 
   connector_type &connector() { return connector_; }
   const connector_type &connector() const { return connector_; }
-
   bool greeting_from_router() const {
     return !((source_ssl_mode() == SslMode::kPassthrough) ||
              (source_ssl_mode() == SslMode::kPreferred &&
               dest_ssl_mode() == SslMode::kAsClient));
   }
 
+ public:
   void requires_tls(bool v) { requires_tls_ = v; }
 
   bool requires_tls() const { return requires_tls_; }
diff --git a/router/src/routing/src/classic_forwarder.cc b/router/src/routing/src/classic_forwarder.cc
deleted file mode 100644
index 0dff941b3c3..00000000000
--- a/router/src/routing/src/classic_forwarder.cc
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "classic_forwarder.h"
-
-#include "classic_connection.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/tls_error.h"
-#include "tracer.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-// forwarder
-
-static bool has_frame_header(ClassicProtocolState *src_protocol) {
-  return src_protocol->current_frame().has_value();
-}
-
-static stdx::expected<std::pair<size_t, ClassicProtocolState::FrameInfo>,
-                      std::error_code>
-decode_frame_header(const net::const_buffer &recv_buf) {
-  const auto decode_res =
-      classic_protocol::decode<classic_protocol::frame::Header>(
-          net::buffer(recv_buf), 0);
-  if (!decode_res) {
-    const auto ec = decode_res.error();
-
-    if (ec == classic_protocol::codec_errc::not_enough_input) {
-      return stdx::make_unexpected(make_error_code(TlsErrc::kWantRead));
-    }
-    return decode_res.get_unexpected();
-  }
-
-  const auto frame_header_res = decode_res.value();
-  const auto header_size = frame_header_res.first;
-  const auto seq_id = frame_header_res.second.seq_id();
-  const auto payload_size = frame_header_res.second.payload_size();
-
-  const auto frame_size = header_size + payload_size;
-
-  return {std::in_place, header_size,
-          ClassicProtocolState::FrameInfo{seq_id, frame_size, 0u}};
-}
-
-/**
- * ensure current_frame() has a current frame-info.
- *
- * @post after success returned, src_protocol->current_frame() has a frame
- * decoded.
- */
-static stdx::expected<void, std::error_code> ensure_frame_header(
-    Channel *src_channel, ClassicProtocolState *src_protocol) {
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  const size_t min_size{4};
-  const auto cur_size = recv_buf.size();
-  if (cur_size < min_size) {
-    // read the rest of the header.
-    auto read_res = src_channel->read_to_plain(min_size - cur_size);
-    if (!read_res) return read_res.get_unexpected();
-
-    if (recv_buf.size() < min_size) {
-      return stdx::make_unexpected(make_error_code(TlsErrc::kWantRead));
-    }
-  }
-
-  const auto decode_frame_res = decode_frame_header(net::buffer(recv_buf));
-  if (!decode_frame_res) return decode_frame_res.get_unexpected();
-
-  src_protocol->current_frame() = std::move(decode_frame_res.value()).second;
-
-  return {};
-}
-
-static stdx::expected<size_t, std::error_code> forward_frame_header_as_is(
-    Channel *src_channel, Channel *dst_channel, size_t header_size) {
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  return dst_channel->write(net::buffer(recv_buf, header_size));
-}
-
-static stdx::expected<size_t, std::error_code> write_frame_header(
-    Channel *dst_channel, classic_protocol::frame::Header frame_header) {
-  std::vector<uint8_t> dest_header;
-  const auto encode_res =
-      classic_protocol::encode<classic_protocol::frame::Header>(
-          frame_header, {}, net::dynamic_buffer(dest_header));
-  if (!encode_res) {
-    return encode_res.get_unexpected();
-  }
-
-  return dst_channel->write(net::buffer(dest_header));
-}
-
-static stdx::expected<size_t, std::error_code> forward_header(
-    Channel *src_channel, ClassicProtocolState *src_protocol,
-    Channel *dst_channel, ClassicProtocolState *dst_protocol,
-    size_t header_size, size_t payload_size) {
-  if (src_protocol->seq_id() == dst_protocol->seq_id()) {
-    return forward_frame_header_as_is(src_channel, dst_channel, header_size);
-  } else {
-    auto write_res =
-        write_frame_header(dst_channel, {payload_size, dst_protocol->seq_id()});
-    if (!write_res) return write_res.get_unexpected();
-
-    // return the bytes that were skipped from the recv_buffer.
-    return header_size;
-  }
-}
-
-/**
- * @returns frame-is-done on success and std::error_code on error.
- */
-static stdx::expected<bool, std::error_code> forward_frame_from_channel(
-    Channel *src_channel, ClassicProtocolState *src_protocol,
-    Channel *dst_channel, ClassicProtocolState *dst_protocol) {
-  if (!has_frame_header(src_protocol)) {
-    auto read_res = ensure_frame_header(src_channel, src_protocol);
-    if (!read_res) return read_res.get_unexpected();
-  }
-
-  auto &current_frame = src_protocol->current_frame().value();
-
-  auto &recv_buf = src_channel->recv_plain_buffer();
-  if (current_frame.forwarded_frame_size_ == 0) {
-    const size_t header_size{4};
-
-    const uint8_t seq_id = current_frame.seq_id_;
-    const size_t payload_size = current_frame.frame_size_ - header_size;
-
-    src_protocol->seq_id(seq_id);
-
-    // if one side starts a new command, reset the sequence-id for the other
-    // side too.
-    if (seq_id == 0) {
-      dst_protocol->seq_id(0);
-    } else {
-      ++dst_protocol->seq_id();
-    }
-
-    auto forward_res = forward_header(src_channel, src_protocol, dst_channel,
-                                      dst_protocol, header_size, payload_size);
-    if (!forward_res) return forward_res.get_unexpected();
-
-    const size_t transferred = forward_res.value();
-
-    current_frame.forwarded_frame_size_ = transferred;
-
-    // skip the original header
-    net::dynamic_buffer(recv_buf).consume(transferred);
-  }
-
-#if 0
-  std::cerr << __LINE__ << ": "
-            << "seq-id: " << (int)current_frame.seq_id_ << ", "
-            << "frame-size: " << current_frame.frame_size_ << ", "
-            << "forwarded so far: " << current_frame.forwarded_frame_size_
-            << "\n";
-#endif
-
-  // forward the (rest of the) payload.
-
-  const size_t rest_of_frame_size =
-      current_frame.frame_size_ - current_frame.forwarded_frame_size_;
-
-  if (rest_of_frame_size > 0) {
-    // try to fill the recv-buf up to the end of the frame
-    if (rest_of_frame_size > recv_buf.size()) {
-      // ... not more than 16k to avoid reading all 16M at once.
-      auto read_res = src_channel->read_to_plain(
-          std::min(rest_of_frame_size - recv_buf.size(), size_t{16 * 1024}));
-      if (!read_res) return read_res.get_unexpected();
-    }
-
-    if (recv_buf.empty()) {
-      return stdx::make_unexpected(make_error_code(TlsErrc::kWantRead));
-    }
-
-    const auto write_res =
-        dst_channel->write(net::buffer(recv_buf, rest_of_frame_size));
-    if (!write_res) return write_res.get_unexpected();
-
-    size_t transferred = write_res.value();
-    current_frame.forwarded_frame_size_ += transferred;
-
-    net::dynamic_buffer(recv_buf).consume(transferred);
-  }
-
-  bool src_side_is_done{false};
-  if (current_frame.forwarded_frame_size_ == current_frame.frame_size_) {
-#if 0
-    std::cerr << __LINE__ << ": "
-              << "seq-id: " << (int)(current_frame.seq_id_) << ", done"
-              << "\n";
-#endif
-    // payload-size + frame-size
-    bool is_overlong_packet = current_frame.frame_size_ == (0xffffff + 4);
-
-    // frame is forwarded, reset for the next one.
-    src_protocol->current_frame().reset();
-
-    if (!is_overlong_packet) {
-      src_side_is_done = true;
-      src_protocol->current_msg_type().reset();
-    }
-  } else {
-#if 0
-    std::cerr << __LINE__ << ": partial-frame: "
-              << "seq-id: " << (int)(current_frame.seq_id_) << ", "
-              << "rest-of-frame: "
-              << (current_frame.frame_size_ -
-                  current_frame.forwarded_frame_size_)
-              << "\n";
-#endif
-  }
-
-  dst_channel->flush_to_send_buf();
-
-  return src_side_is_done;
-}
-
-static stdx::expected<Forwarder::ForwardResult, std::error_code>
-forward_frame_sequence(Channel *src_channel, ClassicProtocolState *src_protocol,
-                       Channel *dst_channel,
-                       ClassicProtocolState *dst_protocol) {
-  const auto forward_res = forward_frame_from_channel(
-      src_channel, src_protocol, dst_channel, dst_protocol);
-  if (!forward_res) {
-    auto ec = forward_res.error();
-
-    if (ec == TlsErrc::kWantRead) {
-      if (!dst_channel->send_buffer().empty()) {
-        return Forwarder::ForwardResult::kWantSendDestination;
-      }
-
-      return Forwarder::ForwardResult::kWantRecvSource;
-    }
-
-    return forward_res.get_unexpected();
-  }
-
-  // if forward-frame succeeded, then the send-buffer should be all sent.
-  if (dst_channel->send_buffer().empty()) {
-    log_debug("%d: %s", __LINE__, "send-buffer is empty.");
-
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-
-  const auto src_is_done = forward_res.value();
-  if (src_is_done) {
-    return Forwarder::ForwardResult::kFinished;
-  } else {
-    return Forwarder::ForwardResult::kWantSendDestination;
-  }
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerToClientForwarder::process() {
-  switch (stage()) {
-    case Stage::Forward:
-      return forward();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ServerToClientForwarder::forward() {
-  auto forward_res = forward_frame_sequence();
-  if (!forward_res) {
-    return recv_server_failed(forward_res.error());
-  }
-
-  switch (forward_res.value()) {
-    case ForwardResult::kWantRecvDestination:
-      return Result::RecvFromClient;
-    case ForwardResult::kWantSendDestination:
-      return Result::SendToClient;
-    case ForwardResult::kWantRecvSource:
-      return Result::RecvFromServer;
-    case ForwardResult::kWantSendSource:
-      return Result::SendToServer;
-    case ForwardResult::kFinished: {
-      stage(Stage::Done);
-
-      auto *socket_splicer = connection()->socket_splicer();
-      auto dst_channel = socket_splicer->client_channel();
-
-      // if flush is optional and send-buffer is not too full, skip the flush.
-      //
-      // force-send-buffer-size is a trade-off between latency,
-      // syscall-latency and memory usage:
-      //
-      // - buffering more: less send()-syscalls which helps with small
-      // resultset.
-      // - buffering less: faster forwarding of smaller packets if the server
-      // is send to generate packets.
-      constexpr const size_t kForceFlushAfterBytes{16 * 1024};
-
-      if (flush_before_next_func_optional_ &&
-          dst_channel->send_buffer().size() < kForceFlushAfterBytes) {
-        return Result::Again;
-      } else if (dst_channel->send_buffer().empty()) {
-        return Result::Again;
-      } else {
-        return Result::SendToClient;
-      }
-    }
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Forwarder::ForwardResult, std::error_code>
-ServerToClientForwarder::forward_frame_sequence() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->server_channel();
-  auto src_protocol = connection()->server_protocol();
-  auto dst_channel = socket_splicer->client_channel();
-  auto dst_protocol = connection()->client_protocol();
-
-  return ::forward_frame_sequence(src_channel, src_protocol, dst_channel,
-                                  dst_protocol);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ClientToServerForwarder::process() {
-  switch (stage()) {
-    case Stage::Forward:
-      return forward();
-    case Stage::Done:
-      return Result::Done;
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Processor::Result, std::error_code>
-ClientToServerForwarder::forward() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto dst_channel = socket_splicer->server_channel();
-
-  auto forward_res = forward_frame_sequence();
-  if (!forward_res) {
-    return recv_client_failed(forward_res.error());
-  }
-
-  switch (forward_res.value()) {
-    case ForwardResult::kWantRecvSource:
-      return Result::RecvFromClient;
-    case ForwardResult::kWantSendSource:
-      return Result::SendToClient;
-    case ForwardResult::kWantRecvDestination:
-      return Result::RecvFromServer;
-    case ForwardResult::kWantSendDestination:
-      return Result::SendToServer;
-    case ForwardResult::kFinished:
-      stage(Stage::Done);
-
-      if (dst_channel->send_buffer().empty()) {
-        return Result::Again;
-      } else {
-        return Result::SendToServer;
-      }
-  }
-
-  harness_assert_this_should_not_execute();
-}
-
-stdx::expected<Forwarder::ForwardResult, std::error_code>
-ClientToServerForwarder::forward_frame_sequence() {
-  auto *socket_splicer = connection()->socket_splicer();
-  auto src_channel = socket_splicer->client_channel();
-  auto src_protocol = connection()->client_protocol();
-  auto dst_channel = socket_splicer->server_channel();
-  auto dst_protocol = connection()->server_protocol();
-
-  return ::forward_frame_sequence(src_channel, src_protocol, dst_channel,
-                                  dst_protocol);
-}
diff --git a/router/src/routing/src/classic_forwarder.h b/router/src/routing/src/classic_forwarder.h
deleted file mode 100644
index ea641e2e87a..00000000000
--- a/router/src/routing/src/classic_forwarder.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_FORWARDER_INCLUDED
-#define ROUTING_CLASSIC_FORWARDER_INCLUDED
-
-#include "processor.h"
-
-/**
- * a generic forwarder for mysql packets.
- */
-class Forwarder : public Processor {
- public:
-  using Processor::Processor;
-
-  enum class ForwardResult {
-    kWantRecvSource,
-    kWantSendSource,
-    kWantRecvDestination,
-    kWantSendDestination,
-    kFinished,
-  };
-};
-
-/**
- * forward a mysql packet from the client to the server.
- */
-class ClientToServerForwarder : public Forwarder {
- public:
-  using Forwarder::Forwarder;
-
-  enum class Stage {
-    Forward,
-    Done,
-  };
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<ForwardResult, std::error_code> forward_frame_sequence();
-  stdx::expected<Result, std::error_code> forward();
-
-  Stage stage_{Stage::Forward};
-};
-
-/**
- * forward a mysql packet from the server to the client.
- */
-class ServerToClientForwarder : public Forwarder {
- public:
-  enum class Stage {
-    Forward,
-    Done,
-  };
-
-  ServerToClientForwarder(MysqlRoutingClassicConnection *conn,
-                          bool flush_before_next_func_optional = true)
-      : Forwarder(conn),
-        flush_before_next_func_optional_(flush_before_next_func_optional) {}
-
-  stdx::expected<Result, std::error_code> process() override;
-
-  void stage(Stage stage) { stage_ = stage; }
-  Stage stage() const { return stage_; }
-
- private:
-  stdx::expected<ForwardResult, std::error_code> forward_frame_sequence();
-  stdx::expected<Result, std::error_code> forward();
-
-  bool flush_before_next_func_optional_;
-
-  Stage stage_{Stage::Forward};
-};
-
-#endif
diff --git a/router/src/routing/src/processor.cc b/router/src/routing/src/processor.cc
deleted file mode 100644
index 78f04f580d9..00000000000
--- a/router/src/routing/src/processor.cc
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <memory>  // make_unique
-
-#include "classic_connection.h"
-#include "classic_forwarder.h"
-#include "mysql/harness/logging/logging.h"
-#include "mysql/harness/stdx/expected.h"
-#include "mysql/harness/tls_error.h"
-#include "processor.h"
-
-IMPORT_LOG_FUNCTIONS()
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::send_server_failed(std::error_code ec) {
-  // don't call finish() as the calling loop() will call it for us when the
-  // error is returned.
-  connection()->send_server_failed(ec, false);
-
-  return stdx::make_unexpected(ec);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::recv_server_failed(std::error_code ec) {
-  if (ec == TlsErrc::kWantRead) return Result::RecvFromServer;
-
-  // don't call finish() as the calling loop() will call it for us when the
-  // error is returned.
-  connection()->recv_server_failed(ec, false);
-
-  return stdx::make_unexpected(ec);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::send_client_failed(std::error_code ec) {
-  // don't call finish() as the calling loop() will call it for us when the
-  // error is returned.
-  connection()->send_client_failed(ec, false);
-
-  return stdx::make_unexpected(ec);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::recv_client_failed(std::error_code ec) {
-  if (ec == TlsErrc::kWantRead) return Result::RecvFromClient;
-
-  // don't call finish() as the calling loop() will call it for us when the
-  // error is returned.
-  connection()->recv_client_failed(ec, false);
-
-  return stdx::make_unexpected(ec);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::server_socket_failed(std::error_code ec) {
-  // don't call finish() as the calling loop() will call it for us when the
-  // error is returned.
-  connection()->server_socket_failed(ec, false);
-
-  return stdx::make_unexpected(ec);
-}
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::client_socket_failed(std::error_code ec) {
-  // don't call finish() as the calling loop() will call it for us when the
-  // error is returned.
-  connection()->client_socket_failed(ec, false);
-
-  return stdx::make_unexpected(ec);
-}
-
-stdx::expected<void, std::error_code> Processor::discard_current_msg(
-    Channel *src_channel, ClassicProtocolState *src_protocol) {
-  auto &opt_current_frame = src_protocol->current_frame();
-  if (!opt_current_frame) return {};
-
-  auto &current_frame = *opt_current_frame;
-
-  auto &recv_buf = src_channel->recv_plain_buffer();
-
-  if (recv_buf.size() < current_frame.frame_size_) {
-    // received message is incomplete.
-    return stdx::make_unexpected(make_error_code(std::errc::bad_message));
-  }
-  if (current_frame.forwarded_frame_size_ != 0) {
-    // partially forwarded already.
-    return stdx::make_unexpected(make_error_code(std::errc::invalid_argument));
-  }
-
-  net::dynamic_buffer(recv_buf).consume(current_frame.frame_size_);
-
-  // unset current frame and also current-msg
-  src_protocol->current_frame().reset();
-  src_protocol->current_msg_type().reset();
-
-  return {};
-}
-
-void Processor::log_fatal_error_code(const char *msg, std::error_code ec) {
-  log_error("%s: %s (%s:%d)", msg, ec.message().c_str(), ec.category().name(),
-            ec.value());
-}
-
-void Processor::trace(Tracer::Event e) { return connection()->trace(e); }
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::forward_server_to_client(bool noflush) {
-  connection()->push_processor(
-      std::make_unique<ServerToClientForwarder>(connection(), noflush));
-
-  return Result::Again;
-}
-
-stdx::expected<Processor::Result, std::error_code>
-Processor::forward_client_to_server() {
-  connection()->push_processor(
-      std::make_unique<ClientToServerForwarder>(connection()));
-
-  return Result::Again;
-}
diff --git a/router/src/routing/src/processor.h b/router/src/routing/src/processor.h
deleted file mode 100644
index 54da3ecd53c..00000000000
--- a/router/src/routing/src/processor.h
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
-  Copyright (c) 2022, Oracle and/or its affiliates.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License, version 2.0,
-  as published by the Free Software Foundation.
-
-  This program is also distributed with certain software (including
-  but not limited to OpenSSL) that is licensed under separate terms,
-  as designated in a particular file or component or in included license
-  documentation.  The authors of MySQL hereby grant you an additional
-  permission to link the program and your derivative works with the
-  separately licensed software that they have included with MySQL.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ROUTING_CLASSIC_PROCESSOR_INCLUDED
-#define ROUTING_CLASSIC_PROCESSOR_INCLUDED
-
-#include "basic_protocol_splicer.h"
-#include "tracer.h"
-
-class MysqlRoutingClassicConnection;
-class ClassicProtocolState;
-
-/**
- * base class of all the processors.
- *
- * Processor
- *
- * - have their own internal state
- * - expose a process() function which will be called until
- *   it returns Result::Done
- *
- * Processors are stacked.
- *
- * The methods:
- *
- * - push_processor()
- * - pop_processor()
- *
- * allow to add and remove elements for the stack.
- *
- * The top-most processor's process() function is called.
- */
-class BasicProcessor {
- public:
-  enum class Result {
-    Again,           // will invoke the process() of the top-most-processor
-    RecvFromClient,  // wait for recv from client and invoke ...
-    SendToClient,    // wait for send-to-client and invoke ...
-    RecvFromServer,  // wait for recv from server and invoke ...
-    RecvFromBoth,    // wait for recv from client and server and invoke ..
-    SendToServer,    // wait for send-to-server and invoke ...
-    SendableToServer,
-
-    Done,  // pop this processor and invoke the top-most-processor's process()
-
-    Void,
-  };
-
-  BasicProcessor(MysqlRoutingClassicConnection *conn) : conn_(conn) {}
-
-  virtual ~BasicProcessor() = default;
-
-  const MysqlRoutingClassicConnection *connection() const { return conn_; }
-
-  MysqlRoutingClassicConnection *connection() { return conn_; }
-
-  virtual stdx::expected<Result, std::error_code> process() = 0;
-
- private:
-  MysqlRoutingClassicConnection *conn_;
-};
-
-/**
- * a processor base class with helper functions.
- */
-class Processor : public BasicProcessor {
- public:
-  using BasicProcessor::BasicProcessor;
-
- protected:
-  stdx::expected<Result, std::error_code> send_server_failed(
-      std::error_code ec);
-
-  stdx::expected<Result, std::error_code> recv_server_failed(
-      std::error_code ec);
-
-  stdx::expected<Result, std::error_code> send_client_failed(
-      std::error_code ec);
-
-  stdx::expected<Result, std::error_code> recv_client_failed(
-      std::error_code ec);
-
-  stdx::expected<Result, std::error_code> server_socket_failed(
-      std::error_code ec);
-
-  stdx::expected<Result, std::error_code> client_socket_failed(
-      std::error_code ec);
-
-  /**
-   * discard to current message.
-   *
-   * @pre ensure_full_frame() must true.
-   */
-  stdx::expected<void, std::error_code> discard_current_msg(
-      Channel *src_channel, ClassicProtocolState *src_protocol);
-
-  /**
-   * log a message with error-code as error.
-   */
-  static void log_fatal_error_code(const char *msg, std::error_code ec);
-
-  // see MysqlClassicConnection::trace()
-  void trace(Tracer::Event e);
-
-  /**
-   * forward the current packet from the server-side to the client-side.
-   *
-   * use 'noflush' if the next message is from the server side too to allow
-   * merging of multiple server-side packets into one "send-to-client".
-   *
-   * Useful for resultsets which is split into multiple packets.
-   *
-   * Pushes a ServerToClientForwarder to the processor-stack.
-   *
-   * @param noflush if true, it isn't required to wait until the packet is sent
-   * to the client.
-   */
-  stdx::expected<Result, std::error_code> forward_server_to_client(
-      bool noflush = false);
-
-  /**
-   * forward the current packet from the client-side to the server-side.
-   *
-   * Pushes a ClientToServerForwarder to the processor-stack.
-   */
-  stdx::expected<Result, std::error_code> forward_client_to_server();
-};
-
-#endif
-- 
2.37.2

